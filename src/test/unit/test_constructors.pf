@test
subroutine test_torch_tensor_zeros()
  use pFUnit
  use ftorch, only: torch_kFloat32, torch_kCPU, torch_tensor, torch_tensor_delete, torch_tensor_to_array, torch_tensor_zeros
  use ftorch_test_utils, only: assert_allclose
  use, intrinsic :: iso_fortran_env, only: real32
  use iso_c_binding, only: c_bool, c_int, c_int64_t, c_null_ptr

  implicit none

  type(torch_tensor) :: tensor
  integer(c_int) :: ndims
  integer(c_int64_t), dimension(2) :: tensor_shape
  integer(c_int) :: dtype
  integer(c_int) :: device_type
  integer(c_int) :: device_index
  logical(c_bool) :: requires_grad
  real(kind=real32), dimension(:,:), pointer :: out_data
  real(kind=real32), dimension(2,3) :: expected
  logical :: test_pass

  ndims = 2
  tensor_shape = [2, 3]
  dtype = torch_kFloat32
  device_type = torch_kCPU
  device_index = -1
  requires_grad = .false.

  ! Create a tensor of zeros
  call torch_tensor_zeros(tensor, ndims, tensor_shape, dtype, device_type, &
                          device_index, requires_grad)

  ! Check if tensor is not null
  ! @assertTrue(tensor%p /= c_null_ptr) ! FIXME: compiler not happy with this

  call torch_tensor_to_array(tensor, out_data, shape(expected))

  ! Check that the tensor values are all zero
  expected(:,:) = 0.0
  test_pass = assert_allclose(out_data, expected, test_name="test_torch_tensor_zeros")
  @assertTrue(test_pass)

  ! Cleanup
  nullify(out_data)
  call torch_tensor_delete(tensor)

end subroutine test_torch_tensor_zeros

@test
subroutine test_torch_tensor_ones()
  use pFUnit
  use ftorch
  use iso_c_binding, only: c_bool, c_int, c_int64_t, c_null_ptr

  implicit none

  type(torch_tensor) :: tensor
  integer(c_int) :: ndims
  integer(c_int64_t), dimension(2) :: tensor_shape
  integer(c_int) :: dtype
  integer(c_int) :: device_type
  integer(c_int) :: device_index
  logical(c_bool) :: requires_grad

  ndims = 2
  tensor_shape = [2, 3]
  dtype = torch_kFloat32
  device_type = torch_kCPU
  device_index = -1
  requires_grad = .false.

  call torch_tensor_ones(tensor, ndims, tensor_shape, dtype, device_type, &
                         device_index, requires_grad)

  ! Check if tensor is not null
  ! @assertNotEqual(tensor%p, c_null_ptr) ! FIXME: compiler not happy with this

  ! Cleanup
  call torch_tensor_delete(tensor)

end subroutine test_torch_tensor_ones

@test
subroutine test_torch_from_blob()
  use pFUnit
  use ftorch
  use, intrinsic :: iso_c_binding, only : c_ptr, c_int, c_loc
  use, intrinsic :: iso_c_binding, only: c_int, c_int8_t, c_int16_t, c_int32_t, c_int64_t, c_int64_t, &
                                        c_float, c_double, c_char, c_ptr, c_null_ptr

  implicit none

  ! generate test data for torch_tensor_from_blob
  integer(c_int), parameter :: ndims = 2
  integer(c_int64_t), parameter :: tensor_shape(ndims)  = [2,3] ! 2 rows, 3 columns
  integer(kind = 4), target :: data1(2,3)  = reshape([1,2,3,4,5,6], [2,3])  ! 2 rows, 3 columns
  integer(c_int), parameter :: layout(ndims) = [1, 1]
  integer(c_int) :: dtype  = torch_kInt32
  integer(c_int) :: device = torch_kCPU

  type(torch_tensor) :: tensor
  integer(kind = 4) :: data2(3,2) = reshape([1,2,3,4,5,6], [3,2]) ! 3 columns, 2 rows (after reshape)

  ! Smoke test
  call torch_tensor_from_blob(tensor, c_loc(data1), ndims, tensor_shape, layout, dtype, device)

  ! TODO: would be good to try to compare the data in the tensor to the data in data1

  !@assertEqual(tensor, data2)

  ! Cleanup
  call torch_tensor_delete(tensor)

end subroutine test_torch_from_blob
