!| Unit tests for FTorch subroutines that construct tensors.
!
!  * License  
!    FTorch is released under an MIT license.
!    See the [LICENSE](https://github.com/Cambridge-ICCS/FTorch/blob/main/LICENSE)
!    file for details.

@test
subroutine test_torch_tensor_empty()
  use pFUnit
  use ftorch, only: torch_kFloat32, torch_kCPU, torch_tensor, torch_tensor_delete, torch_tensor_empty
  use ftorch_test_utils, only: assert_allclose
  use iso_c_binding, only: c_associated, c_bool, c_int, c_int64_t, c_null_ptr

  implicit none

  type(torch_tensor) :: tensor
  integer(c_int), parameter :: ndims = 2
  integer(c_int64_t), dimension(2) :: tensor_shape
  integer(c_int), parameter :: dtype = torch_kFloat32
  integer(c_int), parameter :: device_type = torch_kCPU
  integer(c_int), parameter :: device_index = -1
  logical(c_bool), parameter :: requires_grad = .false.
  logical :: test_pass

  tensor_shape = [2, 3]

  ! Check the tensor pointer is not associated
  @assertFalse(c_associated(tensor%p))

  ! Create a tensor of zeros
  call torch_tensor_empty(tensor, ndims, tensor_shape, dtype, device_type, &
                          device_index, requires_grad)

  ! Check the tensor pointer is associated
  @assertTrue(c_associated(tensor%p))

  ! Cleanup
  call torch_tensor_delete(tensor)

end subroutine test_torch_tensor_empty

@test
subroutine test_torch_tensor_zeros()
  use pFUnit
  use ftorch, only: torch_kFloat32, torch_kCPU, torch_tensor, torch_tensor_delete, torch_tensor_to_array, torch_tensor_zeros
  use ftorch_test_utils, only: assert_allclose
  use, intrinsic :: iso_fortran_env, only: real32
  use iso_c_binding, only: c_associated, c_bool, c_int, c_int64_t, c_null_ptr

  implicit none

  type(torch_tensor) :: tensor
  integer(c_int), parameter :: ndims = 2
  integer(c_int64_t), dimension(2) :: tensor_shape
  integer(c_int), parameter :: dtype = torch_kFloat32
  integer(c_int), parameter :: device_type = torch_kCPU
  integer(c_int), parameter :: device_index = -1
  logical(c_bool), parameter :: requires_grad = .false.
  real(kind=real32), dimension(:,:), pointer :: out_data
  real(kind=real32), dimension(2,3) :: expected
  logical :: test_pass

  tensor_shape = [2, 3]

  ! Check the tensor pointer is not associated
  @assertFalse(c_associated(tensor%p))

  ! Create a tensor of zeros
  call torch_tensor_zeros(tensor, ndims, tensor_shape, dtype, device_type, &
                          device_index, requires_grad)

  ! Check the tensor pointer is associated
  @assertTrue(c_associated(tensor%p))

  call torch_tensor_to_array(tensor, out_data, shape(expected))

  ! Check that the tensor values are all zero
  expected(:,:) = 0.0
  test_pass = assert_allclose(out_data, expected, test_name="test_torch_tensor_zeros")
  @assertTrue(test_pass)

  ! Cleanup
  nullify(out_data)
  call torch_tensor_delete(tensor)

end subroutine test_torch_tensor_zeros

@test
subroutine test_torch_tensor_ones()
  use pFUnit
  use ftorch, only: torch_kFloat32, torch_kCPU, torch_tensor, torch_tensor_delete, torch_tensor_ones, torch_tensor_to_array
  use ftorch_test_utils, only: assert_allclose
  use, intrinsic :: iso_fortran_env, only: real32
  use iso_c_binding, only: c_associated, c_bool, c_int, c_int64_t, c_null_ptr

  implicit none

  type(torch_tensor) :: tensor
  integer(c_int), parameter :: ndims = 2
  integer(c_int64_t), dimension(2) :: tensor_shape
  integer(c_int), parameter :: dtype = torch_kFloat32
  integer(c_int), parameter :: device_type = torch_kCPU
  integer(c_int), parameter :: device_index = -1
  logical(c_bool), parameter :: requires_grad = .false.
  real(kind=real32), dimension(:,:), pointer :: out_data
  real(kind=real32), dimension(2,3) :: expected
  logical :: test_pass

  tensor_shape = [2, 3]

  ! Check the tensor pointer is not associated
  @assertFalse(c_associated(tensor%p))

  ! Create tensor of ones
  call torch_tensor_ones(tensor, ndims, tensor_shape, dtype, device_type, &
                         device_index, requires_grad)

  ! Check the tensor pointer is associated
  @assertTrue(c_associated(tensor%p))

  call torch_tensor_to_array(tensor, out_data, shape(expected))

  ! Check that the tensor values are all one
  expected(:,:) = 1.0
  test_pass = assert_allclose(out_data, expected, test_name="test_torch_tensor_ones")
  @assertTrue(test_pass)

  ! Cleanup
  nullify(out_data)
  call torch_tensor_delete(tensor)

end subroutine test_torch_tensor_ones

@test
subroutine test_torch_from_blob()
  use pFUnit
  use ftorch
  use, intrinsic :: iso_c_binding, only : c_associated, c_ptr, c_int, c_loc, c_null_ptr
  use, intrinsic :: iso_c_binding, only: c_int, c_int8_t, c_int16_t, c_int32_t, c_int64_t, &
                                        c_float, c_double, c_char

  implicit none

  ! generate test data for torch_tensor_from_blob
  integer(c_int), parameter :: ndims = 2
  integer(c_int64_t), parameter :: tensor_shape(ndims)  = [2,3] ! 2 rows, 3 columns
  integer(kind = 4), target :: data1(2,3)  = reshape([1,2,3,4,5,6], [2,3])  ! 2 rows, 3 columns
  integer(c_int), parameter :: layout(ndims) = [1, 1]
  integer(c_int), parameter :: dtype  = torch_kInt32
  integer(c_int), parameter :: device = torch_kCPU

  type(torch_tensor) :: tensor
  integer(kind = 4) :: data2(3,2) = reshape([1,2,3,4,5,6], [3,2]) ! 3 columns, 2 rows (after reshape)

  ! Check the tensor pointer is not associated
  @assertFalse(c_associated(tensor%p))

  ! Smoke test
  call torch_tensor_from_blob(tensor, c_loc(data1), ndims, tensor_shape, layout, dtype, device)

  ! TODO: would be good to try to compare the data in the tensor to the data in data1

  !@assertEqual(tensor, data2)

  ! Check the tensor pointer is associated
  @assertTrue(c_associated(tensor%p))

  ! Cleanup
  call torch_tensor_delete(tensor)

end subroutine test_torch_from_blob
