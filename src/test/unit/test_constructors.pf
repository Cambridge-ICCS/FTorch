!| Unit tests for FTorch subroutines that construct tensors.
!
!  * License  
!    FTorch is released under an MIT license.
!    See the [LICENSE](https://github.com/Cambridge-ICCS/FTorch/blob/main/LICENSE)
!    file for details.

@test
subroutine test_torch_tensor_empty()
  use pFUnit
  use ftorch, only: torch_kFloat32, torch_kCPU, torch_tensor, torch_tensor_delete, torch_tensor_empty
  use ftorch_test_utils, only: assert_allclose
  use iso_c_binding, only: c_associated, c_bool, c_int, c_int64_t, c_null_ptr

  implicit none

  type(torch_tensor) :: tensor
  integer(c_int), parameter :: ndims = 2
  integer(c_int64_t), dimension(2) :: tensor_shape
  integer(c_int), parameter :: dtype = torch_kFloat32
  integer(c_int), parameter :: device_type = torch_kCPU
  integer(c_int), parameter :: device_index = -1
  logical(c_bool), parameter :: requires_grad = .false.
  logical :: test_pass

  tensor_shape = [2, 3]

  ! Check the tensor pointer is not associated
  @assertFalse(c_associated(tensor%p))

  ! Create a tensor of zeros
  call torch_tensor_empty(tensor, ndims, tensor_shape, dtype, device_type, &
                          device_index, requires_grad)

  ! Check the tensor pointer is associated
  @assertTrue(c_associated(tensor%p))

  ! Cleanup
  call torch_tensor_delete(tensor)

end subroutine test_torch_tensor_empty

@test
subroutine test_torch_tensor_zeros()
  use pFUnit
  use ftorch, only: torch_kFloat32, torch_kCPU, torch_tensor, torch_tensor_delete, torch_tensor_to_array, torch_tensor_zeros
  use ftorch_test_utils, only: assert_allclose
  use, intrinsic :: iso_fortran_env, only: real32
  use iso_c_binding, only: c_associated, c_bool, c_int, c_int64_t, c_null_ptr

  implicit none

  type(torch_tensor) :: tensor
  integer(c_int), parameter :: ndims = 2
  integer(c_int64_t), dimension(2) :: tensor_shape
  integer(c_int), parameter :: dtype = torch_kFloat32
  integer(c_int), parameter :: device_type = torch_kCPU
  integer(c_int), parameter :: device_index = -1
  logical(c_bool), parameter :: requires_grad = .false.
  real(kind=real32), dimension(:,:), pointer :: out_data
  real(kind=real32), dimension(2,3) :: expected
  logical :: test_pass

  tensor_shape = [2, 3]

  ! Check the tensor pointer is not associated
  @assertFalse(c_associated(tensor%p))

  ! Create a tensor of zeros
  call torch_tensor_zeros(tensor, ndims, tensor_shape, dtype, device_type, &
                          device_index, requires_grad)

  ! Check the tensor pointer is associated
  @assertTrue(c_associated(tensor%p))

  ! Extract Fortran array from tensor
  call torch_tensor_to_array(tensor, out_data, shape(expected))

  ! Check that the tensor values are all zero
  expected(:,:) = 0.0
  test_pass = assert_allclose(out_data, expected, test_name="test_torch_tensor_zeros")
  @assertTrue(test_pass)

  ! Cleanup
  nullify(out_data)
  call torch_tensor_delete(tensor)

end subroutine test_torch_tensor_zeros

@test
subroutine test_torch_tensor_ones()
  use pFUnit
  use ftorch, only: torch_kFloat32, torch_kCPU, torch_tensor, torch_tensor_delete, torch_tensor_ones, torch_tensor_to_array
  use ftorch_test_utils, only: assert_allclose
  use, intrinsic :: iso_fortran_env, only: real32
  use iso_c_binding, only: c_associated, c_bool, c_int, c_int64_t, c_null_ptr

  implicit none

  type(torch_tensor) :: tensor
  integer(c_int), parameter :: ndims = 2
  integer(c_int64_t), dimension(2) :: tensor_shape
  integer(c_int), parameter :: dtype = torch_kFloat32
  integer(c_int), parameter :: device_type = torch_kCPU
  integer(c_int), parameter :: device_index = -1
  logical(c_bool), parameter :: requires_grad = .false.
  real(kind=real32), dimension(:,:), pointer :: out_data
  real(kind=real32), dimension(2,3) :: expected
  logical :: test_pass

  tensor_shape = [2, 3]

  ! Check the tensor pointer is not associated
  @assertFalse(c_associated(tensor%p))

  ! Create tensor of ones
  call torch_tensor_ones(tensor, ndims, tensor_shape, dtype, device_type, &
                         device_index, requires_grad)

  ! Check the tensor pointer is associated
  @assertTrue(c_associated(tensor%p))

  ! Extract Fortran array from tensor
  call torch_tensor_to_array(tensor, out_data, shape(expected))

  ! Check that the tensor values are all one
  expected(:,:) = 1.0
  test_pass = assert_allclose(out_data, expected, test_name="test_torch_tensor_ones")
  @assertTrue(test_pass)

  ! Cleanup
  nullify(out_data)
  call torch_tensor_delete(tensor)

end subroutine test_torch_tensor_ones

@test
subroutine test_torch_from_blob()
  use pFUnit
  use ftorch, only: torch_kCPU, torch_kFloat32, torch_tensor, torch_tensor_delete, torch_tensor_from_blob, torch_tensor_to_array
  use ftorch_test_utils, only: assert_allclose
  use, intrinsic :: iso_fortran_env, only: real32
  use, intrinsic :: iso_c_binding, only : c_associated, c_bool, c_int, c_int64_t, c_loc, c_null_ptr, c_ptr

  implicit none

  type(torch_tensor) :: tensor
  integer(kind=c_int), parameter :: ndims = 2
  integer(kind=c_int64_t), parameter :: tensor_layout(ndims) = [2,3]
  integer(kind=c_int), parameter :: layout(ndims) = [1, 1]
  integer(kind=c_int), parameter :: dtype = torch_kFloat32
  integer(kind=c_int), parameter :: device_type = torch_kCPU
  integer(kind=c_int), parameter :: device_index = -1
  logical(kind=c_bool), parameter :: requires_grad = .false.
  real(kind=real32), dimension(2,3), target :: in_data
  real(kind=real32), dimension(:,:), pointer :: out_data
  real(kind=real32), dimension(2,3) :: expected
  logical :: test_pass

  ! Create an arbitrary input array
  in_data = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], [2,3])

  ! Check the tensor pointer is not associated
  @assertFalse(c_associated(tensor%p))

  ! Create a tensor based off an input array
  call torch_tensor_from_blob(tensor, c_loc(in_data), ndims, tensor_layout, layout, dtype, device_type, device_index, requires_grad)

  ! Check the tensor pointer is associated
  @assertTrue(c_associated(tensor%p))

  ! Extract Fortran array from tensor
  call torch_tensor_to_array(tensor, out_data, shape(in_data))

  ! Compare the data in the tensor to the input data 
  expected(:,:) = in_data
  print *, expected
  print *, out_data
  test_pass = assert_allclose(out_data, expected, test_name="test_torch_tensor_from_blob")
  @assertTrue(test_pass)

  ! Cleanup
  nullify(out_data)
  call torch_tensor_delete(tensor)

end subroutine test_torch_from_blob
