var tipuesearch = {"pages":[{"title":" FTorch ","text":"FTorch Description It is desirable to run machine learning (ML) models directly in Fortran.\nHowever, ML models are often trained in some other language using popular frameworks (say, Python and PyTorch). FTorch is a library enabling users to directly couple their PyTorch models to Fortran code enabling the development of hybrid models that combine high-performance scientific computing with modern ML techniques.\nIt supports running on both CPU and GPU, and is tested on UNIX and Windows operating systems This site contains user and API documentation for FTorch as well as community information.\nThere are also installation instructions for the library and numerous examples of\nperforming coupling. Using and Citing FTorch FTorch is published in JOSS. To cite it in your work please refer to: Atkinson et al., (2025). FTorch: a library for coupling PyTorch models to Fortran. Journal of Open Source Software , 10(107), 7602, https://doi.org/10.21105/joss.07602 For examples of the many projects and publications that rely on FTorch please see our user case studies page .\nIf you use FTorch and want to be included please get in touch. The presentations page has a full list of recent talks about FTorch with links to slides and recordings. News For the latest updates and developments please see the news page and join our user mailing list . Training We offer training on FTorch in the form of tutorials and workshops. The\ncompanion repository https://github.com/Cambridge-ICCS/FTorch-workshop provides a set of exercises and solutions to help users get started with FTorch.\nUpcoming in-person sessions will be listed on the news page . Contact For feature requests, bug reports, or assistance in using FTorch please get in touch via\nGitHub by either raising an issue or opening an discussion . For general enquiries please contact ICCS via iccs@maths.cam.ac.uk . License The FTorch source code, related files and documentation are\ndistributed under an MIT License which can be viewed here . Developer Info ICCS Cambridge Research Software Engineering team supporting software development and standards across the climate sciences domain.","tags":"home","url":"index.html"},{"title":"torch_model – FTorch ","text":"type, public :: torch_model Type for holding a torch neural net (nn.Module). Inherits type~~torch_model~~InheritsGraph type~torch_model torch_model c_ptr c_ptr type~torch_model->c_ptr p Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type(c_ptr), public :: p = c_null_ptr pointer to the neural net in memory Source Code type torch_model type ( c_ptr ) :: p = c_null_ptr !! pointer to the neural net in memory end type torch_model","tags":"","url":"type/torch_model.html"},{"title":"torch_tensor – FTorch ","text":"type, public :: torch_tensor Type for holding a Torch tensor. Inherits type~~torch_tensor~~InheritsGraph type~torch_tensor torch_tensor c_ptr c_ptr type~torch_tensor->c_ptr p Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type(c_ptr), public :: p = c_null_ptr pointer to the tensor in memory Finalization Procedures final :: torch_tensor_delete public  subroutine torch_tensor_delete (tensor) Deallocates a tensor. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(inout) :: tensor Tensor to deallocate Type-Bound Procedures procedure, public :: get_device_index => torch_tensor_get_device_index public  function torch_tensor_get_device_index (self) result(device_index) Determines the device index of a tensor. Arguments Type Intent Optional Attributes Name class( torch_tensor ), intent(in) :: self Tensor to get the device index of Return Value integer(kind=c_int) Device index of tensor procedure, public :: get_device_type => torch_tensor_get_device_type public  function torch_tensor_get_device_type (self) result(device_type) Returns the device type of a tensor. Arguments Type Intent Optional Attributes Name class( torch_tensor ), intent(in) :: self Tensor to get the device type of Return Value integer(kind=c_int) Device type of tensor procedure, public :: get_dtype => torch_tensor_get_dtype public  function torch_tensor_get_dtype (self) result(dtype) Returns the data type of a tensor. Arguments Type Intent Optional Attributes Name class( torch_tensor ), intent(in) :: self Tensor to get the data type of Return Value integer(kind=c_int) Data type of tensor procedure, public :: get_rank => torch_tensor_get_rank public  function torch_tensor_get_rank (self) result(rank) Determines the rank of a tensor. Arguments Type Intent Optional Attributes Name class( torch_tensor ), intent(in) :: self Tensor to get the rank of Return Value integer(kind=int32) Rank of tensor procedure, public :: get_shape => torch_tensor_get_shape public  function torch_tensor_get_shape (self) result(sizes) Determines the shape of a tensor. Arguments Type Intent Optional Attributes Name class( torch_tensor ), intent(in) :: self Tensor to get the shape of Return Value integer(kind=c_int64_t), pointer, (:) Pointer to tensor data procedure, public :: get_stride => torch_tensor_get_stride public  function torch_tensor_get_stride (self) result(strides) Return the strides of the tensor Arguments Type Intent Optional Attributes Name class( torch_tensor ), intent(in) :: self Tensor to get the strides of Return Value integer(kind=c_int64_t), pointer, (:) Pointer to tensor data procedure, public :: requires_grad => torch_tensor_requires_grad public  function torch_tensor_requires_grad (self) result(requires_grad) Determines whether a tensor requires the autograd module. Arguments Type Intent Optional Attributes Name class( torch_tensor ), intent(in) :: self Tensor to query Return Value logical Whether the tensor requires autograd procedure, public :: zero => torch_tensor_zero public  subroutine torch_tensor_zero (tensor) Fills a tensor with the scalar value 0. Arguments Type Intent Optional Attributes Name class( torch_tensor ), intent(inout) :: tensor Tensor whose values are to be zeroed procedure, public :: zero_grad => torch_tensor_zero_grad public  subroutine torch_tensor_zero_grad (tensor) Resets a tensor's gradient to zero. Arguments Type Intent Optional Attributes Name class( torch_tensor ), intent(inout) :: tensor Tensor to zero the gradient of Source Code type torch_tensor type ( c_ptr ) :: p = c_null_ptr !! pointer to the tensor in memory contains procedure :: get_rank => torch_tensor_get_rank procedure :: get_shape => torch_tensor_get_shape procedure :: get_stride => torch_tensor_get_stride procedure :: get_dtype => torch_tensor_get_dtype procedure :: get_device_type => torch_tensor_get_device_type procedure :: get_device_index => torch_tensor_get_device_index procedure :: requires_grad => torch_tensor_requires_grad procedure :: zero => torch_tensor_zero procedure :: zero_grad => torch_tensor_zero_grad final :: torch_tensor_delete end type torch_tensor","tags":"","url":"type/torch_tensor.html"},{"title":"torch_tensor_add – FTorch","text":"public  function torch_tensor_add(tensor1, tensor2) result(output) Uses iso_c_binding proc~~torch_tensor_add~~UsesGraph proc~torch_tensor_add torch_tensor_add iso_c_binding iso_c_binding proc~torch_tensor_add->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Overloads addition operator for two tensors. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor1 First tensor to be added type( torch_tensor ), intent(in) :: tensor2 Second tensor to be added Return Value type( torch_tensor ) Tensor to hold the sum Calls proc~~torch_tensor_add~~CallsGraph proc~torch_tensor_add torch_tensor_add proc~torch_tensor_empty torch_tensor_empty proc~torch_tensor_add->proc~torch_tensor_empty proc~torch_tensor_get_device_index torch_tensor%torch_tensor_get_device_index proc~torch_tensor_add->proc~torch_tensor_get_device_index proc~torch_tensor_get_device_type torch_tensor%torch_tensor_get_device_type proc~torch_tensor_add->proc~torch_tensor_get_device_type proc~torch_tensor_get_dtype torch_tensor%torch_tensor_get_dtype proc~torch_tensor_add->proc~torch_tensor_get_dtype proc~torch_tensor_get_rank torch_tensor%torch_tensor_get_rank proc~torch_tensor_add->proc~torch_tensor_get_rank proc~torch_tensor_get_shape torch_tensor%torch_tensor_get_shape proc~torch_tensor_add->proc~torch_tensor_get_shape proc~torch_tensor_requires_grad torch_tensor%torch_tensor_requires_grad proc~torch_tensor_add->proc~torch_tensor_requires_grad proc~torch_tensor_get_shape->proc~torch_tensor_get_rank Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_add~~CalledByGraph proc~torch_tensor_add torch_tensor_add interface~operator (+) operator (+) interface~operator (+)->proc~torch_tensor_add Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function torch_tensor_add ( tensor1 , tensor2 ) result ( output ) use , intrinsic :: iso_c_binding , only : c_associated type ( torch_tensor ), intent ( in ) :: tensor1 !! First tensor to be added type ( torch_tensor ), intent ( in ) :: tensor2 !! Second tensor to be added type ( torch_tensor ) :: output !! Tensor to hold the sum interface subroutine torch_tensor_add_c ( output_c , tensor1_c , tensor2_c ) & bind ( c , name = 'torch_tensor_add' ) use , intrinsic :: iso_c_binding , only : c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: tensor1_c type ( c_ptr ), value , intent ( in ) :: tensor2_c type ( c_ptr ), value , intent ( in ) :: output_c end subroutine torch_tensor_add_c end interface if ( tensor1 % get_device_type () /= tensor2 % get_device_type ()) then write ( * , * ) \"Error :: cannot add tensors with different device types\" stop 1 end if if (. not . c_associated ( output % p )) then call torch_tensor_empty ( output , tensor1 % get_rank (), tensor1 % get_shape (), & tensor1 % get_dtype (), tensor1 % get_device_type (), & device_index = tensor1 % get_device_index (), & requires_grad = tensor1 % requires_grad ()) end if call torch_tensor_add_c ( output % p , tensor1 % p , tensor2 % p ) end function torch_tensor_add","tags":"","url":"proc/torch_tensor_add.html"},{"title":"torch_tensor_divide – FTorch","text":"public  function torch_tensor_divide(tensor1, tensor2) result(output) Uses iso_c_binding proc~~torch_tensor_divide~~UsesGraph proc~torch_tensor_divide torch_tensor_divide iso_c_binding iso_c_binding proc~torch_tensor_divide->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Overloads division operator for two tensors. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor1 First tensor for the division type( torch_tensor ), intent(in) :: tensor2 Second tensor for the division Return Value type( torch_tensor ) Tensor to hold the quotient Calls proc~~torch_tensor_divide~~CallsGraph proc~torch_tensor_divide torch_tensor_divide interface~torch_tensor_divide_c torch_tensor_divide_c proc~torch_tensor_divide->interface~torch_tensor_divide_c proc~torch_tensor_empty torch_tensor_empty proc~torch_tensor_divide->proc~torch_tensor_empty proc~torch_tensor_get_device_index torch_tensor%torch_tensor_get_device_index proc~torch_tensor_divide->proc~torch_tensor_get_device_index proc~torch_tensor_get_device_type torch_tensor%torch_tensor_get_device_type proc~torch_tensor_divide->proc~torch_tensor_get_device_type proc~torch_tensor_get_dtype torch_tensor%torch_tensor_get_dtype proc~torch_tensor_divide->proc~torch_tensor_get_dtype proc~torch_tensor_get_rank torch_tensor%torch_tensor_get_rank proc~torch_tensor_divide->proc~torch_tensor_get_rank proc~torch_tensor_get_shape torch_tensor%torch_tensor_get_shape proc~torch_tensor_divide->proc~torch_tensor_get_shape proc~torch_tensor_requires_grad torch_tensor%torch_tensor_requires_grad proc~torch_tensor_divide->proc~torch_tensor_requires_grad proc~torch_tensor_get_shape->proc~torch_tensor_get_rank Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_divide~~CalledByGraph proc~torch_tensor_divide torch_tensor_divide interface~operator (SLASH) operator (/) interface~operator (SLASH)->proc~torch_tensor_divide Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function torch_tensor_divide ( tensor1 , tensor2 ) result ( output ) use , intrinsic :: iso_c_binding , only : c_associated type ( torch_tensor ), intent ( in ) :: tensor1 !! First tensor for the division type ( torch_tensor ), intent ( in ) :: tensor2 !! Second tensor for the division type ( torch_tensor ) :: output !! Tensor to hold the quotient if ( tensor1 % get_device_type () /= tensor2 % get_device_type ()) then write ( * , * ) \"Error :: cannot divide tensors with different device types\" stop 1 end if if (. not . c_associated ( output % p )) then call torch_tensor_empty ( output , tensor1 % get_rank (), tensor1 % get_shape (), & tensor1 % get_dtype (), tensor1 % get_device_type (), & device_index = tensor1 % get_device_index (), & requires_grad = tensor1 % requires_grad ()) end if call torch_tensor_divide_c ( output % p , tensor1 % p , tensor2 % p ) end function torch_tensor_divide","tags":"","url":"proc/torch_tensor_divide.html"},{"title":"torch_tensor_get_device_index – FTorch","text":"public  function torch_tensor_get_device_index(self) result(device_index) Uses iso_c_binding proc~~torch_tensor_get_device_index~~UsesGraph proc~torch_tensor_get_device_index torch_tensor%torch_tensor_get_device_index iso_c_binding iso_c_binding proc~torch_tensor_get_device_index->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Determines the device index of a tensor. Type Bound torch_tensor Arguments Type Intent Optional Attributes Name class( torch_tensor ), intent(in) :: self Tensor to get the device index of Return Value integer(kind=c_int) Device index of tensor Called by proc~~torch_tensor_get_device_index~~CalledByGraph proc~torch_tensor_get_device_index torch_tensor%torch_tensor_get_device_index proc~torch_tensor_add torch_tensor_add proc~torch_tensor_add->proc~torch_tensor_get_device_index proc~torch_tensor_assign torch_tensor_assign proc~torch_tensor_assign->proc~torch_tensor_get_device_index proc~torch_tensor_backward torch_tensor_backward proc~torch_tensor_backward->proc~torch_tensor_get_device_index proc~torch_tensor_divide torch_tensor_divide proc~torch_tensor_divide->proc~torch_tensor_get_device_index proc~torch_tensor_multiply torch_tensor_multiply proc~torch_tensor_multiply->proc~torch_tensor_get_device_index proc~torch_tensor_negative torch_tensor_negative proc~torch_tensor_negative->proc~torch_tensor_get_device_index proc~torch_tensor_power_int16 torch_tensor_power_int16 proc~torch_tensor_power_int16->proc~torch_tensor_get_device_index proc~torch_tensor_power_int32 torch_tensor_power_int32 proc~torch_tensor_power_int32->proc~torch_tensor_get_device_index proc~torch_tensor_power_int64 torch_tensor_power_int64 proc~torch_tensor_power_int64->proc~torch_tensor_get_device_index proc~torch_tensor_power_int8 torch_tensor_power_int8 proc~torch_tensor_power_int8->proc~torch_tensor_get_device_index proc~torch_tensor_power_real32 torch_tensor_power_real32 proc~torch_tensor_power_real32->proc~torch_tensor_get_device_index proc~torch_tensor_power_real64 torch_tensor_power_real64 proc~torch_tensor_power_real64->proc~torch_tensor_get_device_index proc~torch_tensor_subtract torch_tensor_subtract proc~torch_tensor_subtract->proc~torch_tensor_get_device_index interface~assignment (=) assignment (=) interface~assignment (=)->proc~torch_tensor_assign interface~operator (+) operator (+) interface~operator (+)->proc~torch_tensor_add interface~operator (-) operator (-) interface~operator (-)->proc~torch_tensor_negative interface~operator (-)->proc~torch_tensor_subtract interface~operator (ASTERISK) operator (*) interface~operator (ASTERISK)->proc~torch_tensor_multiply interface~operator (ASTERISKASTERISK) operator (**) interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_int16 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_int32 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_int64 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_int8 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_real32 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_real64 interface~operator (SLASH) operator (/) interface~operator (SLASH)->proc~torch_tensor_divide Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function torch_tensor_get_device_index ( self ) result ( device_index ) use , intrinsic :: iso_c_binding , only : c_int class ( torch_tensor ), intent ( in ) :: self !! Tensor to get the device index of integer ( c_int ) :: device_index !! Device index of tensor interface function torch_tensor_get_device_index_c ( tensor_c ) result ( device_index_c ) & bind ( c , name = 'torch_tensor_get_device_index' ) use , intrinsic :: iso_c_binding , only : c_int , c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: tensor_c integer ( c_int ) :: device_index_c end function torch_tensor_get_device_index_c end interface if (. not . c_associated ( self % p )) then write ( * , * ) \"Error :: tensor has not been constructed so its device index is unset\" stop 1 end if device_index = torch_tensor_get_device_index_c ( self % p ) end function torch_tensor_get_device_index","tags":"","url":"proc/torch_tensor_get_device_index.html"},{"title":"torch_tensor_get_device_type – FTorch","text":"public  function torch_tensor_get_device_type(self) result(device_type) Uses iso_c_binding proc~~torch_tensor_get_device_type~~UsesGraph proc~torch_tensor_get_device_type torch_tensor%torch_tensor_get_device_type iso_c_binding iso_c_binding proc~torch_tensor_get_device_type->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Returns the device type of a tensor. Type Bound torch_tensor Arguments Type Intent Optional Attributes Name class( torch_tensor ), intent(in) :: self Tensor to get the device type of Return Value integer(kind=c_int) Device type of tensor Called by proc~~torch_tensor_get_device_type~~CalledByGraph proc~torch_tensor_get_device_type torch_tensor%torch_tensor_get_device_type proc~torch_tensor_add torch_tensor_add proc~torch_tensor_add->proc~torch_tensor_get_device_type proc~torch_tensor_assign torch_tensor_assign proc~torch_tensor_assign->proc~torch_tensor_get_device_type proc~torch_tensor_backward torch_tensor_backward proc~torch_tensor_backward->proc~torch_tensor_get_device_type proc~torch_tensor_divide torch_tensor_divide proc~torch_tensor_divide->proc~torch_tensor_get_device_type proc~torch_tensor_multiply torch_tensor_multiply proc~torch_tensor_multiply->proc~torch_tensor_get_device_type proc~torch_tensor_negative torch_tensor_negative proc~torch_tensor_negative->proc~torch_tensor_get_device_type proc~torch_tensor_power_int16 torch_tensor_power_int16 proc~torch_tensor_power_int16->proc~torch_tensor_get_device_type proc~torch_tensor_power_int32 torch_tensor_power_int32 proc~torch_tensor_power_int32->proc~torch_tensor_get_device_type proc~torch_tensor_power_int64 torch_tensor_power_int64 proc~torch_tensor_power_int64->proc~torch_tensor_get_device_type proc~torch_tensor_power_int8 torch_tensor_power_int8 proc~torch_tensor_power_int8->proc~torch_tensor_get_device_type proc~torch_tensor_power_real32 torch_tensor_power_real32 proc~torch_tensor_power_real32->proc~torch_tensor_get_device_type proc~torch_tensor_power_real64 torch_tensor_power_real64 proc~torch_tensor_power_real64->proc~torch_tensor_get_device_type proc~torch_tensor_subtract torch_tensor_subtract proc~torch_tensor_subtract->proc~torch_tensor_get_device_type interface~assignment (=) assignment (=) interface~assignment (=)->proc~torch_tensor_assign interface~operator (+) operator (+) interface~operator (+)->proc~torch_tensor_add interface~operator (-) operator (-) interface~operator (-)->proc~torch_tensor_negative interface~operator (-)->proc~torch_tensor_subtract interface~operator (ASTERISK) operator (*) interface~operator (ASTERISK)->proc~torch_tensor_multiply interface~operator (ASTERISKASTERISK) operator (**) interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_int16 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_int32 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_int64 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_int8 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_real32 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_real64 interface~operator (SLASH) operator (/) interface~operator (SLASH)->proc~torch_tensor_divide Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function torch_tensor_get_device_type ( self ) result ( device_type ) use , intrinsic :: iso_c_binding , only : c_int class ( torch_tensor ), intent ( in ) :: self !! Tensor to get the device type of integer ( c_int ) :: device_type !! Device type of tensor interface function torch_tensor_get_device_type_c ( tensor_c ) result ( device_type_c ) & bind ( c , name = 'torch_tensor_get_device_type' ) use , intrinsic :: iso_c_binding , only : c_int , c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: tensor_c integer ( c_int ) :: device_type_c end function torch_tensor_get_device_type_c end interface if (. not . c_associated ( self % p )) then write ( * , * ) \"Error :: tensor has not been constructed so its device type is unset\" stop 1 end if device_type = torch_tensor_get_device_type_c ( self % p ) end function torch_tensor_get_device_type","tags":"","url":"proc/torch_tensor_get_device_type.html"},{"title":"torch_tensor_get_dtype – FTorch","text":"public  function torch_tensor_get_dtype(self) result(dtype) Uses iso_c_binding proc~~torch_tensor_get_dtype~~UsesGraph proc~torch_tensor_get_dtype torch_tensor%torch_tensor_get_dtype iso_c_binding iso_c_binding proc~torch_tensor_get_dtype->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Returns the data type of a tensor. Type Bound torch_tensor Arguments Type Intent Optional Attributes Name class( torch_tensor ), intent(in) :: self Tensor to get the data type of Return Value integer(kind=c_int) Data type of tensor Called by proc~~torch_tensor_get_dtype~~CalledByGraph proc~torch_tensor_get_dtype torch_tensor%torch_tensor_get_dtype proc~torch_tensor_add torch_tensor_add proc~torch_tensor_add->proc~torch_tensor_get_dtype proc~torch_tensor_assign torch_tensor_assign proc~torch_tensor_assign->proc~torch_tensor_get_dtype proc~torch_tensor_backward torch_tensor_backward proc~torch_tensor_backward->proc~torch_tensor_get_dtype proc~torch_tensor_divide torch_tensor_divide proc~torch_tensor_divide->proc~torch_tensor_get_dtype proc~torch_tensor_multiply torch_tensor_multiply proc~torch_tensor_multiply->proc~torch_tensor_get_dtype proc~torch_tensor_negative torch_tensor_negative proc~torch_tensor_negative->proc~torch_tensor_get_dtype proc~torch_tensor_power_int16 torch_tensor_power_int16 proc~torch_tensor_power_int16->proc~torch_tensor_get_dtype proc~torch_tensor_power_int32 torch_tensor_power_int32 proc~torch_tensor_power_int32->proc~torch_tensor_get_dtype proc~torch_tensor_power_int64 torch_tensor_power_int64 proc~torch_tensor_power_int64->proc~torch_tensor_get_dtype proc~torch_tensor_power_int8 torch_tensor_power_int8 proc~torch_tensor_power_int8->proc~torch_tensor_get_dtype proc~torch_tensor_power_real32 torch_tensor_power_real32 proc~torch_tensor_power_real32->proc~torch_tensor_get_dtype proc~torch_tensor_power_real64 torch_tensor_power_real64 proc~torch_tensor_power_real64->proc~torch_tensor_get_dtype proc~torch_tensor_subtract torch_tensor_subtract proc~torch_tensor_subtract->proc~torch_tensor_get_dtype interface~assignment (=) assignment (=) interface~assignment (=)->proc~torch_tensor_assign interface~operator (+) operator (+) interface~operator (+)->proc~torch_tensor_add interface~operator (-) operator (-) interface~operator (-)->proc~torch_tensor_negative interface~operator (-)->proc~torch_tensor_subtract interface~operator (ASTERISK) operator (*) interface~operator (ASTERISK)->proc~torch_tensor_multiply interface~operator (ASTERISKASTERISK) operator (**) interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_int16 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_int32 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_int64 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_int8 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_real32 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_real64 interface~operator (SLASH) operator (/) interface~operator (SLASH)->proc~torch_tensor_divide Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function torch_tensor_get_dtype ( self ) result ( dtype ) use , intrinsic :: iso_c_binding , only : c_int class ( torch_tensor ), intent ( in ) :: self !! Tensor to get the data type of integer ( c_int ) :: dtype !! Data type of tensor interface function torch_tensor_get_dtype_c ( tensor_c ) result ( dtype_c ) & bind ( c , name = 'torch_tensor_get_dtype' ) use , intrinsic :: iso_c_binding , only : c_int , c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: tensor_c integer ( c_int ) :: dtype_c end function torch_tensor_get_dtype_c end interface if (. not . c_associated ( self % p )) then write ( * , * ) \"Error :: tensor has not been constructed so its data type is unset\" stop 1 end if dtype = torch_tensor_get_dtype_c ( self % p ) end function torch_tensor_get_dtype","tags":"","url":"proc/torch_tensor_get_dtype.html"},{"title":"torch_tensor_get_rank – FTorch","text":"public  function torch_tensor_get_rank(self) result(rank) Determines the rank of a tensor. Type Bound torch_tensor Arguments Type Intent Optional Attributes Name class( torch_tensor ), intent(in) :: self Tensor to get the rank of Return Value integer(kind=int32) Rank of tensor Called by proc~~torch_tensor_get_rank~~CalledByGraph proc~torch_tensor_get_rank torch_tensor%torch_tensor_get_rank proc~torch_tensor_add torch_tensor_add proc~torch_tensor_add->proc~torch_tensor_get_rank proc~torch_tensor_get_shape torch_tensor%torch_tensor_get_shape proc~torch_tensor_add->proc~torch_tensor_get_shape proc~torch_tensor_assign torch_tensor_assign proc~torch_tensor_assign->proc~torch_tensor_get_rank proc~torch_tensor_assign->proc~torch_tensor_get_shape proc~torch_tensor_backward torch_tensor_backward proc~torch_tensor_backward->proc~torch_tensor_get_rank proc~torch_tensor_backward->proc~torch_tensor_get_shape proc~torch_tensor_divide torch_tensor_divide proc~torch_tensor_divide->proc~torch_tensor_get_rank proc~torch_tensor_divide->proc~torch_tensor_get_shape proc~torch_tensor_get_shape->proc~torch_tensor_get_rank proc~torch_tensor_get_stride torch_tensor%torch_tensor_get_stride proc~torch_tensor_get_stride->proc~torch_tensor_get_rank proc~torch_tensor_multiply torch_tensor_multiply proc~torch_tensor_multiply->proc~torch_tensor_get_rank proc~torch_tensor_multiply->proc~torch_tensor_get_shape proc~torch_tensor_negative torch_tensor_negative proc~torch_tensor_negative->proc~torch_tensor_get_rank proc~torch_tensor_negative->proc~torch_tensor_get_shape proc~torch_tensor_power_int16 torch_tensor_power_int16 proc~torch_tensor_power_int16->proc~torch_tensor_get_rank proc~torch_tensor_power_int16->proc~torch_tensor_get_shape proc~torch_tensor_power_int32 torch_tensor_power_int32 proc~torch_tensor_power_int32->proc~torch_tensor_get_rank proc~torch_tensor_power_int32->proc~torch_tensor_get_shape proc~torch_tensor_power_int64 torch_tensor_power_int64 proc~torch_tensor_power_int64->proc~torch_tensor_get_rank proc~torch_tensor_power_int64->proc~torch_tensor_get_shape proc~torch_tensor_power_int8 torch_tensor_power_int8 proc~torch_tensor_power_int8->proc~torch_tensor_get_rank proc~torch_tensor_power_int8->proc~torch_tensor_get_shape proc~torch_tensor_power_real32 torch_tensor_power_real32 proc~torch_tensor_power_real32->proc~torch_tensor_get_rank proc~torch_tensor_power_real32->proc~torch_tensor_get_shape proc~torch_tensor_power_real64 torch_tensor_power_real64 proc~torch_tensor_power_real64->proc~torch_tensor_get_rank proc~torch_tensor_power_real64->proc~torch_tensor_get_shape proc~torch_tensor_subtract torch_tensor_subtract proc~torch_tensor_subtract->proc~torch_tensor_get_rank proc~torch_tensor_subtract->proc~torch_tensor_get_shape proc~torch_tensor_to torch_tensor_to proc~torch_tensor_to->proc~torch_tensor_get_rank proc~torch_tensor_to->proc~torch_tensor_get_shape interface~assignment (=) assignment (=) interface~assignment (=)->proc~torch_tensor_assign interface~operator (+) operator (+) interface~operator (+)->proc~torch_tensor_add interface~operator (-) operator (-) interface~operator (-)->proc~torch_tensor_negative interface~operator (-)->proc~torch_tensor_subtract interface~operator (ASTERISK) operator (*) interface~operator (ASTERISK)->proc~torch_tensor_multiply interface~operator (ASTERISKASTERISK) operator (**) interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_int16 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_int32 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_int64 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_int8 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_real32 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_real64 interface~operator (SLASH) operator (/) interface~operator (SLASH)->proc~torch_tensor_divide Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function torch_tensor_get_rank ( self ) result ( rank ) class ( torch_tensor ), intent ( in ) :: self !! Tensor to get the rank of integer ( kind = int32 ) :: rank !! Rank of tensor interface function torch_tensor_get_rank_c ( tensor_c ) result ( rank_c ) & bind ( c , name = 'torch_tensor_get_rank' ) use , intrinsic :: iso_c_binding , only : c_int , c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: tensor_c integer ( c_int ) :: rank_c end function torch_tensor_get_rank_c end interface if (. not . c_associated ( self % p )) then write ( * , * ) \"Error :: tensor has not been constructed so its rank is unset\" stop 1 end if rank = torch_tensor_get_rank_c ( self % p ) end function torch_tensor_get_rank","tags":"","url":"proc/torch_tensor_get_rank.html"},{"title":"torch_tensor_get_shape – FTorch","text":"public  function torch_tensor_get_shape(self) result(sizes) Uses iso_c_binding proc~~torch_tensor_get_shape~~UsesGraph proc~torch_tensor_get_shape torch_tensor%torch_tensor_get_shape iso_c_binding iso_c_binding proc~torch_tensor_get_shape->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Determines the shape of a tensor. Type Bound torch_tensor Arguments Type Intent Optional Attributes Name class( torch_tensor ), intent(in) :: self Tensor to get the shape of Return Value integer(kind=c_int64_t), pointer, (:) Pointer to tensor data Calls proc~~torch_tensor_get_shape~~CallsGraph proc~torch_tensor_get_shape torch_tensor%torch_tensor_get_shape proc~torch_tensor_get_rank torch_tensor%torch_tensor_get_rank proc~torch_tensor_get_shape->proc~torch_tensor_get_rank Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_get_shape~~CalledByGraph proc~torch_tensor_get_shape torch_tensor%torch_tensor_get_shape proc~torch_tensor_add torch_tensor_add proc~torch_tensor_add->proc~torch_tensor_get_shape proc~torch_tensor_assign torch_tensor_assign proc~torch_tensor_assign->proc~torch_tensor_get_shape proc~torch_tensor_backward torch_tensor_backward proc~torch_tensor_backward->proc~torch_tensor_get_shape proc~torch_tensor_divide torch_tensor_divide proc~torch_tensor_divide->proc~torch_tensor_get_shape proc~torch_tensor_multiply torch_tensor_multiply proc~torch_tensor_multiply->proc~torch_tensor_get_shape proc~torch_tensor_negative torch_tensor_negative proc~torch_tensor_negative->proc~torch_tensor_get_shape proc~torch_tensor_power_int16 torch_tensor_power_int16 proc~torch_tensor_power_int16->proc~torch_tensor_get_shape proc~torch_tensor_power_int32 torch_tensor_power_int32 proc~torch_tensor_power_int32->proc~torch_tensor_get_shape proc~torch_tensor_power_int64 torch_tensor_power_int64 proc~torch_tensor_power_int64->proc~torch_tensor_get_shape proc~torch_tensor_power_int8 torch_tensor_power_int8 proc~torch_tensor_power_int8->proc~torch_tensor_get_shape proc~torch_tensor_power_real32 torch_tensor_power_real32 proc~torch_tensor_power_real32->proc~torch_tensor_get_shape proc~torch_tensor_power_real64 torch_tensor_power_real64 proc~torch_tensor_power_real64->proc~torch_tensor_get_shape proc~torch_tensor_subtract torch_tensor_subtract proc~torch_tensor_subtract->proc~torch_tensor_get_shape proc~torch_tensor_to torch_tensor_to proc~torch_tensor_to->proc~torch_tensor_get_shape interface~assignment (=) assignment (=) interface~assignment (=)->proc~torch_tensor_assign interface~operator (+) operator (+) interface~operator (+)->proc~torch_tensor_add interface~operator (-) operator (-) interface~operator (-)->proc~torch_tensor_negative interface~operator (-)->proc~torch_tensor_subtract interface~operator (ASTERISK) operator (*) interface~operator (ASTERISK)->proc~torch_tensor_multiply interface~operator (ASTERISKASTERISK) operator (**) interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_int16 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_int32 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_int64 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_int8 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_real32 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_real64 interface~operator (SLASH) operator (/) interface~operator (SLASH)->proc~torch_tensor_divide Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function torch_tensor_get_shape ( self ) result ( sizes ) use , intrinsic :: iso_c_binding , only : c_f_pointer , c_int , c_int64_t , c_ptr class ( torch_tensor ), intent ( in ) :: self !! Tensor to get the shape of integer ( kind = c_int64_t ), pointer :: sizes (:) !! Pointer to tensor data ! Local data integer ( kind = int32 ) :: ndims ( 1 ) type ( c_ptr ) :: cptr interface function torch_tensor_get_sizes_c ( tensor_c ) result ( sizes_c ) & bind ( c , name = 'torch_tensor_get_sizes' ) use , intrinsic :: iso_c_binding , only : c_int , c_long , c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: tensor_c type ( c_ptr ) :: sizes_c end function torch_tensor_get_sizes_c end interface if (. not . c_associated ( self % p )) then write ( * , * ) \"Error :: tensor has not been constructed so its shape is unset\" stop 1 end if ndims ( 1 ) = self % get_rank () cptr = torch_tensor_get_sizes_c ( self % p ) call c_f_pointer ( cptr , sizes , ndims ) end function torch_tensor_get_shape","tags":"","url":"proc/torch_tensor_get_shape.html"},{"title":"torch_tensor_get_stride – FTorch","text":"public  function torch_tensor_get_stride(self) result(strides) Uses iso_c_binding proc~~torch_tensor_get_stride~~UsesGraph proc~torch_tensor_get_stride torch_tensor%torch_tensor_get_stride iso_c_binding iso_c_binding proc~torch_tensor_get_stride->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return the strides of the tensor Type Bound torch_tensor Arguments Type Intent Optional Attributes Name class( torch_tensor ), intent(in) :: self Tensor to get the strides of Return Value integer(kind=c_int64_t), pointer, (:) Pointer to tensor data Calls proc~~torch_tensor_get_stride~~CallsGraph proc~torch_tensor_get_stride torch_tensor%torch_tensor_get_stride proc~torch_tensor_get_rank torch_tensor%torch_tensor_get_rank proc~torch_tensor_get_stride->proc~torch_tensor_get_rank Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function torch_tensor_get_stride ( self ) result ( strides ) use , intrinsic :: iso_c_binding , only : c_f_pointer , c_int , c_int64_t , c_ptr class ( torch_tensor ), intent ( in ) :: self !! Tensor to get the strides of integer ( kind = c_int64_t ), pointer :: strides (:) !! Pointer to tensor data ! Local data integer ( kind = int32 ) :: ndims ( 1 ) type ( c_ptr ) :: cptr interface function torch_tensor_get_stride_c ( tensor_c ) result ( strides_c ) & bind ( c , name = 'torch_tensor_get_stride' ) use , intrinsic :: iso_c_binding , only : c_int , c_long , c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: tensor_c type ( c_ptr ) :: strides_c end function torch_tensor_get_stride_c end interface if (. not . c_associated ( self % p )) then write ( * , * ) \"Error :: tensor has not been constructed so its strides are unset\" stop 1 end if ndims ( 1 ) = self % get_rank () cptr = torch_tensor_get_stride_c ( self % p ) call c_f_pointer ( cptr , strides , ndims ) end function torch_tensor_get_stride","tags":"","url":"proc/torch_tensor_get_stride.html"},{"title":"torch_tensor_multiply – FTorch","text":"public  function torch_tensor_multiply(tensor1, tensor2) result(output) Uses iso_c_binding proc~~torch_tensor_multiply~~UsesGraph proc~torch_tensor_multiply torch_tensor_multiply iso_c_binding iso_c_binding proc~torch_tensor_multiply->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Overloads multiplication operator for two tensors. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor1 First tensor to be multiplied type( torch_tensor ), intent(in) :: tensor2 Second tensor to be multiplied Return Value type( torch_tensor ) Tensor to hold the product Calls proc~~torch_tensor_multiply~~CallsGraph proc~torch_tensor_multiply torch_tensor_multiply interface~torch_tensor_multiply_c torch_tensor_multiply_c proc~torch_tensor_multiply->interface~torch_tensor_multiply_c proc~torch_tensor_empty torch_tensor_empty proc~torch_tensor_multiply->proc~torch_tensor_empty proc~torch_tensor_get_device_index torch_tensor%torch_tensor_get_device_index proc~torch_tensor_multiply->proc~torch_tensor_get_device_index proc~torch_tensor_get_device_type torch_tensor%torch_tensor_get_device_type proc~torch_tensor_multiply->proc~torch_tensor_get_device_type proc~torch_tensor_get_dtype torch_tensor%torch_tensor_get_dtype proc~torch_tensor_multiply->proc~torch_tensor_get_dtype proc~torch_tensor_get_rank torch_tensor%torch_tensor_get_rank proc~torch_tensor_multiply->proc~torch_tensor_get_rank proc~torch_tensor_get_shape torch_tensor%torch_tensor_get_shape proc~torch_tensor_multiply->proc~torch_tensor_get_shape proc~torch_tensor_requires_grad torch_tensor%torch_tensor_requires_grad proc~torch_tensor_multiply->proc~torch_tensor_requires_grad proc~torch_tensor_get_shape->proc~torch_tensor_get_rank Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_multiply~~CalledByGraph proc~torch_tensor_multiply torch_tensor_multiply interface~operator (ASTERISK) operator (*) interface~operator (ASTERISK)->proc~torch_tensor_multiply Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function torch_tensor_multiply ( tensor1 , tensor2 ) result ( output ) use , intrinsic :: iso_c_binding , only : c_associated type ( torch_tensor ), intent ( in ) :: tensor1 !! First tensor to be multiplied type ( torch_tensor ), intent ( in ) :: tensor2 !! Second tensor to be multiplied type ( torch_tensor ) :: output !! Tensor to hold the product if ( tensor1 % get_device_type () /= tensor2 % get_device_type ()) then write ( * , * ) \"Error :: cannot multiply tensors with different device types\" stop 1 end if if (. not . c_associated ( output % p )) then call torch_tensor_empty ( output , tensor1 % get_rank (), tensor1 % get_shape (), & tensor1 % get_dtype (), tensor1 % get_device_type (), & device_index = tensor1 % get_device_index (), & requires_grad = tensor1 % requires_grad ()) end if call torch_tensor_multiply_c ( output % p , tensor1 % p , tensor2 % p ) end function torch_tensor_multiply","tags":"","url":"proc/torch_tensor_multiply.html"},{"title":"torch_tensor_negative – FTorch","text":"public  function torch_tensor_negative(tensor) result(output) Uses iso_c_binding proc~~torch_tensor_negative~~UsesGraph proc~torch_tensor_negative torch_tensor_negative iso_c_binding iso_c_binding proc~torch_tensor_negative->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Overloads negative operator for a single tensor. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor Tensor to take the negative of Return Value type( torch_tensor ) Tensor to hold the negative values Calls proc~~torch_tensor_negative~~CallsGraph proc~torch_tensor_negative torch_tensor_negative proc~torch_tensor_empty torch_tensor_empty proc~torch_tensor_negative->proc~torch_tensor_empty proc~torch_tensor_get_device_index torch_tensor%torch_tensor_get_device_index proc~torch_tensor_negative->proc~torch_tensor_get_device_index proc~torch_tensor_get_device_type torch_tensor%torch_tensor_get_device_type proc~torch_tensor_negative->proc~torch_tensor_get_device_type proc~torch_tensor_get_dtype torch_tensor%torch_tensor_get_dtype proc~torch_tensor_negative->proc~torch_tensor_get_dtype proc~torch_tensor_get_rank torch_tensor%torch_tensor_get_rank proc~torch_tensor_negative->proc~torch_tensor_get_rank proc~torch_tensor_get_shape torch_tensor%torch_tensor_get_shape proc~torch_tensor_negative->proc~torch_tensor_get_shape proc~torch_tensor_requires_grad torch_tensor%torch_tensor_requires_grad proc~torch_tensor_negative->proc~torch_tensor_requires_grad proc~torch_tensor_get_shape->proc~torch_tensor_get_rank Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_negative~~CalledByGraph proc~torch_tensor_negative torch_tensor_negative interface~operator (-) operator (-) interface~operator (-)->proc~torch_tensor_negative Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function torch_tensor_negative ( tensor ) result ( output ) use , intrinsic :: iso_c_binding , only : c_associated type ( torch_tensor ), intent ( in ) :: tensor !! Tensor to take the negative of type ( torch_tensor ) :: output !! Tensor to hold the negative values interface subroutine torch_tensor_negative_c ( output_c , tensor_c ) bind ( c , name = 'torch_tensor_negative' ) use , intrinsic :: iso_c_binding , only : c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: tensor_c type ( c_ptr ), value , intent ( in ) :: output_c end subroutine torch_tensor_negative_c end interface if (. not . c_associated ( output % p )) then call torch_tensor_empty ( output , tensor % get_rank (), tensor % get_shape (), tensor % get_dtype (), & tensor % get_device_type (), device_index = tensor % get_device_index (), & requires_grad = tensor % requires_grad ()) end if call torch_tensor_negative_c ( output % p , tensor % p ) end function torch_tensor_negative","tags":"","url":"proc/torch_tensor_negative.html"},{"title":"torch_tensor_power_int16 – FTorch","text":"public  function torch_tensor_power_int16(tensor, power) result(output) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_power_int16~~UsesGraph proc~torch_tensor_power_int16 torch_tensor_power_int16 iso_c_binding iso_c_binding proc~torch_tensor_power_int16->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_power_int16->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Overloads exponentiation operator for a tensor and a scalar of type int16 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor Tensor to take the power of integer(kind=int16), intent(in), target :: power Integer exponent Return Value type( torch_tensor ) Tensor to hold the exponentiation Calls proc~~torch_tensor_power_int16~~CallsGraph proc~torch_tensor_power_int16 torch_tensor_power_int16 proc~torch_tensor_empty torch_tensor_empty proc~torch_tensor_power_int16->proc~torch_tensor_empty proc~torch_tensor_get_device_index torch_tensor%torch_tensor_get_device_index proc~torch_tensor_power_int16->proc~torch_tensor_get_device_index proc~torch_tensor_get_device_type torch_tensor%torch_tensor_get_device_type proc~torch_tensor_power_int16->proc~torch_tensor_get_device_type proc~torch_tensor_get_dtype torch_tensor%torch_tensor_get_dtype proc~torch_tensor_power_int16->proc~torch_tensor_get_dtype proc~torch_tensor_get_rank torch_tensor%torch_tensor_get_rank proc~torch_tensor_power_int16->proc~torch_tensor_get_rank proc~torch_tensor_get_shape torch_tensor%torch_tensor_get_shape proc~torch_tensor_power_int16->proc~torch_tensor_get_shape proc~torch_tensor_requires_grad torch_tensor%torch_tensor_requires_grad proc~torch_tensor_power_int16->proc~torch_tensor_requires_grad proc~torch_tensor_get_shape->proc~torch_tensor_get_rank Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_power_int16~~CalledByGraph proc~torch_tensor_power_int16 torch_tensor_power_int16 interface~operator (ASTERISKASTERISK) operator (**) interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_int16 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function torch_tensor_power_int16 ( tensor , power ) result ( output ) use , intrinsic :: iso_c_binding , only : c_associated , c_loc use , intrinsic :: iso_fortran_env , only : int16 type ( torch_tensor ), intent ( in ) :: tensor !! Tensor to take the power of integer ( int16 ), target , intent ( in ) :: power !! Integer exponent type ( torch_tensor ) :: output !! Tensor to hold the exponentiation interface subroutine torch_tensor_power_int_c ( output_c , tensor_c , power_c ) & bind ( c , name = 'torch_tensor_power_int' ) use , intrinsic :: iso_c_binding , only : c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: output_c type ( c_ptr ), value , intent ( in ) :: tensor_c type ( c_ptr ), value , intent ( in ) :: power_c end subroutine torch_tensor_power_int_c end interface if (. not . c_associated ( output % p )) then call torch_tensor_empty ( output , tensor % get_rank (), tensor % get_shape (), tensor % get_dtype (), & tensor % get_device_type (), device_index = tensor % get_device_index (), & requires_grad = tensor % requires_grad ()) end if call torch_tensor_power_int_c ( output % p , tensor % p , c_loc ( power )) end function torch_tensor_power_int16","tags":"","url":"proc/torch_tensor_power_int16.html"},{"title":"torch_tensor_power_int32 – FTorch","text":"public  function torch_tensor_power_int32(tensor, power) result(output) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_power_int32~~UsesGraph proc~torch_tensor_power_int32 torch_tensor_power_int32 iso_c_binding iso_c_binding proc~torch_tensor_power_int32->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_power_int32->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Overloads exponentiation operator for a tensor and a scalar of type int32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor Tensor to take the power of integer(kind=int32), intent(in), target :: power Integer exponent Return Value type( torch_tensor ) Tensor to hold the exponentiation Calls proc~~torch_tensor_power_int32~~CallsGraph proc~torch_tensor_power_int32 torch_tensor_power_int32 proc~torch_tensor_empty torch_tensor_empty proc~torch_tensor_power_int32->proc~torch_tensor_empty proc~torch_tensor_get_device_index torch_tensor%torch_tensor_get_device_index proc~torch_tensor_power_int32->proc~torch_tensor_get_device_index proc~torch_tensor_get_device_type torch_tensor%torch_tensor_get_device_type proc~torch_tensor_power_int32->proc~torch_tensor_get_device_type proc~torch_tensor_get_dtype torch_tensor%torch_tensor_get_dtype proc~torch_tensor_power_int32->proc~torch_tensor_get_dtype proc~torch_tensor_get_rank torch_tensor%torch_tensor_get_rank proc~torch_tensor_power_int32->proc~torch_tensor_get_rank proc~torch_tensor_get_shape torch_tensor%torch_tensor_get_shape proc~torch_tensor_power_int32->proc~torch_tensor_get_shape proc~torch_tensor_requires_grad torch_tensor%torch_tensor_requires_grad proc~torch_tensor_power_int32->proc~torch_tensor_requires_grad proc~torch_tensor_get_shape->proc~torch_tensor_get_rank Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_power_int32~~CalledByGraph proc~torch_tensor_power_int32 torch_tensor_power_int32 interface~operator (ASTERISKASTERISK) operator (**) interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_int32 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function torch_tensor_power_int32 ( tensor , power ) result ( output ) use , intrinsic :: iso_c_binding , only : c_associated , c_loc use , intrinsic :: iso_fortran_env , only : int32 type ( torch_tensor ), intent ( in ) :: tensor !! Tensor to take the power of integer ( int32 ), target , intent ( in ) :: power !! Integer exponent type ( torch_tensor ) :: output !! Tensor to hold the exponentiation interface subroutine torch_tensor_power_int_c ( output_c , tensor_c , power_c ) & bind ( c , name = 'torch_tensor_power_int' ) use , intrinsic :: iso_c_binding , only : c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: output_c type ( c_ptr ), value , intent ( in ) :: tensor_c type ( c_ptr ), value , intent ( in ) :: power_c end subroutine torch_tensor_power_int_c end interface if (. not . c_associated ( output % p )) then call torch_tensor_empty ( output , tensor % get_rank (), tensor % get_shape (), tensor % get_dtype (), & tensor % get_device_type (), device_index = tensor % get_device_index (), & requires_grad = tensor % requires_grad ()) end if call torch_tensor_power_int_c ( output % p , tensor % p , c_loc ( power )) end function torch_tensor_power_int32","tags":"","url":"proc/torch_tensor_power_int32.html"},{"title":"torch_tensor_power_int64 – FTorch","text":"public  function torch_tensor_power_int64(tensor, power) result(output) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_power_int64~~UsesGraph proc~torch_tensor_power_int64 torch_tensor_power_int64 iso_c_binding iso_c_binding proc~torch_tensor_power_int64->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_power_int64->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Overloads exponentiation operator for a tensor and a scalar of type int64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor Tensor to take the power of integer(kind=int64), intent(in), target :: power Integer exponent Return Value type( torch_tensor ) Tensor to hold the exponentiation Calls proc~~torch_tensor_power_int64~~CallsGraph proc~torch_tensor_power_int64 torch_tensor_power_int64 proc~torch_tensor_empty torch_tensor_empty proc~torch_tensor_power_int64->proc~torch_tensor_empty proc~torch_tensor_get_device_index torch_tensor%torch_tensor_get_device_index proc~torch_tensor_power_int64->proc~torch_tensor_get_device_index proc~torch_tensor_get_device_type torch_tensor%torch_tensor_get_device_type proc~torch_tensor_power_int64->proc~torch_tensor_get_device_type proc~torch_tensor_get_dtype torch_tensor%torch_tensor_get_dtype proc~torch_tensor_power_int64->proc~torch_tensor_get_dtype proc~torch_tensor_get_rank torch_tensor%torch_tensor_get_rank proc~torch_tensor_power_int64->proc~torch_tensor_get_rank proc~torch_tensor_get_shape torch_tensor%torch_tensor_get_shape proc~torch_tensor_power_int64->proc~torch_tensor_get_shape proc~torch_tensor_requires_grad torch_tensor%torch_tensor_requires_grad proc~torch_tensor_power_int64->proc~torch_tensor_requires_grad proc~torch_tensor_get_shape->proc~torch_tensor_get_rank Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_power_int64~~CalledByGraph proc~torch_tensor_power_int64 torch_tensor_power_int64 interface~operator (ASTERISKASTERISK) operator (**) interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_int64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function torch_tensor_power_int64 ( tensor , power ) result ( output ) use , intrinsic :: iso_c_binding , only : c_associated , c_loc use , intrinsic :: iso_fortran_env , only : int64 type ( torch_tensor ), intent ( in ) :: tensor !! Tensor to take the power of integer ( int64 ), target , intent ( in ) :: power !! Integer exponent type ( torch_tensor ) :: output !! Tensor to hold the exponentiation interface subroutine torch_tensor_power_int_c ( output_c , tensor_c , power_c ) & bind ( c , name = 'torch_tensor_power_int' ) use , intrinsic :: iso_c_binding , only : c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: output_c type ( c_ptr ), value , intent ( in ) :: tensor_c type ( c_ptr ), value , intent ( in ) :: power_c end subroutine torch_tensor_power_int_c end interface if (. not . c_associated ( output % p )) then call torch_tensor_empty ( output , tensor % get_rank (), tensor % get_shape (), tensor % get_dtype (), & tensor % get_device_type (), device_index = tensor % get_device_index (), & requires_grad = tensor % requires_grad ()) end if call torch_tensor_power_int_c ( output % p , tensor % p , c_loc ( power )) end function torch_tensor_power_int64","tags":"","url":"proc/torch_tensor_power_int64.html"},{"title":"torch_tensor_power_int8 – FTorch","text":"public  function torch_tensor_power_int8(tensor, power) result(output) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_power_int8~~UsesGraph proc~torch_tensor_power_int8 torch_tensor_power_int8 iso_c_binding iso_c_binding proc~torch_tensor_power_int8->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_power_int8->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Overloads exponentiation operator for a tensor and a scalar of type int8 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor Tensor to take the power of integer(kind=int8), intent(in), target :: power Integer exponent Return Value type( torch_tensor ) Tensor to hold the exponentiation Calls proc~~torch_tensor_power_int8~~CallsGraph proc~torch_tensor_power_int8 torch_tensor_power_int8 proc~torch_tensor_empty torch_tensor_empty proc~torch_tensor_power_int8->proc~torch_tensor_empty proc~torch_tensor_get_device_index torch_tensor%torch_tensor_get_device_index proc~torch_tensor_power_int8->proc~torch_tensor_get_device_index proc~torch_tensor_get_device_type torch_tensor%torch_tensor_get_device_type proc~torch_tensor_power_int8->proc~torch_tensor_get_device_type proc~torch_tensor_get_dtype torch_tensor%torch_tensor_get_dtype proc~torch_tensor_power_int8->proc~torch_tensor_get_dtype proc~torch_tensor_get_rank torch_tensor%torch_tensor_get_rank proc~torch_tensor_power_int8->proc~torch_tensor_get_rank proc~torch_tensor_get_shape torch_tensor%torch_tensor_get_shape proc~torch_tensor_power_int8->proc~torch_tensor_get_shape proc~torch_tensor_requires_grad torch_tensor%torch_tensor_requires_grad proc~torch_tensor_power_int8->proc~torch_tensor_requires_grad proc~torch_tensor_get_shape->proc~torch_tensor_get_rank Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_power_int8~~CalledByGraph proc~torch_tensor_power_int8 torch_tensor_power_int8 interface~operator (ASTERISKASTERISK) operator (**) interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_int8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function torch_tensor_power_int8 ( tensor , power ) result ( output ) use , intrinsic :: iso_c_binding , only : c_associated , c_loc use , intrinsic :: iso_fortran_env , only : int8 type ( torch_tensor ), intent ( in ) :: tensor !! Tensor to take the power of integer ( int8 ), target , intent ( in ) :: power !! Integer exponent type ( torch_tensor ) :: output !! Tensor to hold the exponentiation interface subroutine torch_tensor_power_int_c ( output_c , tensor_c , power_c ) & bind ( c , name = 'torch_tensor_power_int' ) use , intrinsic :: iso_c_binding , only : c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: output_c type ( c_ptr ), value , intent ( in ) :: tensor_c type ( c_ptr ), value , intent ( in ) :: power_c end subroutine torch_tensor_power_int_c end interface if (. not . c_associated ( output % p )) then call torch_tensor_empty ( output , tensor % get_rank (), tensor % get_shape (), tensor % get_dtype (), & tensor % get_device_type (), device_index = tensor % get_device_index (), & requires_grad = tensor % requires_grad ()) end if call torch_tensor_power_int_c ( output % p , tensor % p , c_loc ( power )) end function torch_tensor_power_int8","tags":"","url":"proc/torch_tensor_power_int8.html"},{"title":"torch_tensor_power_real32 – FTorch","text":"public  function torch_tensor_power_real32(tensor, power) result(output) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_power_real32~~UsesGraph proc~torch_tensor_power_real32 torch_tensor_power_real32 iso_c_binding iso_c_binding proc~torch_tensor_power_real32->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_power_real32->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Overloads exponentiation operator for a tensor and a scalar of type real32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor Tensor to take the power of real(kind=real32), intent(in), target :: power Floating point exponent Return Value type( torch_tensor ) Tensor to hold the exponentiation Calls proc~~torch_tensor_power_real32~~CallsGraph proc~torch_tensor_power_real32 torch_tensor_power_real32 proc~torch_tensor_empty torch_tensor_empty proc~torch_tensor_power_real32->proc~torch_tensor_empty proc~torch_tensor_get_device_index torch_tensor%torch_tensor_get_device_index proc~torch_tensor_power_real32->proc~torch_tensor_get_device_index proc~torch_tensor_get_device_type torch_tensor%torch_tensor_get_device_type proc~torch_tensor_power_real32->proc~torch_tensor_get_device_type proc~torch_tensor_get_dtype torch_tensor%torch_tensor_get_dtype proc~torch_tensor_power_real32->proc~torch_tensor_get_dtype proc~torch_tensor_get_rank torch_tensor%torch_tensor_get_rank proc~torch_tensor_power_real32->proc~torch_tensor_get_rank proc~torch_tensor_get_shape torch_tensor%torch_tensor_get_shape proc~torch_tensor_power_real32->proc~torch_tensor_get_shape proc~torch_tensor_requires_grad torch_tensor%torch_tensor_requires_grad proc~torch_tensor_power_real32->proc~torch_tensor_requires_grad proc~torch_tensor_get_shape->proc~torch_tensor_get_rank Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_power_real32~~CalledByGraph proc~torch_tensor_power_real32 torch_tensor_power_real32 interface~operator (ASTERISKASTERISK) operator (**) interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_real32 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function torch_tensor_power_real32 ( tensor , power ) result ( output ) use , intrinsic :: iso_c_binding , only : c_associated , c_loc use , intrinsic :: iso_fortran_env , only : real32 type ( torch_tensor ), intent ( in ) :: tensor !! Tensor to take the power of real ( kind = real32 ), target , intent ( in ) :: power !! Floating point exponent type ( torch_tensor ) :: output !! Tensor to hold the exponentiation interface subroutine torch_tensor_power_float_c ( output_c , tensor_c , power_c ) & bind ( c , name = 'torch_tensor_power_float' ) use , intrinsic :: iso_c_binding , only : c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: output_c type ( c_ptr ), value , intent ( in ) :: tensor_c type ( c_ptr ), value , intent ( in ) :: power_c end subroutine torch_tensor_power_float_c end interface if (. not . c_associated ( output % p )) then call torch_tensor_empty ( output , tensor % get_rank (), tensor % get_shape (), tensor % get_dtype (), & tensor % get_device_type (), device_index = tensor % get_device_index (), & requires_grad = tensor % requires_grad ()) end if call torch_tensor_power_float_c ( output % p , tensor % p , c_loc ( power )) end function torch_tensor_power_real32","tags":"","url":"proc/torch_tensor_power_real32.html"},{"title":"torch_tensor_power_real64 – FTorch","text":"public  function torch_tensor_power_real64(tensor, power) result(output) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_power_real64~~UsesGraph proc~torch_tensor_power_real64 torch_tensor_power_real64 iso_c_binding iso_c_binding proc~torch_tensor_power_real64->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_power_real64->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Overloads exponentiation operator for a tensor and a scalar of type real64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor Tensor to take the power of real(kind=real64), intent(in), target :: power Floating point exponent Return Value type( torch_tensor ) Tensor to hold the exponentiation Calls proc~~torch_tensor_power_real64~~CallsGraph proc~torch_tensor_power_real64 torch_tensor_power_real64 proc~torch_tensor_empty torch_tensor_empty proc~torch_tensor_power_real64->proc~torch_tensor_empty proc~torch_tensor_get_device_index torch_tensor%torch_tensor_get_device_index proc~torch_tensor_power_real64->proc~torch_tensor_get_device_index proc~torch_tensor_get_device_type torch_tensor%torch_tensor_get_device_type proc~torch_tensor_power_real64->proc~torch_tensor_get_device_type proc~torch_tensor_get_dtype torch_tensor%torch_tensor_get_dtype proc~torch_tensor_power_real64->proc~torch_tensor_get_dtype proc~torch_tensor_get_rank torch_tensor%torch_tensor_get_rank proc~torch_tensor_power_real64->proc~torch_tensor_get_rank proc~torch_tensor_get_shape torch_tensor%torch_tensor_get_shape proc~torch_tensor_power_real64->proc~torch_tensor_get_shape proc~torch_tensor_requires_grad torch_tensor%torch_tensor_requires_grad proc~torch_tensor_power_real64->proc~torch_tensor_requires_grad proc~torch_tensor_get_shape->proc~torch_tensor_get_rank Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_power_real64~~CalledByGraph proc~torch_tensor_power_real64 torch_tensor_power_real64 interface~operator (ASTERISKASTERISK) operator (**) interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_real64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function torch_tensor_power_real64 ( tensor , power ) result ( output ) use , intrinsic :: iso_c_binding , only : c_associated , c_loc use , intrinsic :: iso_fortran_env , only : real64 type ( torch_tensor ), intent ( in ) :: tensor !! Tensor to take the power of real ( kind = real64 ), target , intent ( in ) :: power !! Floating point exponent type ( torch_tensor ) :: output !! Tensor to hold the exponentiation interface subroutine torch_tensor_power_float_c ( output_c , tensor_c , power_c ) & bind ( c , name = 'torch_tensor_power_float' ) use , intrinsic :: iso_c_binding , only : c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: output_c type ( c_ptr ), value , intent ( in ) :: tensor_c type ( c_ptr ), value , intent ( in ) :: power_c end subroutine torch_tensor_power_float_c end interface if (. not . c_associated ( output % p )) then call torch_tensor_empty ( output , tensor % get_rank (), tensor % get_shape (), tensor % get_dtype (), & tensor % get_device_type (), device_index = tensor % get_device_index (), & requires_grad = tensor % requires_grad ()) end if call torch_tensor_power_float_c ( output % p , tensor % p , c_loc ( power )) end function torch_tensor_power_real64","tags":"","url":"proc/torch_tensor_power_real64.html"},{"title":"torch_tensor_requires_grad – FTorch","text":"public  function torch_tensor_requires_grad(self) result(requires_grad) Determines whether a tensor requires the autograd module. Type Bound torch_tensor Arguments Type Intent Optional Attributes Name class( torch_tensor ), intent(in) :: self Tensor to query Return Value logical Whether the tensor requires autograd Called by proc~~torch_tensor_requires_grad~~CalledByGraph proc~torch_tensor_requires_grad torch_tensor%torch_tensor_requires_grad proc~torch_tensor_add torch_tensor_add proc~torch_tensor_add->proc~torch_tensor_requires_grad proc~torch_tensor_assign torch_tensor_assign proc~torch_tensor_assign->proc~torch_tensor_requires_grad proc~torch_tensor_divide torch_tensor_divide proc~torch_tensor_divide->proc~torch_tensor_requires_grad proc~torch_tensor_multiply torch_tensor_multiply proc~torch_tensor_multiply->proc~torch_tensor_requires_grad proc~torch_tensor_negative torch_tensor_negative proc~torch_tensor_negative->proc~torch_tensor_requires_grad proc~torch_tensor_power_int16 torch_tensor_power_int16 proc~torch_tensor_power_int16->proc~torch_tensor_requires_grad proc~torch_tensor_power_int32 torch_tensor_power_int32 proc~torch_tensor_power_int32->proc~torch_tensor_requires_grad proc~torch_tensor_power_int64 torch_tensor_power_int64 proc~torch_tensor_power_int64->proc~torch_tensor_requires_grad proc~torch_tensor_power_int8 torch_tensor_power_int8 proc~torch_tensor_power_int8->proc~torch_tensor_requires_grad proc~torch_tensor_power_real32 torch_tensor_power_real32 proc~torch_tensor_power_real32->proc~torch_tensor_requires_grad proc~torch_tensor_power_real64 torch_tensor_power_real64 proc~torch_tensor_power_real64->proc~torch_tensor_requires_grad proc~torch_tensor_subtract torch_tensor_subtract proc~torch_tensor_subtract->proc~torch_tensor_requires_grad interface~assignment (=) assignment (=) interface~assignment (=)->proc~torch_tensor_assign interface~operator (+) operator (+) interface~operator (+)->proc~torch_tensor_add interface~operator (-) operator (-) interface~operator (-)->proc~torch_tensor_negative interface~operator (-)->proc~torch_tensor_subtract interface~operator (ASTERISK) operator (*) interface~operator (ASTERISK)->proc~torch_tensor_multiply interface~operator (ASTERISKASTERISK) operator (**) interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_int16 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_int32 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_int64 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_int8 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_real32 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_real64 interface~operator (SLASH) operator (/) interface~operator (SLASH)->proc~torch_tensor_divide Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function torch_tensor_requires_grad ( self ) result ( requires_grad ) class ( torch_tensor ), intent ( in ) :: self !! Tensor to query logical :: requires_grad !! Whether the tensor requires autograd interface function torch_tensor_requires_grad_c ( tensor_c ) result ( requires_grad_c ) & bind ( c , name = 'torch_tensor_requires_grad' ) use , intrinsic :: iso_c_binding , only : c_bool , c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: tensor_c logical ( c_bool ) :: requires_grad_c end function torch_tensor_requires_grad_c end interface requires_grad = torch_tensor_requires_grad_c ( self % p ) end function torch_tensor_requires_grad","tags":"","url":"proc/torch_tensor_requires_grad.html"},{"title":"torch_tensor_subtract – FTorch","text":"public  function torch_tensor_subtract(tensor1, tensor2) result(output) Uses iso_c_binding proc~~torch_tensor_subtract~~UsesGraph proc~torch_tensor_subtract torch_tensor_subtract iso_c_binding iso_c_binding proc~torch_tensor_subtract->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Overloads subtraction operator for two tensors. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor1 First tensor for the subtraction type( torch_tensor ), intent(in) :: tensor2 Second tensor for the subtraction Return Value type( torch_tensor ) Tensor to hold the difference Calls proc~~torch_tensor_subtract~~CallsGraph proc~torch_tensor_subtract torch_tensor_subtract proc~torch_tensor_empty torch_tensor_empty proc~torch_tensor_subtract->proc~torch_tensor_empty proc~torch_tensor_get_device_index torch_tensor%torch_tensor_get_device_index proc~torch_tensor_subtract->proc~torch_tensor_get_device_index proc~torch_tensor_get_device_type torch_tensor%torch_tensor_get_device_type proc~torch_tensor_subtract->proc~torch_tensor_get_device_type proc~torch_tensor_get_dtype torch_tensor%torch_tensor_get_dtype proc~torch_tensor_subtract->proc~torch_tensor_get_dtype proc~torch_tensor_get_rank torch_tensor%torch_tensor_get_rank proc~torch_tensor_subtract->proc~torch_tensor_get_rank proc~torch_tensor_get_shape torch_tensor%torch_tensor_get_shape proc~torch_tensor_subtract->proc~torch_tensor_get_shape proc~torch_tensor_requires_grad torch_tensor%torch_tensor_requires_grad proc~torch_tensor_subtract->proc~torch_tensor_requires_grad proc~torch_tensor_get_shape->proc~torch_tensor_get_rank Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_subtract~~CalledByGraph proc~torch_tensor_subtract torch_tensor_subtract interface~operator (-) operator (-) interface~operator (-)->proc~torch_tensor_subtract Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function torch_tensor_subtract ( tensor1 , tensor2 ) result ( output ) use , intrinsic :: iso_c_binding , only : c_associated type ( torch_tensor ), intent ( in ) :: tensor1 !! First tensor for the subtraction type ( torch_tensor ), intent ( in ) :: tensor2 !! Second tensor for the subtraction type ( torch_tensor ) :: output !! Tensor to hold the difference interface subroutine torch_tensor_subtract_c ( output_c , tensor1_c , tensor2_c ) & bind ( c , name = 'torch_tensor_subtract' ) use , intrinsic :: iso_c_binding , only : c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: output_c type ( c_ptr ), value , intent ( in ) :: tensor1_c type ( c_ptr ), value , intent ( in ) :: tensor2_c end subroutine torch_tensor_subtract_c end interface if ( tensor1 % get_device_type () /= tensor2 % get_device_type ()) then write ( * , * ) \"Error :: cannot subtract tensors with different device types\" stop 1 end if if (. not . c_associated ( output % p )) then call torch_tensor_empty ( output , tensor1 % get_rank (), tensor1 % get_shape (), & tensor1 % get_dtype (), tensor1 % get_device_type (), & device_index = tensor1 % get_device_index (), & requires_grad = tensor1 % requires_grad ()) end if call torch_tensor_subtract_c ( output % p , tensor1 % p , tensor2 % p ) end function torch_tensor_subtract","tags":"","url":"proc/torch_tensor_subtract.html"},{"title":"torch_model_delete – FTorch","text":"public  subroutine torch_model_delete(model) Deallocates a TorchScript model Arguments Type Intent Optional Attributes Name type( torch_model ), intent(in) :: model Torch Model to deallocate Called by proc~~torch_model_delete~~CalledByGraph proc~torch_model_delete torch_model_delete interface~torch_delete torch_delete interface~torch_delete->proc~torch_model_delete Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_model_delete ( model ) type ( torch_model ), intent ( in ) :: model !! Torch Model to deallocate interface subroutine torch_jit_model_delete_c ( model_c ) & bind ( c , name = 'torch_jit_module_delete' ) use , intrinsic :: iso_c_binding , only : c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: model_c end subroutine torch_jit_model_delete_c end interface call torch_jit_model_delete_c ( model % p ) end subroutine torch_model_delete","tags":"","url":"proc/torch_model_delete.html"},{"title":"torch_model_forward – FTorch","text":"public  subroutine torch_model_forward(model, input_tensors, output_tensors, requires_grad) Uses iso_c_binding proc~~torch_model_forward~~UsesGraph proc~torch_model_forward torch_model_forward iso_c_binding iso_c_binding proc~torch_model_forward->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Performs a forward pass of the model with the input tensors Arguments Type Intent Optional Attributes Name type( torch_model ), intent(in) :: model Model type( torch_tensor ), intent(in), dimension(:) :: input_tensors Array of Input tensors type( torch_tensor ), intent(in), dimension(:) :: output_tensors Returned output tensors logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Source Code subroutine torch_model_forward ( model , input_tensors , output_tensors , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_ptr , c_int , c_loc type ( torch_model ), intent ( in ) :: model !! Model type ( torch_tensor ), intent ( in ), dimension (:) :: input_tensors !! Array of Input tensors type ( torch_tensor ), intent ( in ), dimension (:) :: output_tensors !! Returned output tensors logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor logical :: requires_grad_value !! Whether gradients need to be computed for the created tensor integer ( ftorch_int ) :: i integer ( c_int ) :: n_inputs integer ( c_int ) :: n_outputs type ( c_ptr ), dimension ( size ( input_tensors )), target :: input_ptrs type ( c_ptr ), dimension ( size ( output_tensors )), target :: output_ptrs interface subroutine torch_jit_model_forward_c ( model_c , input_tensors_c , n_inputs_c , & output_tensors_c , n_outputs_c , requires_grad_c ) & bind ( c , name = 'torch_jit_module_forward' ) use , intrinsic :: iso_c_binding , only : c_bool , c_ptr , c_int implicit none type ( c_ptr ), value , intent ( in ) :: model_c type ( c_ptr ), value , intent ( in ) :: input_tensors_c integer ( c_int ), value , intent ( in ) :: n_inputs_c type ( c_ptr ), value , intent ( in ) :: output_tensors_c integer ( c_int ), value , intent ( in ) :: n_outputs_c logical ( c_bool ), value , intent ( in ) :: requires_grad_c end subroutine torch_jit_model_forward_c end interface n_inputs = size ( input_tensors ) n_outputs = size ( output_tensors ) if (. not . present ( requires_grad )) then requires_grad_value = . false . else requires_grad_value = requires_grad end if ! Assign array of pointers to the input tensors do i = 1 , n_inputs input_ptrs ( i ) = input_tensors ( i )% p end do ! Assign array of pointers to the output tensors do i = 1 , n_outputs output_ptrs ( i ) = output_tensors ( i )% p end do call torch_jit_model_forward_c ( model % p , c_loc ( input_ptrs ), n_inputs , & c_loc ( output_ptrs ), n_outputs , & logical ( requires_grad_value , c_bool )) end subroutine torch_model_forward","tags":"","url":"proc/torch_model_forward.html"},{"title":"torch_model_load – FTorch","text":"public  subroutine torch_model_load(model, filename, device_type, device_index, requires_grad, is_training) Uses iso_c_binding proc~~torch_model_load~~UsesGraph proc~torch_model_load torch_model_load iso_c_binding iso_c_binding proc~torch_model_load->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Loads a TorchScript nn.module (pre-trained PyTorch model saved with TorchScript) Arguments Type Intent Optional Attributes Name type( torch_model ), intent(out) :: model Returned deserialized model character(len=*), intent(in) :: filename Filename of saved TorchScript model integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer(kind=c_int), intent(in), optional :: device_index device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor logical, intent(in), optional :: is_training Whether the model is being trained, rather than evaluated Source Code subroutine torch_model_load ( model , filename , device_type , device_index , & requires_grad , is_training ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_null_char type ( torch_model ), intent ( out ) :: model !! Returned deserialized model character ( * ), intent ( in ) :: filename !! Filename of saved TorchScript model integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer ( c_int ), optional , intent ( in ) :: device_index !! device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor logical , optional , intent ( in ) :: is_training !! Whether the model is being trained, rather than evaluated integer ( c_int ) :: device_index_value logical :: requires_grad_value !! Whether gradients need to be computed for the created tensor logical :: is_training_value !! Whether the model is being trained, rather than evaluated interface function torch_jit_load_c ( filename_c , device_type_c , device_index_c , & requires_grad_c , is_training_c ) result ( model_c ) & bind ( c , name = 'torch_jit_load' ) use , intrinsic :: iso_c_binding , only : c_bool , c_char , c_int , c_ptr implicit none character ( c_char ), intent ( in ) :: filename_c ( * ) integer ( c_int ), value , intent ( in ) :: device_type_c integer ( c_int ), value , intent ( in ) :: device_index_c logical ( c_bool ), value , intent ( in ) :: requires_grad_c logical ( c_bool ), value , intent ( in ) :: is_training_c type ( c_ptr ) :: model_c end function torch_jit_load_c end interface ! Process optional arguments if ( present ( device_index )) then device_index_value = device_index else if ( device_type == torch_kCPU ) then device_index_value = - 1 else device_index_value = 0 endif if (. not . present ( requires_grad )) then requires_grad_value = . false . else requires_grad_value = requires_grad end if if (. not . present ( is_training )) then is_training_value = . false . else is_training_value = is_training end if ! Need to append c_null_char at end of filename model % p = torch_jit_load_c ( trim ( adjustl ( filename )) // c_null_char , device_type , & device_index_value , logical ( requires_grad_value , c_bool ), & logical ( is_training_value , c_bool )) end subroutine torch_model_load","tags":"","url":"proc/torch_model_load.html"},{"title":"torch_tensor_array_delete – FTorch","text":"public  subroutine torch_tensor_array_delete(tensor_array) Deallocates an array of tensors. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(inout), dimension(:) :: tensor_array Array of tensors to deallocate Calls proc~~torch_tensor_array_delete~~CallsGraph proc~torch_tensor_array_delete torch_tensor_array_delete proc~torch_tensor_delete torch_tensor_delete proc~torch_tensor_array_delete->proc~torch_tensor_delete Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_array_delete~~CalledByGraph proc~torch_tensor_array_delete torch_tensor_array_delete interface~torch_delete torch_delete interface~torch_delete->proc~torch_tensor_array_delete Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_array_delete ( tensor_array ) type ( torch_tensor ), dimension (:), intent ( inout ) :: tensor_array !! Array of tensors to deallocate ! Local data integer ( ftorch_int ) :: i ! use bounds rather than (1, N) because it's safer do i = lbound ( tensor_array , dim = 1 ), ubound ( tensor_array , dim = 1 ) call torch_tensor_delete ( tensor_array ( i )) end do end subroutine torch_tensor_array_delete","tags":"","url":"proc/torch_tensor_array_delete.html"},{"title":"torch_tensor_assign – FTorch","text":"public  subroutine torch_tensor_assign(output, input) Uses iso_c_binding proc~~torch_tensor_assign~~UsesGraph proc~torch_tensor_assign torch_tensor_assign iso_c_binding iso_c_binding proc~torch_tensor_assign->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Overloads assignment operator for tensors. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(inout) :: output Tensor to assign values to type( torch_tensor ), intent(in) :: input Tensor whose values are to be used Calls proc~~torch_tensor_assign~~CallsGraph proc~torch_tensor_assign torch_tensor_assign proc~torch_tensor_empty torch_tensor_empty proc~torch_tensor_assign->proc~torch_tensor_empty proc~torch_tensor_get_device_index torch_tensor%torch_tensor_get_device_index proc~torch_tensor_assign->proc~torch_tensor_get_device_index proc~torch_tensor_get_device_type torch_tensor%torch_tensor_get_device_type proc~torch_tensor_assign->proc~torch_tensor_get_device_type proc~torch_tensor_get_dtype torch_tensor%torch_tensor_get_dtype proc~torch_tensor_assign->proc~torch_tensor_get_dtype proc~torch_tensor_get_rank torch_tensor%torch_tensor_get_rank proc~torch_tensor_assign->proc~torch_tensor_get_rank proc~torch_tensor_get_shape torch_tensor%torch_tensor_get_shape proc~torch_tensor_assign->proc~torch_tensor_get_shape proc~torch_tensor_requires_grad torch_tensor%torch_tensor_requires_grad proc~torch_tensor_assign->proc~torch_tensor_requires_grad proc~torch_tensor_get_shape->proc~torch_tensor_get_rank Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_assign~~CalledByGraph proc~torch_tensor_assign torch_tensor_assign interface~assignment (=) assignment (=) interface~assignment (=)->proc~torch_tensor_assign Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_assign ( output , input ) use , intrinsic :: iso_c_binding , only : c_associated type ( torch_tensor ), intent ( in ) :: input !! Tensor whose values are to be used type ( torch_tensor ), intent ( inout ) :: output !! Tensor to assign values to interface subroutine torch_tensor_assign_c ( output_c , input_c ) bind ( c , name = 'torch_tensor_assign' ) use , intrinsic :: iso_c_binding , only : c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: output_c type ( c_ptr ), value , intent ( in ) :: input_c end subroutine torch_tensor_assign_c end interface if (. not . c_associated ( output % p )) then call torch_tensor_empty ( output , input % get_rank (), input % get_shape (), input % get_dtype (), & input % get_device_type (), device_index = input % get_device_index (), & requires_grad = input % requires_grad ()) else if ( input % get_device_type () /= output % get_device_type ()) then write ( * , * ) \"Error :: cannot assign tensors with different device types\" stop 1 end if call torch_tensor_assign_c ( output % p , input % p ) end subroutine torch_tensor_assign","tags":"","url":"proc/torch_tensor_assign.html"},{"title":"torch_tensor_backward – FTorch","text":"public  subroutine torch_tensor_backward(tensor, retain_graph) Uses iso_c_binding proc~~torch_tensor_backward~~UsesGraph proc~torch_tensor_backward torch_tensor_backward iso_c_binding iso_c_binding proc~torch_tensor_backward->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Performs back-propagation on a Torch Tensor, given some external gradient. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor Tensor to compute gradients of logical, intent(in), optional :: retain_graph Should the computational graph be retained? Calls proc~~torch_tensor_backward~~CallsGraph proc~torch_tensor_backward torch_tensor_backward proc~torch_tensor_delete torch_tensor_delete proc~torch_tensor_backward->proc~torch_tensor_delete proc~torch_tensor_get_device_index torch_tensor%torch_tensor_get_device_index proc~torch_tensor_backward->proc~torch_tensor_get_device_index proc~torch_tensor_get_device_type torch_tensor%torch_tensor_get_device_type proc~torch_tensor_backward->proc~torch_tensor_get_device_type proc~torch_tensor_get_dtype torch_tensor%torch_tensor_get_dtype proc~torch_tensor_backward->proc~torch_tensor_get_dtype proc~torch_tensor_get_rank torch_tensor%torch_tensor_get_rank proc~torch_tensor_backward->proc~torch_tensor_get_rank proc~torch_tensor_get_shape torch_tensor%torch_tensor_get_shape proc~torch_tensor_backward->proc~torch_tensor_get_shape proc~torch_tensor_ones torch_tensor_ones proc~torch_tensor_backward->proc~torch_tensor_ones proc~torch_tensor_get_shape->proc~torch_tensor_get_rank Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_backward ( tensor , retain_graph ) use , intrinsic :: iso_c_binding , only : c_bool type ( torch_tensor ), intent ( in ) :: tensor !! Tensor to compute gradients of logical , optional , intent ( in ) :: retain_graph !! Should the computational graph be retained? ! Local arguments type ( torch_tensor ) :: external_gradient !! External tensor used as an initial scaling of the gradient calculation logical ( c_bool ) :: retain_graph_value interface subroutine torch_tensor_backward_c ( tensor_c , external_gradient_c , retain_graph_c ) & bind ( c , name = 'torch_tensor_backward' ) use , intrinsic :: iso_c_binding , only : c_bool , c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: tensor_c type ( c_ptr ), value , intent ( in ) :: external_gradient_c logical ( c_bool ), value , intent ( in ) :: retain_graph_c end subroutine torch_tensor_backward_c end interface ! External gradient to provide to the back-propagation consisting of a tensor of ones ! TODO: Accept other external gradients as an optional argument call torch_tensor_ones ( external_gradient , tensor % get_rank (), tensor % get_shape (), & tensor % get_dtype (), tensor % get_device_type (), & device_index = tensor % get_device_index ()) ! Do not retain the graph by default if ( present ( retain_graph )) then retain_graph_value = retain_graph else retain_graph_value = . false . end if ! Call back-propagation with the provided external gradient call torch_tensor_backward_c ( tensor % p , external_gradient % p , retain_graph_value ) ! Delete the external gradient tensor call torch_tensor_delete ( external_gradient ) end subroutine torch_tensor_backward","tags":"","url":"proc/torch_tensor_backward.html"},{"title":"torch_tensor_delete – FTorch","text":"public  subroutine torch_tensor_delete(tensor) Uses iso_c_binding proc~~torch_tensor_delete~~UsesGraph proc~torch_tensor_delete torch_tensor_delete iso_c_binding iso_c_binding proc~torch_tensor_delete->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Deallocates a tensor. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(inout) :: tensor Tensor to deallocate Called by proc~~torch_tensor_delete~~CalledByGraph proc~torch_tensor_delete torch_tensor_delete interface~torch_delete torch_delete interface~torch_delete->proc~torch_tensor_delete proc~torch_tensor_array_delete torch_tensor_array_delete interface~torch_delete->proc~torch_tensor_array_delete proc~torch_tensor_array_delete->proc~torch_tensor_delete proc~torch_tensor_backward torch_tensor_backward proc~torch_tensor_backward->proc~torch_tensor_delete Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_delete ( tensor ) use , intrinsic :: iso_c_binding , only : c_associated , c_null_ptr type ( torch_tensor ), intent ( inout ) :: tensor !! Tensor to deallocate interface subroutine torch_tensor_delete_c ( tensor_c ) & bind ( c , name = 'torch_tensor_delete' ) use , intrinsic :: iso_c_binding , only : c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: tensor_c end subroutine torch_tensor_delete_c end interface ! Call the destructor, if it hasn't already been called if ( c_associated ( tensor % p )) then call torch_tensor_delete_c ( tensor % p ) tensor % p = c_null_ptr end if end subroutine torch_tensor_delete","tags":"","url":"proc/torch_tensor_delete.html"},{"title":"torch_tensor_empty – FTorch","text":"public  subroutine torch_tensor_empty(tensor, ndims, tensor_shape, dtype, device_type, device_index, requires_grad) Uses iso_c_binding proc~~torch_tensor_empty~~UsesGraph proc~torch_tensor_empty torch_tensor_empty iso_c_binding iso_c_binding proc~torch_tensor_empty->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Returns a tensor with uninitialised values. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=c_int), intent(in) :: ndims Number of dimensions of the tensor integer(kind=c_int64_t), intent(in) :: tensor_shape (:) Shape of the tensor integer(kind=c_int), intent(in) :: dtype Data type of the tensor integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Called by proc~~torch_tensor_empty~~CalledByGraph proc~torch_tensor_empty torch_tensor_empty proc~torch_tensor_add torch_tensor_add proc~torch_tensor_add->proc~torch_tensor_empty proc~torch_tensor_assign torch_tensor_assign proc~torch_tensor_assign->proc~torch_tensor_empty proc~torch_tensor_divide torch_tensor_divide proc~torch_tensor_divide->proc~torch_tensor_empty proc~torch_tensor_multiply torch_tensor_multiply proc~torch_tensor_multiply->proc~torch_tensor_empty proc~torch_tensor_negative torch_tensor_negative proc~torch_tensor_negative->proc~torch_tensor_empty proc~torch_tensor_power_int16 torch_tensor_power_int16 proc~torch_tensor_power_int16->proc~torch_tensor_empty proc~torch_tensor_power_int32 torch_tensor_power_int32 proc~torch_tensor_power_int32->proc~torch_tensor_empty proc~torch_tensor_power_int64 torch_tensor_power_int64 proc~torch_tensor_power_int64->proc~torch_tensor_empty proc~torch_tensor_power_int8 torch_tensor_power_int8 proc~torch_tensor_power_int8->proc~torch_tensor_empty proc~torch_tensor_power_real32 torch_tensor_power_real32 proc~torch_tensor_power_real32->proc~torch_tensor_empty proc~torch_tensor_power_real64 torch_tensor_power_real64 proc~torch_tensor_power_real64->proc~torch_tensor_empty proc~torch_tensor_subtract torch_tensor_subtract proc~torch_tensor_subtract->proc~torch_tensor_empty interface~assignment (=) assignment (=) interface~assignment (=)->proc~torch_tensor_assign interface~operator (+) operator (+) interface~operator (+)->proc~torch_tensor_add interface~operator (-) operator (-) interface~operator (-)->proc~torch_tensor_negative interface~operator (-)->proc~torch_tensor_subtract interface~operator (ASTERISK) operator (*) interface~operator (ASTERISK)->proc~torch_tensor_multiply interface~operator (ASTERISKASTERISK) operator (**) interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_int16 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_int32 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_int64 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_int8 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_real32 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_real64 interface~operator (SLASH) operator (/) interface~operator (SLASH)->proc~torch_tensor_divide Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_empty ( tensor , ndims , tensor_shape , dtype , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor integer ( c_int ), intent ( in ) :: ndims !! Number of dimensions of the tensor integer ( c_int64_t ), intent ( in ) :: tensor_shape (:) !! Shape of the tensor integer ( c_int ), intent ( in ) :: dtype !! Data type of the tensor integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor integer ( c_int ) :: device_index_value !! device index used logical ( c_bool ) :: requires_grad_value !! Whether gradients need to be computed for the created tensor interface function torch_empty_c ( ndims_c , tensor_shape_c , dtype_c , device_type_c , & device_index_c , requires_grad_c ) result ( tensor_c ) & bind ( c , name = 'torch_empty' ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_ptr implicit none integer ( c_int ), value , intent ( in ) :: ndims_c integer ( c_int64_t ), intent ( in ) :: tensor_shape_c ( * ) integer ( c_int ), value , intent ( in ) :: dtype_c integer ( c_int ), value , intent ( in ) :: device_type_c integer ( c_int ), value , intent ( in ) :: device_index_c logical ( c_bool ), value , intent ( in ) :: requires_grad_c type ( c_ptr ) :: tensor_c end function torch_empty_c end interface ! Process optional arguments if ( present ( device_index )) then device_index_value = device_index else if ( device_type == torch_kCPU ) then device_index_value = - 1 else device_index_value = 0 endif if (. not . present ( requires_grad )) then requires_grad_value = logical (. false ., c_bool ) else requires_grad_value = requires_grad end if tensor % p = torch_empty_c ( ndims , tensor_shape , dtype , device_type , & device_index_value , requires_grad_value ) end subroutine torch_tensor_empty","tags":"","url":"proc/torch_tensor_empty.html"},{"title":"torch_tensor_from_array_int16_1d – FTorch","text":"public  subroutine torch_tensor_from_array_int16_1d(tensor, data_in, layout, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int16_1d~~UsesGraph proc~torch_tensor_from_array_int16_1d torch_tensor_from_array_int16_1d iso_c_binding iso_c_binding proc~torch_tensor_from_array_int16_1d->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int16_1d->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 1 containing data of type int16 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (1) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int16_1d~~CallsGraph proc~torch_tensor_from_array_int16_1d torch_tensor_from_array_int16_1d proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d->proc~torch_tensor_from_blob interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int16_1d~~CalledByGraph proc~torch_tensor_from_array_int16_1d torch_tensor_from_array_int16_1d interface~torch_tensor_from_array torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int16_1d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int16 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int16 ), intent ( in ), target :: data_in (:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 1 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 1 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt16 !! Data type integer ( c_int ), parameter :: ndims = 1 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int16_1d","tags":"","url":"proc/torch_tensor_from_array_int16_1d.html"},{"title":"torch_tensor_from_array_int16_1d_default_layout – FTorch","text":"public  subroutine torch_tensor_from_array_int16_1d_default_layout(tensor, data_in, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int16_1d_default_layout~~UsesGraph proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout iso_c_binding iso_c_binding proc~torch_tensor_from_array_int16_1d_default_layout->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int16_1d_default_layout->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 1 containing data of type int16 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int16_1d_default_layout~~CallsGraph proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_1d torch_tensor_from_array_int16_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d proc~torch_tensor_from_array_int16_2d torch_tensor_from_array_int16_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d torch_tensor_from_array_int16_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d torch_tensor_from_array_int16_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d torch_tensor_from_array_int16_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d torch_tensor_from_array_int32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d torch_tensor_from_array_int32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d torch_tensor_from_array_int32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d torch_tensor_from_array_int32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d torch_tensor_from_array_int32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d torch_tensor_from_array_int64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d torch_tensor_from_array_int64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d torch_tensor_from_array_int64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d torch_tensor_from_array_int64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d torch_tensor_from_array_int64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d torch_tensor_from_array_int8_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d torch_tensor_from_array_int8_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d torch_tensor_from_array_int8_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d torch_tensor_from_array_int8_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d torch_tensor_from_array_int8_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d torch_tensor_from_array_real32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d torch_tensor_from_array_real32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d torch_tensor_from_array_real32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d torch_tensor_from_array_real32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d torch_tensor_from_array_real32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d torch_tensor_from_array_real64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d torch_tensor_from_array_real64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d torch_tensor_from_array_real64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d torch_tensor_from_array_real64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d torch_tensor_from_array_real64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int16_1d_default_layout~~CalledByGraph proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int16_1d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int16 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int16 ), intent ( in ), target :: data_in (:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 1 ) !! Order of indices integer ( c_int ), parameter :: ndims = 1 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int16_1d_default_layout","tags":"","url":"proc/torch_tensor_from_array_int16_1d_default_layout.html"},{"title":"torch_tensor_from_array_int16_2d – FTorch","text":"public  subroutine torch_tensor_from_array_int16_2d(tensor, data_in, layout, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int16_2d~~UsesGraph proc~torch_tensor_from_array_int16_2d torch_tensor_from_array_int16_2d iso_c_binding iso_c_binding proc~torch_tensor_from_array_int16_2d->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int16_2d->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 2 containing data of type int16 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (2) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int16_2d~~CallsGraph proc~torch_tensor_from_array_int16_2d torch_tensor_from_array_int16_2d proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int16_2d->proc~torch_tensor_from_blob interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int16_2d~~CalledByGraph proc~torch_tensor_from_array_int16_2d torch_tensor_from_array_int16_2d interface~torch_tensor_from_array torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int16_2d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int16 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int16 ), intent ( in ), target :: data_in (:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 2 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 2 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt16 !! Data type integer ( c_int ), parameter :: ndims = 2 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int16_2d","tags":"","url":"proc/torch_tensor_from_array_int16_2d.html"},{"title":"torch_tensor_from_array_int16_2d_default_layout – FTorch","text":"public  subroutine torch_tensor_from_array_int16_2d_default_layout(tensor, data_in, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int16_2d_default_layout~~UsesGraph proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout iso_c_binding iso_c_binding proc~torch_tensor_from_array_int16_2d_default_layout->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int16_2d_default_layout->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 2 containing data of type int16 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int16_2d_default_layout~~CallsGraph proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_1d torch_tensor_from_array_int16_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d torch_tensor_from_array_int16_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d proc~torch_tensor_from_array_int16_3d torch_tensor_from_array_int16_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d torch_tensor_from_array_int16_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d torch_tensor_from_array_int16_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d torch_tensor_from_array_int32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d torch_tensor_from_array_int32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d torch_tensor_from_array_int32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d torch_tensor_from_array_int32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d torch_tensor_from_array_int32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d torch_tensor_from_array_int64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d torch_tensor_from_array_int64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d torch_tensor_from_array_int64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d torch_tensor_from_array_int64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d torch_tensor_from_array_int64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d torch_tensor_from_array_int8_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d torch_tensor_from_array_int8_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d torch_tensor_from_array_int8_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d torch_tensor_from_array_int8_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d torch_tensor_from_array_int8_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d torch_tensor_from_array_real32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d torch_tensor_from_array_real32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d torch_tensor_from_array_real32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d torch_tensor_from_array_real32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d torch_tensor_from_array_real32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d torch_tensor_from_array_real64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d torch_tensor_from_array_real64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d torch_tensor_from_array_real64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d torch_tensor_from_array_real64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d torch_tensor_from_array_real64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int16_2d_default_layout~~CalledByGraph proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int16_2d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int16 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int16 ), intent ( in ), target :: data_in (:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 2 ) !! Order of indices integer ( c_int ), parameter :: ndims = 2 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int16_2d_default_layout","tags":"","url":"proc/torch_tensor_from_array_int16_2d_default_layout.html"},{"title":"torch_tensor_from_array_int16_3d – FTorch","text":"public  subroutine torch_tensor_from_array_int16_3d(tensor, data_in, layout, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int16_3d~~UsesGraph proc~torch_tensor_from_array_int16_3d torch_tensor_from_array_int16_3d iso_c_binding iso_c_binding proc~torch_tensor_from_array_int16_3d->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int16_3d->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 3 containing data of type int16 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (3) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int16_3d~~CallsGraph proc~torch_tensor_from_array_int16_3d torch_tensor_from_array_int16_3d proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int16_3d->proc~torch_tensor_from_blob interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int16_3d~~CalledByGraph proc~torch_tensor_from_array_int16_3d torch_tensor_from_array_int16_3d interface~torch_tensor_from_array torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int16_3d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int16 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int16 ), intent ( in ), target :: data_in (:,:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 3 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 3 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt16 !! Data type integer ( c_int ), parameter :: ndims = 3 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int16_3d","tags":"","url":"proc/torch_tensor_from_array_int16_3d.html"},{"title":"torch_tensor_from_array_int16_3d_default_layout – FTorch","text":"public  subroutine torch_tensor_from_array_int16_3d_default_layout(tensor, data_in, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int16_3d_default_layout~~UsesGraph proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout iso_c_binding iso_c_binding proc~torch_tensor_from_array_int16_3d_default_layout->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int16_3d_default_layout->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 3 containing data of type int16 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int16_3d_default_layout~~CallsGraph proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_1d torch_tensor_from_array_int16_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d torch_tensor_from_array_int16_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d torch_tensor_from_array_int16_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d proc~torch_tensor_from_array_int16_4d torch_tensor_from_array_int16_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d torch_tensor_from_array_int16_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d torch_tensor_from_array_int32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d torch_tensor_from_array_int32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d torch_tensor_from_array_int32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d torch_tensor_from_array_int32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d torch_tensor_from_array_int32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d torch_tensor_from_array_int64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d torch_tensor_from_array_int64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d torch_tensor_from_array_int64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d torch_tensor_from_array_int64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d torch_tensor_from_array_int64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d torch_tensor_from_array_int8_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d torch_tensor_from_array_int8_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d torch_tensor_from_array_int8_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d torch_tensor_from_array_int8_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d torch_tensor_from_array_int8_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d torch_tensor_from_array_real32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d torch_tensor_from_array_real32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d torch_tensor_from_array_real32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d torch_tensor_from_array_real32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d torch_tensor_from_array_real32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d torch_tensor_from_array_real64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d torch_tensor_from_array_real64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d torch_tensor_from_array_real64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d torch_tensor_from_array_real64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d torch_tensor_from_array_real64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int16_3d_default_layout~~CalledByGraph proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int16_3d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int16 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int16 ), intent ( in ), target :: data_in (:,:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 3 ) !! Order of indices integer ( c_int ), parameter :: ndims = 3 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int16_3d_default_layout","tags":"","url":"proc/torch_tensor_from_array_int16_3d_default_layout.html"},{"title":"torch_tensor_from_array_int16_4d – FTorch","text":"public  subroutine torch_tensor_from_array_int16_4d(tensor, data_in, layout, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int16_4d~~UsesGraph proc~torch_tensor_from_array_int16_4d torch_tensor_from_array_int16_4d iso_c_binding iso_c_binding proc~torch_tensor_from_array_int16_4d->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int16_4d->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 4 containing data of type int16 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (4) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int16_4d~~CallsGraph proc~torch_tensor_from_array_int16_4d torch_tensor_from_array_int16_4d proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int16_4d->proc~torch_tensor_from_blob interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int16_4d~~CalledByGraph proc~torch_tensor_from_array_int16_4d torch_tensor_from_array_int16_4d interface~torch_tensor_from_array torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int16_4d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int16 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int16 ), intent ( in ), target :: data_in (:,:,:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 4 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 4 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt16 !! Data type integer ( c_int ), parameter :: ndims = 4 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int16_4d","tags":"","url":"proc/torch_tensor_from_array_int16_4d.html"},{"title":"torch_tensor_from_array_int16_4d_default_layout – FTorch","text":"public  subroutine torch_tensor_from_array_int16_4d_default_layout(tensor, data_in, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int16_4d_default_layout~~UsesGraph proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout iso_c_binding iso_c_binding proc~torch_tensor_from_array_int16_4d_default_layout->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int16_4d_default_layout->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 4 containing data of type int16 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int16_4d_default_layout~~CallsGraph proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_1d torch_tensor_from_array_int16_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d torch_tensor_from_array_int16_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d torch_tensor_from_array_int16_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d torch_tensor_from_array_int16_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d proc~torch_tensor_from_array_int16_5d torch_tensor_from_array_int16_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d torch_tensor_from_array_int32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d torch_tensor_from_array_int32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d torch_tensor_from_array_int32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d torch_tensor_from_array_int32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d torch_tensor_from_array_int32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d torch_tensor_from_array_int64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d torch_tensor_from_array_int64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d torch_tensor_from_array_int64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d torch_tensor_from_array_int64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d torch_tensor_from_array_int64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d torch_tensor_from_array_int8_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d torch_tensor_from_array_int8_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d torch_tensor_from_array_int8_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d torch_tensor_from_array_int8_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d torch_tensor_from_array_int8_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d torch_tensor_from_array_real32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d torch_tensor_from_array_real32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d torch_tensor_from_array_real32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d torch_tensor_from_array_real32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d torch_tensor_from_array_real32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d torch_tensor_from_array_real64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d torch_tensor_from_array_real64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d torch_tensor_from_array_real64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d torch_tensor_from_array_real64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d torch_tensor_from_array_real64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int16_4d_default_layout~~CalledByGraph proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int16_4d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int16 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int16 ), intent ( in ), target :: data_in (:,:,:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 4 ) !! Order of indices integer ( c_int ), parameter :: ndims = 4 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int16_4d_default_layout","tags":"","url":"proc/torch_tensor_from_array_int16_4d_default_layout.html"},{"title":"torch_tensor_from_array_int16_5d – FTorch","text":"public  subroutine torch_tensor_from_array_int16_5d(tensor, data_in, layout, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int16_5d~~UsesGraph proc~torch_tensor_from_array_int16_5d torch_tensor_from_array_int16_5d iso_c_binding iso_c_binding proc~torch_tensor_from_array_int16_5d->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int16_5d->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 5 containing data of type int16 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (5) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int16_5d~~CallsGraph proc~torch_tensor_from_array_int16_5d torch_tensor_from_array_int16_5d proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int16_5d->proc~torch_tensor_from_blob interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int16_5d~~CalledByGraph proc~torch_tensor_from_array_int16_5d torch_tensor_from_array_int16_5d interface~torch_tensor_from_array torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int16_5d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int16 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int16 ), intent ( in ), target :: data_in (:,:,:,:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 5 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 5 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt16 !! Data type integer ( c_int ), parameter :: ndims = 5 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int16_5d","tags":"","url":"proc/torch_tensor_from_array_int16_5d.html"},{"title":"torch_tensor_from_array_int16_5d_default_layout – FTorch","text":"public  subroutine torch_tensor_from_array_int16_5d_default_layout(tensor, data_in, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int16_5d_default_layout~~UsesGraph proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout iso_c_binding iso_c_binding proc~torch_tensor_from_array_int16_5d_default_layout->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int16_5d_default_layout->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 5 containing data of type int16 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int16_5d_default_layout~~CallsGraph proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int16_1d torch_tensor_from_array_int16_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d torch_tensor_from_array_int16_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d torch_tensor_from_array_int16_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d torch_tensor_from_array_int16_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d torch_tensor_from_array_int16_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d proc~torch_tensor_from_array_int32_1d torch_tensor_from_array_int32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d torch_tensor_from_array_int32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d torch_tensor_from_array_int32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d torch_tensor_from_array_int32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d torch_tensor_from_array_int32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d torch_tensor_from_array_int64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d torch_tensor_from_array_int64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d torch_tensor_from_array_int64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d torch_tensor_from_array_int64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d torch_tensor_from_array_int64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d torch_tensor_from_array_int8_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d torch_tensor_from_array_int8_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d torch_tensor_from_array_int8_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d torch_tensor_from_array_int8_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d torch_tensor_from_array_int8_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d torch_tensor_from_array_real32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d torch_tensor_from_array_real32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d torch_tensor_from_array_real32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d torch_tensor_from_array_real32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d torch_tensor_from_array_real32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d torch_tensor_from_array_real64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d torch_tensor_from_array_real64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d torch_tensor_from_array_real64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d torch_tensor_from_array_real64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d torch_tensor_from_array_real64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int16_5d_default_layout~~CalledByGraph proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int16_5d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int16 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int16 ), intent ( in ), target :: data_in (:,:,:,:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 5 ) !! Order of indices integer ( c_int ), parameter :: ndims = 5 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int16_5d_default_layout","tags":"","url":"proc/torch_tensor_from_array_int16_5d_default_layout.html"},{"title":"torch_tensor_from_array_int32_1d – FTorch","text":"public  subroutine torch_tensor_from_array_int32_1d(tensor, data_in, layout, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int32_1d~~UsesGraph proc~torch_tensor_from_array_int32_1d torch_tensor_from_array_int32_1d iso_c_binding iso_c_binding proc~torch_tensor_from_array_int32_1d->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int32_1d->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 1 containing data of type int32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (1) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int32_1d~~CallsGraph proc~torch_tensor_from_array_int32_1d torch_tensor_from_array_int32_1d proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int32_1d->proc~torch_tensor_from_blob interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int32_1d~~CalledByGraph proc~torch_tensor_from_array_int32_1d torch_tensor_from_array_int32_1d interface~torch_tensor_from_array torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int32_1d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int32 ), intent ( in ), target :: data_in (:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 1 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 1 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt32 !! Data type integer ( c_int ), parameter :: ndims = 1 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int32_1d","tags":"","url":"proc/torch_tensor_from_array_int32_1d.html"},{"title":"torch_tensor_from_array_int32_1d_default_layout – FTorch","text":"public  subroutine torch_tensor_from_array_int32_1d_default_layout(tensor, data_in, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int32_1d_default_layout~~UsesGraph proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout iso_c_binding iso_c_binding proc~torch_tensor_from_array_int32_1d_default_layout->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int32_1d_default_layout->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 1 containing data of type int32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int32_1d_default_layout~~CallsGraph proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int16_1d torch_tensor_from_array_int16_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d torch_tensor_from_array_int16_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d torch_tensor_from_array_int16_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d torch_tensor_from_array_int16_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d torch_tensor_from_array_int16_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d torch_tensor_from_array_int32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d proc~torch_tensor_from_array_int32_2d torch_tensor_from_array_int32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d torch_tensor_from_array_int32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d torch_tensor_from_array_int32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d torch_tensor_from_array_int32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d torch_tensor_from_array_int64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d torch_tensor_from_array_int64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d torch_tensor_from_array_int64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d torch_tensor_from_array_int64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d torch_tensor_from_array_int64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d torch_tensor_from_array_int8_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d torch_tensor_from_array_int8_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d torch_tensor_from_array_int8_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d torch_tensor_from_array_int8_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d torch_tensor_from_array_int8_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d torch_tensor_from_array_real32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d torch_tensor_from_array_real32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d torch_tensor_from_array_real32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d torch_tensor_from_array_real32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d torch_tensor_from_array_real32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d torch_tensor_from_array_real64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d torch_tensor_from_array_real64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d torch_tensor_from_array_real64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d torch_tensor_from_array_real64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d torch_tensor_from_array_real64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int32_1d_default_layout~~CalledByGraph proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int32_1d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int32 ), intent ( in ), target :: data_in (:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 1 ) !! Order of indices integer ( c_int ), parameter :: ndims = 1 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int32_1d_default_layout","tags":"","url":"proc/torch_tensor_from_array_int32_1d_default_layout.html"},{"title":"torch_tensor_from_array_int32_2d – FTorch","text":"public  subroutine torch_tensor_from_array_int32_2d(tensor, data_in, layout, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int32_2d~~UsesGraph proc~torch_tensor_from_array_int32_2d torch_tensor_from_array_int32_2d iso_c_binding iso_c_binding proc~torch_tensor_from_array_int32_2d->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int32_2d->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 2 containing data of type int32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (2) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int32_2d~~CallsGraph proc~torch_tensor_from_array_int32_2d torch_tensor_from_array_int32_2d proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int32_2d->proc~torch_tensor_from_blob interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int32_2d~~CalledByGraph proc~torch_tensor_from_array_int32_2d torch_tensor_from_array_int32_2d interface~torch_tensor_from_array torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int32_2d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int32 ), intent ( in ), target :: data_in (:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 2 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 2 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt32 !! Data type integer ( c_int ), parameter :: ndims = 2 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int32_2d","tags":"","url":"proc/torch_tensor_from_array_int32_2d.html"},{"title":"torch_tensor_from_array_int32_2d_default_layout – FTorch","text":"public  subroutine torch_tensor_from_array_int32_2d_default_layout(tensor, data_in, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int32_2d_default_layout~~UsesGraph proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout iso_c_binding iso_c_binding proc~torch_tensor_from_array_int32_2d_default_layout->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int32_2d_default_layout->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 2 containing data of type int32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int32_2d_default_layout~~CallsGraph proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int16_1d torch_tensor_from_array_int16_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d torch_tensor_from_array_int16_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d torch_tensor_from_array_int16_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d torch_tensor_from_array_int16_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d torch_tensor_from_array_int16_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d torch_tensor_from_array_int32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d torch_tensor_from_array_int32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d proc~torch_tensor_from_array_int32_3d torch_tensor_from_array_int32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d torch_tensor_from_array_int32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d torch_tensor_from_array_int32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d torch_tensor_from_array_int64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d torch_tensor_from_array_int64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d torch_tensor_from_array_int64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d torch_tensor_from_array_int64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d torch_tensor_from_array_int64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d torch_tensor_from_array_int8_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d torch_tensor_from_array_int8_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d torch_tensor_from_array_int8_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d torch_tensor_from_array_int8_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d torch_tensor_from_array_int8_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d torch_tensor_from_array_real32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d torch_tensor_from_array_real32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d torch_tensor_from_array_real32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d torch_tensor_from_array_real32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d torch_tensor_from_array_real32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d torch_tensor_from_array_real64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d torch_tensor_from_array_real64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d torch_tensor_from_array_real64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d torch_tensor_from_array_real64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d torch_tensor_from_array_real64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int32_2d_default_layout~~CalledByGraph proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int32_2d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int32 ), intent ( in ), target :: data_in (:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 2 ) !! Order of indices integer ( c_int ), parameter :: ndims = 2 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int32_2d_default_layout","tags":"","url":"proc/torch_tensor_from_array_int32_2d_default_layout.html"},{"title":"torch_tensor_from_array_int32_3d – FTorch","text":"public  subroutine torch_tensor_from_array_int32_3d(tensor, data_in, layout, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int32_3d~~UsesGraph proc~torch_tensor_from_array_int32_3d torch_tensor_from_array_int32_3d iso_c_binding iso_c_binding proc~torch_tensor_from_array_int32_3d->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int32_3d->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 3 containing data of type int32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (3) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int32_3d~~CallsGraph proc~torch_tensor_from_array_int32_3d torch_tensor_from_array_int32_3d proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int32_3d->proc~torch_tensor_from_blob interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int32_3d~~CalledByGraph proc~torch_tensor_from_array_int32_3d torch_tensor_from_array_int32_3d interface~torch_tensor_from_array torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int32_3d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int32 ), intent ( in ), target :: data_in (:,:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 3 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 3 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt32 !! Data type integer ( c_int ), parameter :: ndims = 3 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int32_3d","tags":"","url":"proc/torch_tensor_from_array_int32_3d.html"},{"title":"torch_tensor_from_array_int32_3d_default_layout – FTorch","text":"public  subroutine torch_tensor_from_array_int32_3d_default_layout(tensor, data_in, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int32_3d_default_layout~~UsesGraph proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout iso_c_binding iso_c_binding proc~torch_tensor_from_array_int32_3d_default_layout->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int32_3d_default_layout->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 3 containing data of type int32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int32_3d_default_layout~~CallsGraph proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int16_1d torch_tensor_from_array_int16_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d torch_tensor_from_array_int16_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d torch_tensor_from_array_int16_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d torch_tensor_from_array_int16_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d torch_tensor_from_array_int16_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d torch_tensor_from_array_int32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d torch_tensor_from_array_int32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d torch_tensor_from_array_int32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d proc~torch_tensor_from_array_int32_4d torch_tensor_from_array_int32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d torch_tensor_from_array_int32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d torch_tensor_from_array_int64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d torch_tensor_from_array_int64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d torch_tensor_from_array_int64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d torch_tensor_from_array_int64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d torch_tensor_from_array_int64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d torch_tensor_from_array_int8_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d torch_tensor_from_array_int8_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d torch_tensor_from_array_int8_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d torch_tensor_from_array_int8_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d torch_tensor_from_array_int8_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d torch_tensor_from_array_real32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d torch_tensor_from_array_real32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d torch_tensor_from_array_real32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d torch_tensor_from_array_real32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d torch_tensor_from_array_real32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d torch_tensor_from_array_real64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d torch_tensor_from_array_real64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d torch_tensor_from_array_real64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d torch_tensor_from_array_real64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d torch_tensor_from_array_real64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int32_3d_default_layout~~CalledByGraph proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int32_3d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int32 ), intent ( in ), target :: data_in (:,:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 3 ) !! Order of indices integer ( c_int ), parameter :: ndims = 3 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int32_3d_default_layout","tags":"","url":"proc/torch_tensor_from_array_int32_3d_default_layout.html"},{"title":"torch_tensor_from_array_int32_4d – FTorch","text":"public  subroutine torch_tensor_from_array_int32_4d(tensor, data_in, layout, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int32_4d~~UsesGraph proc~torch_tensor_from_array_int32_4d torch_tensor_from_array_int32_4d iso_c_binding iso_c_binding proc~torch_tensor_from_array_int32_4d->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int32_4d->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 4 containing data of type int32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (4) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int32_4d~~CallsGraph proc~torch_tensor_from_array_int32_4d torch_tensor_from_array_int32_4d proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int32_4d->proc~torch_tensor_from_blob interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int32_4d~~CalledByGraph proc~torch_tensor_from_array_int32_4d torch_tensor_from_array_int32_4d interface~torch_tensor_from_array torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int32_4d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int32 ), intent ( in ), target :: data_in (:,:,:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 4 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 4 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt32 !! Data type integer ( c_int ), parameter :: ndims = 4 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int32_4d","tags":"","url":"proc/torch_tensor_from_array_int32_4d.html"},{"title":"torch_tensor_from_array_int32_4d_default_layout – FTorch","text":"public  subroutine torch_tensor_from_array_int32_4d_default_layout(tensor, data_in, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int32_4d_default_layout~~UsesGraph proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout iso_c_binding iso_c_binding proc~torch_tensor_from_array_int32_4d_default_layout->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int32_4d_default_layout->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 4 containing data of type int32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int32_4d_default_layout~~CallsGraph proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int16_1d torch_tensor_from_array_int16_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d torch_tensor_from_array_int16_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d torch_tensor_from_array_int16_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d torch_tensor_from_array_int16_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d torch_tensor_from_array_int16_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d torch_tensor_from_array_int32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d torch_tensor_from_array_int32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d torch_tensor_from_array_int32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d torch_tensor_from_array_int32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d proc~torch_tensor_from_array_int32_5d torch_tensor_from_array_int32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d torch_tensor_from_array_int64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d torch_tensor_from_array_int64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d torch_tensor_from_array_int64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d torch_tensor_from_array_int64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d torch_tensor_from_array_int64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d torch_tensor_from_array_int8_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d torch_tensor_from_array_int8_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d torch_tensor_from_array_int8_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d torch_tensor_from_array_int8_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d torch_tensor_from_array_int8_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d torch_tensor_from_array_real32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d torch_tensor_from_array_real32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d torch_tensor_from_array_real32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d torch_tensor_from_array_real32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d torch_tensor_from_array_real32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d torch_tensor_from_array_real64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d torch_tensor_from_array_real64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d torch_tensor_from_array_real64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d torch_tensor_from_array_real64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d torch_tensor_from_array_real64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int32_4d_default_layout~~CalledByGraph proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int32_4d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int32 ), intent ( in ), target :: data_in (:,:,:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 4 ) !! Order of indices integer ( c_int ), parameter :: ndims = 4 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int32_4d_default_layout","tags":"","url":"proc/torch_tensor_from_array_int32_4d_default_layout.html"},{"title":"torch_tensor_from_array_int32_5d – FTorch","text":"public  subroutine torch_tensor_from_array_int32_5d(tensor, data_in, layout, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int32_5d~~UsesGraph proc~torch_tensor_from_array_int32_5d torch_tensor_from_array_int32_5d iso_c_binding iso_c_binding proc~torch_tensor_from_array_int32_5d->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int32_5d->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 5 containing data of type int32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (5) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int32_5d~~CallsGraph proc~torch_tensor_from_array_int32_5d torch_tensor_from_array_int32_5d proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int32_5d->proc~torch_tensor_from_blob interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int32_5d~~CalledByGraph proc~torch_tensor_from_array_int32_5d torch_tensor_from_array_int32_5d interface~torch_tensor_from_array torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int32_5d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int32 ), intent ( in ), target :: data_in (:,:,:,:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 5 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 5 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt32 !! Data type integer ( c_int ), parameter :: ndims = 5 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int32_5d","tags":"","url":"proc/torch_tensor_from_array_int32_5d.html"},{"title":"torch_tensor_from_array_int32_5d_default_layout – FTorch","text":"public  subroutine torch_tensor_from_array_int32_5d_default_layout(tensor, data_in, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int32_5d_default_layout~~UsesGraph proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout iso_c_binding iso_c_binding proc~torch_tensor_from_array_int32_5d_default_layout->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int32_5d_default_layout->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 5 containing data of type int32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int32_5d_default_layout~~CallsGraph proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int16_1d torch_tensor_from_array_int16_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d torch_tensor_from_array_int16_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d torch_tensor_from_array_int16_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d torch_tensor_from_array_int16_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d torch_tensor_from_array_int16_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d torch_tensor_from_array_int32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d torch_tensor_from_array_int32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d torch_tensor_from_array_int32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d torch_tensor_from_array_int32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d torch_tensor_from_array_int32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d proc~torch_tensor_from_array_int64_1d torch_tensor_from_array_int64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d torch_tensor_from_array_int64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d torch_tensor_from_array_int64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d torch_tensor_from_array_int64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d torch_tensor_from_array_int64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d torch_tensor_from_array_int8_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d torch_tensor_from_array_int8_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d torch_tensor_from_array_int8_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d torch_tensor_from_array_int8_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d torch_tensor_from_array_int8_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d torch_tensor_from_array_real32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d torch_tensor_from_array_real32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d torch_tensor_from_array_real32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d torch_tensor_from_array_real32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d torch_tensor_from_array_real32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d torch_tensor_from_array_real64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d torch_tensor_from_array_real64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d torch_tensor_from_array_real64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d torch_tensor_from_array_real64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d torch_tensor_from_array_real64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int32_5d_default_layout~~CalledByGraph proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int32_5d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int32 ), intent ( in ), target :: data_in (:,:,:,:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 5 ) !! Order of indices integer ( c_int ), parameter :: ndims = 5 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int32_5d_default_layout","tags":"","url":"proc/torch_tensor_from_array_int32_5d_default_layout.html"},{"title":"torch_tensor_from_array_int64_1d – FTorch","text":"public  subroutine torch_tensor_from_array_int64_1d(tensor, data_in, layout, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int64_1d~~UsesGraph proc~torch_tensor_from_array_int64_1d torch_tensor_from_array_int64_1d iso_c_binding iso_c_binding proc~torch_tensor_from_array_int64_1d->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int64_1d->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 1 containing data of type int64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (1) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int64_1d~~CallsGraph proc~torch_tensor_from_array_int64_1d torch_tensor_from_array_int64_1d proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int64_1d->proc~torch_tensor_from_blob interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int64_1d~~CalledByGraph proc~torch_tensor_from_array_int64_1d torch_tensor_from_array_int64_1d interface~torch_tensor_from_array torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int64_1d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int64 ), intent ( in ), target :: data_in (:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 1 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 1 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt64 !! Data type integer ( c_int ), parameter :: ndims = 1 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int64_1d","tags":"","url":"proc/torch_tensor_from_array_int64_1d.html"},{"title":"torch_tensor_from_array_int64_1d_default_layout – FTorch","text":"public  subroutine torch_tensor_from_array_int64_1d_default_layout(tensor, data_in, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int64_1d_default_layout~~UsesGraph proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout iso_c_binding iso_c_binding proc~torch_tensor_from_array_int64_1d_default_layout->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int64_1d_default_layout->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 1 containing data of type int64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int64_1d_default_layout~~CallsGraph proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int16_1d torch_tensor_from_array_int16_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d torch_tensor_from_array_int16_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d torch_tensor_from_array_int16_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d torch_tensor_from_array_int16_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d torch_tensor_from_array_int16_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d torch_tensor_from_array_int32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d torch_tensor_from_array_int32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d torch_tensor_from_array_int32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d torch_tensor_from_array_int32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d torch_tensor_from_array_int32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d torch_tensor_from_array_int64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d proc~torch_tensor_from_array_int64_2d torch_tensor_from_array_int64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d torch_tensor_from_array_int64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d torch_tensor_from_array_int64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d torch_tensor_from_array_int64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d torch_tensor_from_array_int8_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d torch_tensor_from_array_int8_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d torch_tensor_from_array_int8_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d torch_tensor_from_array_int8_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d torch_tensor_from_array_int8_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d torch_tensor_from_array_real32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d torch_tensor_from_array_real32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d torch_tensor_from_array_real32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d torch_tensor_from_array_real32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d torch_tensor_from_array_real32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d torch_tensor_from_array_real64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d torch_tensor_from_array_real64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d torch_tensor_from_array_real64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d torch_tensor_from_array_real64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d torch_tensor_from_array_real64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int64_1d_default_layout~~CalledByGraph proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int64_1d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int64 ), intent ( in ), target :: data_in (:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 1 ) !! Order of indices integer ( c_int ), parameter :: ndims = 1 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int64_1d_default_layout","tags":"","url":"proc/torch_tensor_from_array_int64_1d_default_layout.html"},{"title":"torch_tensor_from_array_int64_2d – FTorch","text":"public  subroutine torch_tensor_from_array_int64_2d(tensor, data_in, layout, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int64_2d~~UsesGraph proc~torch_tensor_from_array_int64_2d torch_tensor_from_array_int64_2d iso_c_binding iso_c_binding proc~torch_tensor_from_array_int64_2d->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int64_2d->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 2 containing data of type int64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (2) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int64_2d~~CallsGraph proc~torch_tensor_from_array_int64_2d torch_tensor_from_array_int64_2d proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int64_2d->proc~torch_tensor_from_blob interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int64_2d~~CalledByGraph proc~torch_tensor_from_array_int64_2d torch_tensor_from_array_int64_2d interface~torch_tensor_from_array torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int64_2d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int64 ), intent ( in ), target :: data_in (:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 2 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 2 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt64 !! Data type integer ( c_int ), parameter :: ndims = 2 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int64_2d","tags":"","url":"proc/torch_tensor_from_array_int64_2d.html"},{"title":"torch_tensor_from_array_int64_2d_default_layout – FTorch","text":"public  subroutine torch_tensor_from_array_int64_2d_default_layout(tensor, data_in, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int64_2d_default_layout~~UsesGraph proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout iso_c_binding iso_c_binding proc~torch_tensor_from_array_int64_2d_default_layout->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int64_2d_default_layout->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 2 containing data of type int64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int64_2d_default_layout~~CallsGraph proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int16_1d torch_tensor_from_array_int16_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d torch_tensor_from_array_int16_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d torch_tensor_from_array_int16_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d torch_tensor_from_array_int16_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d torch_tensor_from_array_int16_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d torch_tensor_from_array_int32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d torch_tensor_from_array_int32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d torch_tensor_from_array_int32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d torch_tensor_from_array_int32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d torch_tensor_from_array_int32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d torch_tensor_from_array_int64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d torch_tensor_from_array_int64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d proc~torch_tensor_from_array_int64_3d torch_tensor_from_array_int64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d torch_tensor_from_array_int64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d torch_tensor_from_array_int64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d torch_tensor_from_array_int8_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d torch_tensor_from_array_int8_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d torch_tensor_from_array_int8_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d torch_tensor_from_array_int8_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d torch_tensor_from_array_int8_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d torch_tensor_from_array_real32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d torch_tensor_from_array_real32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d torch_tensor_from_array_real32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d torch_tensor_from_array_real32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d torch_tensor_from_array_real32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d torch_tensor_from_array_real64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d torch_tensor_from_array_real64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d torch_tensor_from_array_real64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d torch_tensor_from_array_real64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d torch_tensor_from_array_real64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int64_2d_default_layout~~CalledByGraph proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int64_2d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int64 ), intent ( in ), target :: data_in (:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 2 ) !! Order of indices integer ( c_int ), parameter :: ndims = 2 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int64_2d_default_layout","tags":"","url":"proc/torch_tensor_from_array_int64_2d_default_layout.html"},{"title":"torch_tensor_from_array_int64_3d – FTorch","text":"public  subroutine torch_tensor_from_array_int64_3d(tensor, data_in, layout, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int64_3d~~UsesGraph proc~torch_tensor_from_array_int64_3d torch_tensor_from_array_int64_3d iso_c_binding iso_c_binding proc~torch_tensor_from_array_int64_3d->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int64_3d->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 3 containing data of type int64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (3) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int64_3d~~CallsGraph proc~torch_tensor_from_array_int64_3d torch_tensor_from_array_int64_3d proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int64_3d->proc~torch_tensor_from_blob interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int64_3d~~CalledByGraph proc~torch_tensor_from_array_int64_3d torch_tensor_from_array_int64_3d interface~torch_tensor_from_array torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int64_3d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int64 ), intent ( in ), target :: data_in (:,:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 3 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 3 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt64 !! Data type integer ( c_int ), parameter :: ndims = 3 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int64_3d","tags":"","url":"proc/torch_tensor_from_array_int64_3d.html"},{"title":"torch_tensor_from_array_int64_3d_default_layout – FTorch","text":"public  subroutine torch_tensor_from_array_int64_3d_default_layout(tensor, data_in, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int64_3d_default_layout~~UsesGraph proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout iso_c_binding iso_c_binding proc~torch_tensor_from_array_int64_3d_default_layout->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int64_3d_default_layout->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 3 containing data of type int64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int64_3d_default_layout~~CallsGraph proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int16_1d torch_tensor_from_array_int16_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d torch_tensor_from_array_int16_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d torch_tensor_from_array_int16_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d torch_tensor_from_array_int16_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d torch_tensor_from_array_int16_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d torch_tensor_from_array_int32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d torch_tensor_from_array_int32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d torch_tensor_from_array_int32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d torch_tensor_from_array_int32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d torch_tensor_from_array_int32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d torch_tensor_from_array_int64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d torch_tensor_from_array_int64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d torch_tensor_from_array_int64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d proc~torch_tensor_from_array_int64_4d torch_tensor_from_array_int64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d torch_tensor_from_array_int64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d torch_tensor_from_array_int8_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d torch_tensor_from_array_int8_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d torch_tensor_from_array_int8_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d torch_tensor_from_array_int8_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d torch_tensor_from_array_int8_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d torch_tensor_from_array_real32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d torch_tensor_from_array_real32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d torch_tensor_from_array_real32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d torch_tensor_from_array_real32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d torch_tensor_from_array_real32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d torch_tensor_from_array_real64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d torch_tensor_from_array_real64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d torch_tensor_from_array_real64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d torch_tensor_from_array_real64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d torch_tensor_from_array_real64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int64_3d_default_layout~~CalledByGraph proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int64_3d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int64 ), intent ( in ), target :: data_in (:,:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 3 ) !! Order of indices integer ( c_int ), parameter :: ndims = 3 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int64_3d_default_layout","tags":"","url":"proc/torch_tensor_from_array_int64_3d_default_layout.html"},{"title":"torch_tensor_from_array_int64_4d – FTorch","text":"public  subroutine torch_tensor_from_array_int64_4d(tensor, data_in, layout, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int64_4d~~UsesGraph proc~torch_tensor_from_array_int64_4d torch_tensor_from_array_int64_4d iso_c_binding iso_c_binding proc~torch_tensor_from_array_int64_4d->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int64_4d->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 4 containing data of type int64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (4) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int64_4d~~CallsGraph proc~torch_tensor_from_array_int64_4d torch_tensor_from_array_int64_4d proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int64_4d->proc~torch_tensor_from_blob interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int64_4d~~CalledByGraph proc~torch_tensor_from_array_int64_4d torch_tensor_from_array_int64_4d interface~torch_tensor_from_array torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int64_4d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int64 ), intent ( in ), target :: data_in (:,:,:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 4 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 4 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt64 !! Data type integer ( c_int ), parameter :: ndims = 4 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int64_4d","tags":"","url":"proc/torch_tensor_from_array_int64_4d.html"},{"title":"torch_tensor_from_array_int64_4d_default_layout – FTorch","text":"public  subroutine torch_tensor_from_array_int64_4d_default_layout(tensor, data_in, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int64_4d_default_layout~~UsesGraph proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout iso_c_binding iso_c_binding proc~torch_tensor_from_array_int64_4d_default_layout->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int64_4d_default_layout->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 4 containing data of type int64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int64_4d_default_layout~~CallsGraph proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int16_1d torch_tensor_from_array_int16_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d torch_tensor_from_array_int16_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d torch_tensor_from_array_int16_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d torch_tensor_from_array_int16_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d torch_tensor_from_array_int16_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d torch_tensor_from_array_int32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d torch_tensor_from_array_int32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d torch_tensor_from_array_int32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d torch_tensor_from_array_int32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d torch_tensor_from_array_int32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d torch_tensor_from_array_int64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d torch_tensor_from_array_int64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d torch_tensor_from_array_int64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d torch_tensor_from_array_int64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d proc~torch_tensor_from_array_int64_5d torch_tensor_from_array_int64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d torch_tensor_from_array_int8_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d torch_tensor_from_array_int8_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d torch_tensor_from_array_int8_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d torch_tensor_from_array_int8_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d torch_tensor_from_array_int8_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d torch_tensor_from_array_real32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d torch_tensor_from_array_real32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d torch_tensor_from_array_real32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d torch_tensor_from_array_real32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d torch_tensor_from_array_real32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d torch_tensor_from_array_real64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d torch_tensor_from_array_real64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d torch_tensor_from_array_real64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d torch_tensor_from_array_real64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d torch_tensor_from_array_real64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int64_4d_default_layout~~CalledByGraph proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int64_4d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int64 ), intent ( in ), target :: data_in (:,:,:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 4 ) !! Order of indices integer ( c_int ), parameter :: ndims = 4 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int64_4d_default_layout","tags":"","url":"proc/torch_tensor_from_array_int64_4d_default_layout.html"},{"title":"torch_tensor_from_array_int64_5d – FTorch","text":"public  subroutine torch_tensor_from_array_int64_5d(tensor, data_in, layout, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int64_5d~~UsesGraph proc~torch_tensor_from_array_int64_5d torch_tensor_from_array_int64_5d iso_c_binding iso_c_binding proc~torch_tensor_from_array_int64_5d->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int64_5d->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 5 containing data of type int64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (5) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int64_5d~~CallsGraph proc~torch_tensor_from_array_int64_5d torch_tensor_from_array_int64_5d proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int64_5d->proc~torch_tensor_from_blob interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int64_5d~~CalledByGraph proc~torch_tensor_from_array_int64_5d torch_tensor_from_array_int64_5d interface~torch_tensor_from_array torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int64_5d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int64 ), intent ( in ), target :: data_in (:,:,:,:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 5 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 5 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt64 !! Data type integer ( c_int ), parameter :: ndims = 5 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int64_5d","tags":"","url":"proc/torch_tensor_from_array_int64_5d.html"},{"title":"torch_tensor_from_array_int64_5d_default_layout – FTorch","text":"public  subroutine torch_tensor_from_array_int64_5d_default_layout(tensor, data_in, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int64_5d_default_layout~~UsesGraph proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout iso_c_binding iso_c_binding proc~torch_tensor_from_array_int64_5d_default_layout->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int64_5d_default_layout->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 5 containing data of type int64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int64_5d_default_layout~~CallsGraph proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int16_1d torch_tensor_from_array_int16_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d torch_tensor_from_array_int16_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d torch_tensor_from_array_int16_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d torch_tensor_from_array_int16_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d torch_tensor_from_array_int16_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d torch_tensor_from_array_int32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d torch_tensor_from_array_int32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d torch_tensor_from_array_int32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d torch_tensor_from_array_int32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d torch_tensor_from_array_int32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d torch_tensor_from_array_int64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d torch_tensor_from_array_int64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d torch_tensor_from_array_int64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d torch_tensor_from_array_int64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d torch_tensor_from_array_int64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d proc~torch_tensor_from_array_int8_1d torch_tensor_from_array_int8_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d torch_tensor_from_array_int8_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d torch_tensor_from_array_int8_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d torch_tensor_from_array_int8_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d torch_tensor_from_array_int8_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d torch_tensor_from_array_real32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d torch_tensor_from_array_real32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d torch_tensor_from_array_real32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d torch_tensor_from_array_real32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d torch_tensor_from_array_real32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d torch_tensor_from_array_real64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d torch_tensor_from_array_real64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d torch_tensor_from_array_real64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d torch_tensor_from_array_real64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d torch_tensor_from_array_real64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int64_5d_default_layout~~CalledByGraph proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int64_5d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int64 ), intent ( in ), target :: data_in (:,:,:,:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 5 ) !! Order of indices integer ( c_int ), parameter :: ndims = 5 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int64_5d_default_layout","tags":"","url":"proc/torch_tensor_from_array_int64_5d_default_layout.html"},{"title":"torch_tensor_from_array_int8_1d – FTorch","text":"public  subroutine torch_tensor_from_array_int8_1d(tensor, data_in, layout, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int8_1d~~UsesGraph proc~torch_tensor_from_array_int8_1d torch_tensor_from_array_int8_1d iso_c_binding iso_c_binding proc~torch_tensor_from_array_int8_1d->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int8_1d->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 1 containing data of type int8 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (1) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int8_1d~~CallsGraph proc~torch_tensor_from_array_int8_1d torch_tensor_from_array_int8_1d proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int8_1d->proc~torch_tensor_from_blob interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int8_1d~~CalledByGraph proc~torch_tensor_from_array_int8_1d torch_tensor_from_array_int8_1d interface~torch_tensor_from_array torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int8_1d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int8 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int8 ), intent ( in ), target :: data_in (:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 1 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 1 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt8 !! Data type integer ( c_int ), parameter :: ndims = 1 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int8_1d","tags":"","url":"proc/torch_tensor_from_array_int8_1d.html"},{"title":"torch_tensor_from_array_int8_1d_default_layout – FTorch","text":"public  subroutine torch_tensor_from_array_int8_1d_default_layout(tensor, data_in, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int8_1d_default_layout~~UsesGraph proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout iso_c_binding iso_c_binding proc~torch_tensor_from_array_int8_1d_default_layout->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int8_1d_default_layout->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 1 containing data of type int8 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int8_1d_default_layout~~CallsGraph proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int16_1d torch_tensor_from_array_int16_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d torch_tensor_from_array_int16_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d torch_tensor_from_array_int16_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d torch_tensor_from_array_int16_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d torch_tensor_from_array_int16_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d torch_tensor_from_array_int32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d torch_tensor_from_array_int32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d torch_tensor_from_array_int32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d torch_tensor_from_array_int32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d torch_tensor_from_array_int32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d torch_tensor_from_array_int64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d torch_tensor_from_array_int64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d torch_tensor_from_array_int64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d torch_tensor_from_array_int64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d torch_tensor_from_array_int64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d torch_tensor_from_array_int8_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d proc~torch_tensor_from_array_int8_2d torch_tensor_from_array_int8_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d torch_tensor_from_array_int8_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d torch_tensor_from_array_int8_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d torch_tensor_from_array_int8_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d torch_tensor_from_array_real32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d torch_tensor_from_array_real32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d torch_tensor_from_array_real32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d torch_tensor_from_array_real32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d torch_tensor_from_array_real32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d torch_tensor_from_array_real64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d torch_tensor_from_array_real64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d torch_tensor_from_array_real64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d torch_tensor_from_array_real64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d torch_tensor_from_array_real64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int8_1d_default_layout~~CalledByGraph proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int8_1d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int8 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int8 ), intent ( in ), target :: data_in (:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 1 ) !! Order of indices integer ( c_int ), parameter :: ndims = 1 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int8_1d_default_layout","tags":"","url":"proc/torch_tensor_from_array_int8_1d_default_layout.html"},{"title":"torch_tensor_from_array_int8_2d – FTorch","text":"public  subroutine torch_tensor_from_array_int8_2d(tensor, data_in, layout, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int8_2d~~UsesGraph proc~torch_tensor_from_array_int8_2d torch_tensor_from_array_int8_2d iso_c_binding iso_c_binding proc~torch_tensor_from_array_int8_2d->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int8_2d->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 2 containing data of type int8 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (2) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int8_2d~~CallsGraph proc~torch_tensor_from_array_int8_2d torch_tensor_from_array_int8_2d proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int8_2d->proc~torch_tensor_from_blob interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int8_2d~~CalledByGraph proc~torch_tensor_from_array_int8_2d torch_tensor_from_array_int8_2d interface~torch_tensor_from_array torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int8_2d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int8 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int8 ), intent ( in ), target :: data_in (:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 2 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 2 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt8 !! Data type integer ( c_int ), parameter :: ndims = 2 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int8_2d","tags":"","url":"proc/torch_tensor_from_array_int8_2d.html"},{"title":"torch_tensor_from_array_int8_2d_default_layout – FTorch","text":"public  subroutine torch_tensor_from_array_int8_2d_default_layout(tensor, data_in, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int8_2d_default_layout~~UsesGraph proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout iso_c_binding iso_c_binding proc~torch_tensor_from_array_int8_2d_default_layout->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int8_2d_default_layout->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 2 containing data of type int8 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int8_2d_default_layout~~CallsGraph proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int16_1d torch_tensor_from_array_int16_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d torch_tensor_from_array_int16_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d torch_tensor_from_array_int16_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d torch_tensor_from_array_int16_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d torch_tensor_from_array_int16_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d torch_tensor_from_array_int32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d torch_tensor_from_array_int32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d torch_tensor_from_array_int32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d torch_tensor_from_array_int32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d torch_tensor_from_array_int32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d torch_tensor_from_array_int64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d torch_tensor_from_array_int64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d torch_tensor_from_array_int64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d torch_tensor_from_array_int64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d torch_tensor_from_array_int64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d torch_tensor_from_array_int8_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d torch_tensor_from_array_int8_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d proc~torch_tensor_from_array_int8_3d torch_tensor_from_array_int8_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d torch_tensor_from_array_int8_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d torch_tensor_from_array_int8_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d torch_tensor_from_array_real32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d torch_tensor_from_array_real32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d torch_tensor_from_array_real32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d torch_tensor_from_array_real32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d torch_tensor_from_array_real32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d torch_tensor_from_array_real64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d torch_tensor_from_array_real64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d torch_tensor_from_array_real64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d torch_tensor_from_array_real64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d torch_tensor_from_array_real64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int8_2d_default_layout~~CalledByGraph proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int8_2d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int8 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int8 ), intent ( in ), target :: data_in (:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 2 ) !! Order of indices integer ( c_int ), parameter :: ndims = 2 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int8_2d_default_layout","tags":"","url":"proc/torch_tensor_from_array_int8_2d_default_layout.html"},{"title":"torch_tensor_from_array_int8_3d – FTorch","text":"public  subroutine torch_tensor_from_array_int8_3d(tensor, data_in, layout, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int8_3d~~UsesGraph proc~torch_tensor_from_array_int8_3d torch_tensor_from_array_int8_3d iso_c_binding iso_c_binding proc~torch_tensor_from_array_int8_3d->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int8_3d->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 3 containing data of type int8 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (3) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int8_3d~~CallsGraph proc~torch_tensor_from_array_int8_3d torch_tensor_from_array_int8_3d proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int8_3d->proc~torch_tensor_from_blob interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int8_3d~~CalledByGraph proc~torch_tensor_from_array_int8_3d torch_tensor_from_array_int8_3d interface~torch_tensor_from_array torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int8_3d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int8 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int8 ), intent ( in ), target :: data_in (:,:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 3 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 3 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt8 !! Data type integer ( c_int ), parameter :: ndims = 3 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int8_3d","tags":"","url":"proc/torch_tensor_from_array_int8_3d.html"},{"title":"torch_tensor_from_array_int8_3d_default_layout – FTorch","text":"public  subroutine torch_tensor_from_array_int8_3d_default_layout(tensor, data_in, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int8_3d_default_layout~~UsesGraph proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout iso_c_binding iso_c_binding proc~torch_tensor_from_array_int8_3d_default_layout->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int8_3d_default_layout->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 3 containing data of type int8 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int8_3d_default_layout~~CallsGraph proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int16_1d torch_tensor_from_array_int16_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d torch_tensor_from_array_int16_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d torch_tensor_from_array_int16_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d torch_tensor_from_array_int16_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d torch_tensor_from_array_int16_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d torch_tensor_from_array_int32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d torch_tensor_from_array_int32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d torch_tensor_from_array_int32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d torch_tensor_from_array_int32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d torch_tensor_from_array_int32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d torch_tensor_from_array_int64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d torch_tensor_from_array_int64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d torch_tensor_from_array_int64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d torch_tensor_from_array_int64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d torch_tensor_from_array_int64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d torch_tensor_from_array_int8_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d torch_tensor_from_array_int8_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d torch_tensor_from_array_int8_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d proc~torch_tensor_from_array_int8_4d torch_tensor_from_array_int8_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d torch_tensor_from_array_int8_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d torch_tensor_from_array_real32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d torch_tensor_from_array_real32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d torch_tensor_from_array_real32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d torch_tensor_from_array_real32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d torch_tensor_from_array_real32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d torch_tensor_from_array_real64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d torch_tensor_from_array_real64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d torch_tensor_from_array_real64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d torch_tensor_from_array_real64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d torch_tensor_from_array_real64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int8_3d_default_layout~~CalledByGraph proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int8_3d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int8 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int8 ), intent ( in ), target :: data_in (:,:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 3 ) !! Order of indices integer ( c_int ), parameter :: ndims = 3 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int8_3d_default_layout","tags":"","url":"proc/torch_tensor_from_array_int8_3d_default_layout.html"},{"title":"torch_tensor_from_array_int8_4d – FTorch","text":"public  subroutine torch_tensor_from_array_int8_4d(tensor, data_in, layout, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int8_4d~~UsesGraph proc~torch_tensor_from_array_int8_4d torch_tensor_from_array_int8_4d iso_c_binding iso_c_binding proc~torch_tensor_from_array_int8_4d->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int8_4d->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 4 containing data of type int8 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (4) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int8_4d~~CallsGraph proc~torch_tensor_from_array_int8_4d torch_tensor_from_array_int8_4d proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int8_4d->proc~torch_tensor_from_blob interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int8_4d~~CalledByGraph proc~torch_tensor_from_array_int8_4d torch_tensor_from_array_int8_4d interface~torch_tensor_from_array torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int8_4d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int8 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int8 ), intent ( in ), target :: data_in (:,:,:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 4 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 4 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt8 !! Data type integer ( c_int ), parameter :: ndims = 4 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int8_4d","tags":"","url":"proc/torch_tensor_from_array_int8_4d.html"},{"title":"torch_tensor_from_array_int8_4d_default_layout – FTorch","text":"public  subroutine torch_tensor_from_array_int8_4d_default_layout(tensor, data_in, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int8_4d_default_layout~~UsesGraph proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout iso_c_binding iso_c_binding proc~torch_tensor_from_array_int8_4d_default_layout->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int8_4d_default_layout->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 4 containing data of type int8 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int8_4d_default_layout~~CallsGraph proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int16_1d torch_tensor_from_array_int16_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d torch_tensor_from_array_int16_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d torch_tensor_from_array_int16_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d torch_tensor_from_array_int16_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d torch_tensor_from_array_int16_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d torch_tensor_from_array_int32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d torch_tensor_from_array_int32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d torch_tensor_from_array_int32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d torch_tensor_from_array_int32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d torch_tensor_from_array_int32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d torch_tensor_from_array_int64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d torch_tensor_from_array_int64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d torch_tensor_from_array_int64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d torch_tensor_from_array_int64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d torch_tensor_from_array_int64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d torch_tensor_from_array_int8_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d torch_tensor_from_array_int8_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d torch_tensor_from_array_int8_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d torch_tensor_from_array_int8_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d proc~torch_tensor_from_array_int8_5d torch_tensor_from_array_int8_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d torch_tensor_from_array_real32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d torch_tensor_from_array_real32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d torch_tensor_from_array_real32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d torch_tensor_from_array_real32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d torch_tensor_from_array_real32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d torch_tensor_from_array_real64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d torch_tensor_from_array_real64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d torch_tensor_from_array_real64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d torch_tensor_from_array_real64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d torch_tensor_from_array_real64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int8_4d_default_layout~~CalledByGraph proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int8_4d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int8 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int8 ), intent ( in ), target :: data_in (:,:,:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 4 ) !! Order of indices integer ( c_int ), parameter :: ndims = 4 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int8_4d_default_layout","tags":"","url":"proc/torch_tensor_from_array_int8_4d_default_layout.html"},{"title":"torch_tensor_from_array_int8_5d – FTorch","text":"public  subroutine torch_tensor_from_array_int8_5d(tensor, data_in, layout, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int8_5d~~UsesGraph proc~torch_tensor_from_array_int8_5d torch_tensor_from_array_int8_5d iso_c_binding iso_c_binding proc~torch_tensor_from_array_int8_5d->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int8_5d->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 5 containing data of type int8 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (5) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int8_5d~~CallsGraph proc~torch_tensor_from_array_int8_5d torch_tensor_from_array_int8_5d proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int8_5d->proc~torch_tensor_from_blob interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int8_5d~~CalledByGraph proc~torch_tensor_from_array_int8_5d torch_tensor_from_array_int8_5d interface~torch_tensor_from_array torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int8_5d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int8 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int8 ), intent ( in ), target :: data_in (:,:,:,:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 5 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 5 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt8 !! Data type integer ( c_int ), parameter :: ndims = 5 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int8_5d","tags":"","url":"proc/torch_tensor_from_array_int8_5d.html"},{"title":"torch_tensor_from_array_int8_5d_default_layout – FTorch","text":"public  subroutine torch_tensor_from_array_int8_5d_default_layout(tensor, data_in, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_int8_5d_default_layout~~UsesGraph proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout iso_c_binding iso_c_binding proc~torch_tensor_from_array_int8_5d_default_layout->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_int8_5d_default_layout->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 5 containing data of type int8 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_int8_5d_default_layout~~CallsGraph proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_int16_1d torch_tensor_from_array_int16_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d torch_tensor_from_array_int16_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d torch_tensor_from_array_int16_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d torch_tensor_from_array_int16_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d torch_tensor_from_array_int16_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d torch_tensor_from_array_int32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d torch_tensor_from_array_int32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d torch_tensor_from_array_int32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d torch_tensor_from_array_int32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d torch_tensor_from_array_int32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d torch_tensor_from_array_int64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d torch_tensor_from_array_int64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d torch_tensor_from_array_int64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d torch_tensor_from_array_int64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d torch_tensor_from_array_int64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d torch_tensor_from_array_int8_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d torch_tensor_from_array_int8_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d torch_tensor_from_array_int8_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d torch_tensor_from_array_int8_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d torch_tensor_from_array_int8_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d proc~torch_tensor_from_array_real32_1d torch_tensor_from_array_real32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d torch_tensor_from_array_real32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d torch_tensor_from_array_real32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d torch_tensor_from_array_real32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d torch_tensor_from_array_real32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d torch_tensor_from_array_real64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d torch_tensor_from_array_real64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d torch_tensor_from_array_real64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d torch_tensor_from_array_real64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d torch_tensor_from_array_real64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_int8_5d_default_layout~~CalledByGraph proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_int8_5d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int8 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int8 ), intent ( in ), target :: data_in (:,:,:,:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 5 ) !! Order of indices integer ( c_int ), parameter :: ndims = 5 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int8_5d_default_layout","tags":"","url":"proc/torch_tensor_from_array_int8_5d_default_layout.html"},{"title":"torch_tensor_from_array_real32_1d – FTorch","text":"public  subroutine torch_tensor_from_array_real32_1d(tensor, data_in, layout, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_real32_1d~~UsesGraph proc~torch_tensor_from_array_real32_1d torch_tensor_from_array_real32_1d iso_c_binding iso_c_binding proc~torch_tensor_from_array_real32_1d->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_real32_1d->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 1 containing data of type real32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (1) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_real32_1d~~CallsGraph proc~torch_tensor_from_array_real32_1d torch_tensor_from_array_real32_1d proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_real32_1d->proc~torch_tensor_from_blob interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_real32_1d~~CalledByGraph proc~torch_tensor_from_array_real32_1d torch_tensor_from_array_real32_1d interface~torch_tensor_from_array torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_real32_1d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : real32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real32 ), intent ( in ), target :: data_in (:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 1 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 1 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kFloat32 !! Data type integer ( c_int ), parameter :: ndims = 1 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_real32_1d","tags":"","url":"proc/torch_tensor_from_array_real32_1d.html"},{"title":"torch_tensor_from_array_real32_1d_default_layout – FTorch","text":"public  subroutine torch_tensor_from_array_real32_1d_default_layout(tensor, data_in, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_real32_1d_default_layout~~UsesGraph proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout iso_c_binding iso_c_binding proc~torch_tensor_from_array_real32_1d_default_layout->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_real32_1d_default_layout->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 1 containing data of type real32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_real32_1d_default_layout~~CallsGraph proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_int16_1d torch_tensor_from_array_int16_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d torch_tensor_from_array_int16_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d torch_tensor_from_array_int16_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d torch_tensor_from_array_int16_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d torch_tensor_from_array_int16_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d torch_tensor_from_array_int32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d torch_tensor_from_array_int32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d torch_tensor_from_array_int32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d torch_tensor_from_array_int32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d torch_tensor_from_array_int32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d torch_tensor_from_array_int64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d torch_tensor_from_array_int64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d torch_tensor_from_array_int64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d torch_tensor_from_array_int64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d torch_tensor_from_array_int64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d torch_tensor_from_array_int8_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d torch_tensor_from_array_int8_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d torch_tensor_from_array_int8_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d torch_tensor_from_array_int8_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d torch_tensor_from_array_int8_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d torch_tensor_from_array_real32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d proc~torch_tensor_from_array_real32_2d torch_tensor_from_array_real32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d torch_tensor_from_array_real32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d torch_tensor_from_array_real32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d torch_tensor_from_array_real32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d torch_tensor_from_array_real64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d torch_tensor_from_array_real64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d torch_tensor_from_array_real64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d torch_tensor_from_array_real64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d torch_tensor_from_array_real64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_real32_1d_default_layout~~CalledByGraph proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_real32_1d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : real32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real32 ), intent ( in ), target :: data_in (:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 1 ) !! Order of indices integer ( c_int ), parameter :: ndims = 1 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_real32_1d_default_layout","tags":"","url":"proc/torch_tensor_from_array_real32_1d_default_layout.html"},{"title":"torch_tensor_from_array_real32_2d – FTorch","text":"public  subroutine torch_tensor_from_array_real32_2d(tensor, data_in, layout, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_real32_2d~~UsesGraph proc~torch_tensor_from_array_real32_2d torch_tensor_from_array_real32_2d iso_c_binding iso_c_binding proc~torch_tensor_from_array_real32_2d->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_real32_2d->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 2 containing data of type real32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (2) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_real32_2d~~CallsGraph proc~torch_tensor_from_array_real32_2d torch_tensor_from_array_real32_2d proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_real32_2d->proc~torch_tensor_from_blob interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_real32_2d~~CalledByGraph proc~torch_tensor_from_array_real32_2d torch_tensor_from_array_real32_2d interface~torch_tensor_from_array torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_real32_2d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : real32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real32 ), intent ( in ), target :: data_in (:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 2 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 2 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kFloat32 !! Data type integer ( c_int ), parameter :: ndims = 2 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_real32_2d","tags":"","url":"proc/torch_tensor_from_array_real32_2d.html"},{"title":"torch_tensor_from_array_real32_2d_default_layout – FTorch","text":"public  subroutine torch_tensor_from_array_real32_2d_default_layout(tensor, data_in, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_real32_2d_default_layout~~UsesGraph proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout iso_c_binding iso_c_binding proc~torch_tensor_from_array_real32_2d_default_layout->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_real32_2d_default_layout->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 2 containing data of type real32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_real32_2d_default_layout~~CallsGraph proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_int16_1d torch_tensor_from_array_int16_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d torch_tensor_from_array_int16_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d torch_tensor_from_array_int16_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d torch_tensor_from_array_int16_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d torch_tensor_from_array_int16_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d torch_tensor_from_array_int32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d torch_tensor_from_array_int32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d torch_tensor_from_array_int32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d torch_tensor_from_array_int32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d torch_tensor_from_array_int32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d torch_tensor_from_array_int64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d torch_tensor_from_array_int64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d torch_tensor_from_array_int64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d torch_tensor_from_array_int64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d torch_tensor_from_array_int64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d torch_tensor_from_array_int8_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d torch_tensor_from_array_int8_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d torch_tensor_from_array_int8_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d torch_tensor_from_array_int8_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d torch_tensor_from_array_int8_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d torch_tensor_from_array_real32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d torch_tensor_from_array_real32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d proc~torch_tensor_from_array_real32_3d torch_tensor_from_array_real32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d torch_tensor_from_array_real32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d torch_tensor_from_array_real32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d torch_tensor_from_array_real64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d torch_tensor_from_array_real64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d torch_tensor_from_array_real64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d torch_tensor_from_array_real64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d torch_tensor_from_array_real64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_real32_2d_default_layout~~CalledByGraph proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_real32_2d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : real32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real32 ), intent ( in ), target :: data_in (:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 2 ) !! Order of indices integer ( c_int ), parameter :: ndims = 2 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_real32_2d_default_layout","tags":"","url":"proc/torch_tensor_from_array_real32_2d_default_layout.html"},{"title":"torch_tensor_from_array_real32_3d – FTorch","text":"public  subroutine torch_tensor_from_array_real32_3d(tensor, data_in, layout, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_real32_3d~~UsesGraph proc~torch_tensor_from_array_real32_3d torch_tensor_from_array_real32_3d iso_c_binding iso_c_binding proc~torch_tensor_from_array_real32_3d->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_real32_3d->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 3 containing data of type real32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (3) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_real32_3d~~CallsGraph proc~torch_tensor_from_array_real32_3d torch_tensor_from_array_real32_3d proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_real32_3d->proc~torch_tensor_from_blob interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_real32_3d~~CalledByGraph proc~torch_tensor_from_array_real32_3d torch_tensor_from_array_real32_3d interface~torch_tensor_from_array torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_real32_3d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : real32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real32 ), intent ( in ), target :: data_in (:,:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 3 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 3 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kFloat32 !! Data type integer ( c_int ), parameter :: ndims = 3 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_real32_3d","tags":"","url":"proc/torch_tensor_from_array_real32_3d.html"},{"title":"torch_tensor_from_array_real32_3d_default_layout – FTorch","text":"public  subroutine torch_tensor_from_array_real32_3d_default_layout(tensor, data_in, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_real32_3d_default_layout~~UsesGraph proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout iso_c_binding iso_c_binding proc~torch_tensor_from_array_real32_3d_default_layout->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_real32_3d_default_layout->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 3 containing data of type real32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_real32_3d_default_layout~~CallsGraph proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_int16_1d torch_tensor_from_array_int16_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d torch_tensor_from_array_int16_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d torch_tensor_from_array_int16_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d torch_tensor_from_array_int16_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d torch_tensor_from_array_int16_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d torch_tensor_from_array_int32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d torch_tensor_from_array_int32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d torch_tensor_from_array_int32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d torch_tensor_from_array_int32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d torch_tensor_from_array_int32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d torch_tensor_from_array_int64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d torch_tensor_from_array_int64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d torch_tensor_from_array_int64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d torch_tensor_from_array_int64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d torch_tensor_from_array_int64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d torch_tensor_from_array_int8_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d torch_tensor_from_array_int8_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d torch_tensor_from_array_int8_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d torch_tensor_from_array_int8_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d torch_tensor_from_array_int8_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d torch_tensor_from_array_real32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d torch_tensor_from_array_real32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d torch_tensor_from_array_real32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d proc~torch_tensor_from_array_real32_4d torch_tensor_from_array_real32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d torch_tensor_from_array_real32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d torch_tensor_from_array_real64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d torch_tensor_from_array_real64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d torch_tensor_from_array_real64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d torch_tensor_from_array_real64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d torch_tensor_from_array_real64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_real32_3d_default_layout~~CalledByGraph proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_real32_3d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : real32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real32 ), intent ( in ), target :: data_in (:,:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 3 ) !! Order of indices integer ( c_int ), parameter :: ndims = 3 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_real32_3d_default_layout","tags":"","url":"proc/torch_tensor_from_array_real32_3d_default_layout.html"},{"title":"torch_tensor_from_array_real32_4d – FTorch","text":"public  subroutine torch_tensor_from_array_real32_4d(tensor, data_in, layout, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_real32_4d~~UsesGraph proc~torch_tensor_from_array_real32_4d torch_tensor_from_array_real32_4d iso_c_binding iso_c_binding proc~torch_tensor_from_array_real32_4d->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_real32_4d->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 4 containing data of type real32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (4) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_real32_4d~~CallsGraph proc~torch_tensor_from_array_real32_4d torch_tensor_from_array_real32_4d proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_real32_4d->proc~torch_tensor_from_blob interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_real32_4d~~CalledByGraph proc~torch_tensor_from_array_real32_4d torch_tensor_from_array_real32_4d interface~torch_tensor_from_array torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_real32_4d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : real32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real32 ), intent ( in ), target :: data_in (:,:,:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 4 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 4 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kFloat32 !! Data type integer ( c_int ), parameter :: ndims = 4 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_real32_4d","tags":"","url":"proc/torch_tensor_from_array_real32_4d.html"},{"title":"torch_tensor_from_array_real32_4d_default_layout – FTorch","text":"public  subroutine torch_tensor_from_array_real32_4d_default_layout(tensor, data_in, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_real32_4d_default_layout~~UsesGraph proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout iso_c_binding iso_c_binding proc~torch_tensor_from_array_real32_4d_default_layout->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_real32_4d_default_layout->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 4 containing data of type real32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_real32_4d_default_layout~~CallsGraph proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_int16_1d torch_tensor_from_array_int16_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d torch_tensor_from_array_int16_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d torch_tensor_from_array_int16_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d torch_tensor_from_array_int16_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d torch_tensor_from_array_int16_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d torch_tensor_from_array_int32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d torch_tensor_from_array_int32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d torch_tensor_from_array_int32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d torch_tensor_from_array_int32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d torch_tensor_from_array_int32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d torch_tensor_from_array_int64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d torch_tensor_from_array_int64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d torch_tensor_from_array_int64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d torch_tensor_from_array_int64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d torch_tensor_from_array_int64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d torch_tensor_from_array_int8_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d torch_tensor_from_array_int8_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d torch_tensor_from_array_int8_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d torch_tensor_from_array_int8_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d torch_tensor_from_array_int8_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d torch_tensor_from_array_real32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d torch_tensor_from_array_real32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d torch_tensor_from_array_real32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d torch_tensor_from_array_real32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d proc~torch_tensor_from_array_real32_5d torch_tensor_from_array_real32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d torch_tensor_from_array_real64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d torch_tensor_from_array_real64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d torch_tensor_from_array_real64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d torch_tensor_from_array_real64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d torch_tensor_from_array_real64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_real32_4d_default_layout~~CalledByGraph proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_real32_4d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : real32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real32 ), intent ( in ), target :: data_in (:,:,:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 4 ) !! Order of indices integer ( c_int ), parameter :: ndims = 4 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_real32_4d_default_layout","tags":"","url":"proc/torch_tensor_from_array_real32_4d_default_layout.html"},{"title":"torch_tensor_from_array_real32_5d – FTorch","text":"public  subroutine torch_tensor_from_array_real32_5d(tensor, data_in, layout, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_real32_5d~~UsesGraph proc~torch_tensor_from_array_real32_5d torch_tensor_from_array_real32_5d iso_c_binding iso_c_binding proc~torch_tensor_from_array_real32_5d->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_real32_5d->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 5 containing data of type real32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (5) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_real32_5d~~CallsGraph proc~torch_tensor_from_array_real32_5d torch_tensor_from_array_real32_5d proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_real32_5d->proc~torch_tensor_from_blob interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_real32_5d~~CalledByGraph proc~torch_tensor_from_array_real32_5d torch_tensor_from_array_real32_5d interface~torch_tensor_from_array torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_real32_5d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : real32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real32 ), intent ( in ), target :: data_in (:,:,:,:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 5 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 5 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kFloat32 !! Data type integer ( c_int ), parameter :: ndims = 5 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_real32_5d","tags":"","url":"proc/torch_tensor_from_array_real32_5d.html"},{"title":"torch_tensor_from_array_real32_5d_default_layout – FTorch","text":"public  subroutine torch_tensor_from_array_real32_5d_default_layout(tensor, data_in, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_real32_5d_default_layout~~UsesGraph proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout iso_c_binding iso_c_binding proc~torch_tensor_from_array_real32_5d_default_layout->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_real32_5d_default_layout->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 5 containing data of type real32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_real32_5d_default_layout~~CallsGraph proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_int16_1d torch_tensor_from_array_int16_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d torch_tensor_from_array_int16_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d torch_tensor_from_array_int16_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d torch_tensor_from_array_int16_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d torch_tensor_from_array_int16_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d torch_tensor_from_array_int32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d torch_tensor_from_array_int32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d torch_tensor_from_array_int32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d torch_tensor_from_array_int32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d torch_tensor_from_array_int32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d torch_tensor_from_array_int64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d torch_tensor_from_array_int64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d torch_tensor_from_array_int64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d torch_tensor_from_array_int64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d torch_tensor_from_array_int64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d torch_tensor_from_array_int8_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d torch_tensor_from_array_int8_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d torch_tensor_from_array_int8_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d torch_tensor_from_array_int8_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d torch_tensor_from_array_int8_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d torch_tensor_from_array_real32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d torch_tensor_from_array_real32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d torch_tensor_from_array_real32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d torch_tensor_from_array_real32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d torch_tensor_from_array_real32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d proc~torch_tensor_from_array_real64_1d torch_tensor_from_array_real64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d torch_tensor_from_array_real64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d torch_tensor_from_array_real64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d torch_tensor_from_array_real64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d torch_tensor_from_array_real64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_real32_5d_default_layout~~CalledByGraph proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_real32_5d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : real32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real32 ), intent ( in ), target :: data_in (:,:,:,:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 5 ) !! Order of indices integer ( c_int ), parameter :: ndims = 5 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_real32_5d_default_layout","tags":"","url":"proc/torch_tensor_from_array_real32_5d_default_layout.html"},{"title":"torch_tensor_from_array_real64_1d – FTorch","text":"public  subroutine torch_tensor_from_array_real64_1d(tensor, data_in, layout, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_real64_1d~~UsesGraph proc~torch_tensor_from_array_real64_1d torch_tensor_from_array_real64_1d iso_c_binding iso_c_binding proc~torch_tensor_from_array_real64_1d->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_real64_1d->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 1 containing data of type real64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (1) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_real64_1d~~CallsGraph proc~torch_tensor_from_array_real64_1d torch_tensor_from_array_real64_1d proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_real64_1d->proc~torch_tensor_from_blob interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_real64_1d~~CalledByGraph proc~torch_tensor_from_array_real64_1d torch_tensor_from_array_real64_1d interface~torch_tensor_from_array torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_real64_1d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : real64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real64 ), intent ( in ), target :: data_in (:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 1 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 1 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kFloat64 !! Data type integer ( c_int ), parameter :: ndims = 1 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_real64_1d","tags":"","url":"proc/torch_tensor_from_array_real64_1d.html"},{"title":"torch_tensor_from_array_real64_1d_default_layout – FTorch","text":"public  subroutine torch_tensor_from_array_real64_1d_default_layout(tensor, data_in, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_real64_1d_default_layout~~UsesGraph proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout iso_c_binding iso_c_binding proc~torch_tensor_from_array_real64_1d_default_layout->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_real64_1d_default_layout->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 1 containing data of type real64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_real64_1d_default_layout~~CallsGraph proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_int16_1d torch_tensor_from_array_int16_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d torch_tensor_from_array_int16_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d torch_tensor_from_array_int16_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d torch_tensor_from_array_int16_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d torch_tensor_from_array_int16_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d torch_tensor_from_array_int32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d torch_tensor_from_array_int32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d torch_tensor_from_array_int32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d torch_tensor_from_array_int32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d torch_tensor_from_array_int32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d torch_tensor_from_array_int64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d torch_tensor_from_array_int64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d torch_tensor_from_array_int64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d torch_tensor_from_array_int64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d torch_tensor_from_array_int64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d torch_tensor_from_array_int8_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d torch_tensor_from_array_int8_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d torch_tensor_from_array_int8_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d torch_tensor_from_array_int8_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d torch_tensor_from_array_int8_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d torch_tensor_from_array_real32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d torch_tensor_from_array_real32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d torch_tensor_from_array_real32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d torch_tensor_from_array_real32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d torch_tensor_from_array_real32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d torch_tensor_from_array_real64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d proc~torch_tensor_from_array_real64_2d torch_tensor_from_array_real64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d torch_tensor_from_array_real64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d torch_tensor_from_array_real64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d torch_tensor_from_array_real64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_real64_1d_default_layout~~CalledByGraph proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_real64_1d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : real64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real64 ), intent ( in ), target :: data_in (:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 1 ) !! Order of indices integer ( c_int ), parameter :: ndims = 1 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_real64_1d_default_layout","tags":"","url":"proc/torch_tensor_from_array_real64_1d_default_layout.html"},{"title":"torch_tensor_from_array_real64_2d – FTorch","text":"public  subroutine torch_tensor_from_array_real64_2d(tensor, data_in, layout, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_real64_2d~~UsesGraph proc~torch_tensor_from_array_real64_2d torch_tensor_from_array_real64_2d iso_c_binding iso_c_binding proc~torch_tensor_from_array_real64_2d->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_real64_2d->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 2 containing data of type real64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (2) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_real64_2d~~CallsGraph proc~torch_tensor_from_array_real64_2d torch_tensor_from_array_real64_2d proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_real64_2d->proc~torch_tensor_from_blob interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_real64_2d~~CalledByGraph proc~torch_tensor_from_array_real64_2d torch_tensor_from_array_real64_2d interface~torch_tensor_from_array torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_real64_2d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : real64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real64 ), intent ( in ), target :: data_in (:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 2 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 2 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kFloat64 !! Data type integer ( c_int ), parameter :: ndims = 2 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_real64_2d","tags":"","url":"proc/torch_tensor_from_array_real64_2d.html"},{"title":"torch_tensor_from_array_real64_2d_default_layout – FTorch","text":"public  subroutine torch_tensor_from_array_real64_2d_default_layout(tensor, data_in, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_real64_2d_default_layout~~UsesGraph proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout iso_c_binding iso_c_binding proc~torch_tensor_from_array_real64_2d_default_layout->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_real64_2d_default_layout->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 2 containing data of type real64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_real64_2d_default_layout~~CallsGraph proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_int16_1d torch_tensor_from_array_int16_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d torch_tensor_from_array_int16_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d torch_tensor_from_array_int16_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d torch_tensor_from_array_int16_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d torch_tensor_from_array_int16_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d torch_tensor_from_array_int32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d torch_tensor_from_array_int32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d torch_tensor_from_array_int32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d torch_tensor_from_array_int32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d torch_tensor_from_array_int32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d torch_tensor_from_array_int64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d torch_tensor_from_array_int64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d torch_tensor_from_array_int64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d torch_tensor_from_array_int64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d torch_tensor_from_array_int64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d torch_tensor_from_array_int8_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d torch_tensor_from_array_int8_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d torch_tensor_from_array_int8_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d torch_tensor_from_array_int8_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d torch_tensor_from_array_int8_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d torch_tensor_from_array_real32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d torch_tensor_from_array_real32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d torch_tensor_from_array_real32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d torch_tensor_from_array_real32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d torch_tensor_from_array_real32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d torch_tensor_from_array_real64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d torch_tensor_from_array_real64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d proc~torch_tensor_from_array_real64_3d torch_tensor_from_array_real64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d torch_tensor_from_array_real64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d torch_tensor_from_array_real64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_real64_2d_default_layout~~CalledByGraph proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_real64_2d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : real64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real64 ), intent ( in ), target :: data_in (:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 2 ) !! Order of indices integer ( c_int ), parameter :: ndims = 2 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_real64_2d_default_layout","tags":"","url":"proc/torch_tensor_from_array_real64_2d_default_layout.html"},{"title":"torch_tensor_from_array_real64_3d – FTorch","text":"public  subroutine torch_tensor_from_array_real64_3d(tensor, data_in, layout, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_real64_3d~~UsesGraph proc~torch_tensor_from_array_real64_3d torch_tensor_from_array_real64_3d iso_c_binding iso_c_binding proc~torch_tensor_from_array_real64_3d->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_real64_3d->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 3 containing data of type real64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (3) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_real64_3d~~CallsGraph proc~torch_tensor_from_array_real64_3d torch_tensor_from_array_real64_3d proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_real64_3d->proc~torch_tensor_from_blob interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_real64_3d~~CalledByGraph proc~torch_tensor_from_array_real64_3d torch_tensor_from_array_real64_3d interface~torch_tensor_from_array torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_real64_3d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : real64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real64 ), intent ( in ), target :: data_in (:,:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 3 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 3 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kFloat64 !! Data type integer ( c_int ), parameter :: ndims = 3 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_real64_3d","tags":"","url":"proc/torch_tensor_from_array_real64_3d.html"},{"title":"torch_tensor_from_array_real64_3d_default_layout – FTorch","text":"public  subroutine torch_tensor_from_array_real64_3d_default_layout(tensor, data_in, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_real64_3d_default_layout~~UsesGraph proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout iso_c_binding iso_c_binding proc~torch_tensor_from_array_real64_3d_default_layout->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_real64_3d_default_layout->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 3 containing data of type real64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_real64_3d_default_layout~~CallsGraph proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_int16_1d torch_tensor_from_array_int16_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d torch_tensor_from_array_int16_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d torch_tensor_from_array_int16_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d torch_tensor_from_array_int16_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d torch_tensor_from_array_int16_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d torch_tensor_from_array_int32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d torch_tensor_from_array_int32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d torch_tensor_from_array_int32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d torch_tensor_from_array_int32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d torch_tensor_from_array_int32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d torch_tensor_from_array_int64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d torch_tensor_from_array_int64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d torch_tensor_from_array_int64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d torch_tensor_from_array_int64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d torch_tensor_from_array_int64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d torch_tensor_from_array_int8_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d torch_tensor_from_array_int8_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d torch_tensor_from_array_int8_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d torch_tensor_from_array_int8_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d torch_tensor_from_array_int8_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d torch_tensor_from_array_real32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d torch_tensor_from_array_real32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d torch_tensor_from_array_real32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d torch_tensor_from_array_real32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d torch_tensor_from_array_real32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d torch_tensor_from_array_real64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d torch_tensor_from_array_real64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d torch_tensor_from_array_real64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d proc~torch_tensor_from_array_real64_4d torch_tensor_from_array_real64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d torch_tensor_from_array_real64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_real64_3d_default_layout~~CalledByGraph proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_real64_3d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : real64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real64 ), intent ( in ), target :: data_in (:,:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 3 ) !! Order of indices integer ( c_int ), parameter :: ndims = 3 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_real64_3d_default_layout","tags":"","url":"proc/torch_tensor_from_array_real64_3d_default_layout.html"},{"title":"torch_tensor_from_array_real64_4d – FTorch","text":"public  subroutine torch_tensor_from_array_real64_4d(tensor, data_in, layout, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_real64_4d~~UsesGraph proc~torch_tensor_from_array_real64_4d torch_tensor_from_array_real64_4d iso_c_binding iso_c_binding proc~torch_tensor_from_array_real64_4d->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_real64_4d->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 4 containing data of type real64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (4) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_real64_4d~~CallsGraph proc~torch_tensor_from_array_real64_4d torch_tensor_from_array_real64_4d proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_real64_4d->proc~torch_tensor_from_blob interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_real64_4d~~CalledByGraph proc~torch_tensor_from_array_real64_4d torch_tensor_from_array_real64_4d interface~torch_tensor_from_array torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_real64_4d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : real64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real64 ), intent ( in ), target :: data_in (:,:,:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 4 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 4 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kFloat64 !! Data type integer ( c_int ), parameter :: ndims = 4 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_real64_4d","tags":"","url":"proc/torch_tensor_from_array_real64_4d.html"},{"title":"torch_tensor_from_array_real64_4d_default_layout – FTorch","text":"public  subroutine torch_tensor_from_array_real64_4d_default_layout(tensor, data_in, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_real64_4d_default_layout~~UsesGraph proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout iso_c_binding iso_c_binding proc~torch_tensor_from_array_real64_4d_default_layout->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_real64_4d_default_layout->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 4 containing data of type real64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_real64_4d_default_layout~~CallsGraph proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_int16_1d torch_tensor_from_array_int16_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d torch_tensor_from_array_int16_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d torch_tensor_from_array_int16_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d torch_tensor_from_array_int16_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d torch_tensor_from_array_int16_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d torch_tensor_from_array_int32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d torch_tensor_from_array_int32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d torch_tensor_from_array_int32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d torch_tensor_from_array_int32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d torch_tensor_from_array_int32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d torch_tensor_from_array_int64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d torch_tensor_from_array_int64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d torch_tensor_from_array_int64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d torch_tensor_from_array_int64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d torch_tensor_from_array_int64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d torch_tensor_from_array_int8_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d torch_tensor_from_array_int8_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d torch_tensor_from_array_int8_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d torch_tensor_from_array_int8_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d torch_tensor_from_array_int8_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d torch_tensor_from_array_real32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d torch_tensor_from_array_real32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d torch_tensor_from_array_real32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d torch_tensor_from_array_real32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d torch_tensor_from_array_real32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d torch_tensor_from_array_real64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d torch_tensor_from_array_real64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d torch_tensor_from_array_real64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d torch_tensor_from_array_real64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d proc~torch_tensor_from_array_real64_5d torch_tensor_from_array_real64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_real64_4d_default_layout~~CalledByGraph proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_real64_4d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : real64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real64 ), intent ( in ), target :: data_in (:,:,:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 4 ) !! Order of indices integer ( c_int ), parameter :: ndims = 4 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_real64_4d_default_layout","tags":"","url":"proc/torch_tensor_from_array_real64_4d_default_layout.html"},{"title":"torch_tensor_from_array_real64_5d – FTorch","text":"public  subroutine torch_tensor_from_array_real64_5d(tensor, data_in, layout, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_real64_5d~~UsesGraph proc~torch_tensor_from_array_real64_5d torch_tensor_from_array_real64_5d iso_c_binding iso_c_binding proc~torch_tensor_from_array_real64_5d->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_real64_5d->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 5 containing data of type real64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (5) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_real64_5d~~CallsGraph proc~torch_tensor_from_array_real64_5d torch_tensor_from_array_real64_5d proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_real64_5d->proc~torch_tensor_from_blob interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_real64_5d~~CalledByGraph proc~torch_tensor_from_array_real64_5d torch_tensor_from_array_real64_5d interface~torch_tensor_from_array torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_real64_5d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : real64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real64 ), intent ( in ), target :: data_in (:,:,:,:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 5 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 5 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kFloat64 !! Data type integer ( c_int ), parameter :: ndims = 5 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_real64_5d","tags":"","url":"proc/torch_tensor_from_array_real64_5d.html"},{"title":"torch_tensor_from_array_real64_5d_default_layout – FTorch","text":"public  subroutine torch_tensor_from_array_real64_5d_default_layout(tensor, data_in, device_type, device_index, requires_grad) Uses iso_fortran_env iso_c_binding proc~~torch_tensor_from_array_real64_5d_default_layout~~UsesGraph proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout iso_c_binding iso_c_binding proc~torch_tensor_from_array_real64_5d_default_layout->iso_c_binding iso_fortran_env iso_fortran_env proc~torch_tensor_from_array_real64_5d_default_layout->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Return a Torch tensor pointing to data_in array of rank 5 containing data of type real64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_array_real64_5d_default_layout~~CallsGraph proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d torch_tensor_from_array_int16_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d torch_tensor_from_array_int16_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d torch_tensor_from_array_int16_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d torch_tensor_from_array_int16_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d torch_tensor_from_array_int16_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d torch_tensor_from_array_int32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d torch_tensor_from_array_int32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d torch_tensor_from_array_int32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d torch_tensor_from_array_int32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d torch_tensor_from_array_int32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d torch_tensor_from_array_int64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d torch_tensor_from_array_int64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d torch_tensor_from_array_int64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d torch_tensor_from_array_int64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d torch_tensor_from_array_int64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d torch_tensor_from_array_int8_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d torch_tensor_from_array_int8_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d torch_tensor_from_array_int8_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d torch_tensor_from_array_int8_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d torch_tensor_from_array_int8_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d torch_tensor_from_array_real32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d torch_tensor_from_array_real32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d torch_tensor_from_array_real32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d torch_tensor_from_array_real32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d torch_tensor_from_array_real32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d torch_tensor_from_array_real64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d torch_tensor_from_array_real64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d torch_tensor_from_array_real64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d torch_tensor_from_array_real64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d torch_tensor_from_array_real64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d->proc~torch_tensor_from_blob interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_array_real64_5d_default_layout~~CalledByGraph proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_array_real64_5d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : real64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real64 ), intent ( in ), target :: data_in (:,:,:,:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 5 ) !! Order of indices integer ( c_int ), parameter :: ndims = 5 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_real64_5d_default_layout","tags":"","url":"proc/torch_tensor_from_array_real64_5d_default_layout.html"},{"title":"torch_tensor_from_blob – FTorch","text":"public  subroutine torch_tensor_from_blob(tensor, data, ndims, tensor_shape, layout, dtype, device_type, device_index, requires_grad) Uses iso_c_binding proc~~torch_tensor_from_blob~~UsesGraph proc~torch_tensor_from_blob torch_tensor_from_blob iso_c_binding iso_c_binding proc~torch_tensor_from_blob->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Exposes the given data as a tensor without taking ownership of the original data.\n This routine will take an (i, j, k) array and return an (k, j, i) tensor. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor type(c_ptr), intent(in) :: data Pointer to data integer(kind=c_int), intent(in) :: ndims Number of dimensions of the tensor integer(kind=c_int64_t), intent(in) :: tensor_shape (:) Shape of the tensor integer(kind=c_int), intent(in) :: layout (:) Layout for strides for accessing data integer(kind=c_int), intent(in) :: dtype Data type of the tensor integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Calls proc~~torch_tensor_from_blob~~CallsGraph proc~torch_tensor_from_blob torch_tensor_from_blob interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~torch_tensor_from_blob~~CalledByGraph proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d torch_tensor_from_array_int16_1d proc~torch_tensor_from_array_int16_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_2d torch_tensor_from_array_int16_2d proc~torch_tensor_from_array_int16_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_3d torch_tensor_from_array_int16_3d proc~torch_tensor_from_array_int16_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_4d torch_tensor_from_array_int16_4d proc~torch_tensor_from_array_int16_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_5d torch_tensor_from_array_int16_5d proc~torch_tensor_from_array_int16_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_1d torch_tensor_from_array_int32_1d proc~torch_tensor_from_array_int32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_2d torch_tensor_from_array_int32_2d proc~torch_tensor_from_array_int32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_3d torch_tensor_from_array_int32_3d proc~torch_tensor_from_array_int32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_4d torch_tensor_from_array_int32_4d proc~torch_tensor_from_array_int32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_5d torch_tensor_from_array_int32_5d proc~torch_tensor_from_array_int32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_1d torch_tensor_from_array_int64_1d proc~torch_tensor_from_array_int64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_2d torch_tensor_from_array_int64_2d proc~torch_tensor_from_array_int64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_3d torch_tensor_from_array_int64_3d proc~torch_tensor_from_array_int64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_4d torch_tensor_from_array_int64_4d proc~torch_tensor_from_array_int64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_5d torch_tensor_from_array_int64_5d proc~torch_tensor_from_array_int64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_1d torch_tensor_from_array_int8_1d proc~torch_tensor_from_array_int8_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_2d torch_tensor_from_array_int8_2d proc~torch_tensor_from_array_int8_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_3d torch_tensor_from_array_int8_3d proc~torch_tensor_from_array_int8_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_4d torch_tensor_from_array_int8_4d proc~torch_tensor_from_array_int8_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_5d torch_tensor_from_array_int8_5d proc~torch_tensor_from_array_int8_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_1d torch_tensor_from_array_real32_1d proc~torch_tensor_from_array_real32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_2d torch_tensor_from_array_real32_2d proc~torch_tensor_from_array_real32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_3d torch_tensor_from_array_real32_3d proc~torch_tensor_from_array_real32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_4d torch_tensor_from_array_real32_4d proc~torch_tensor_from_array_real32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_5d torch_tensor_from_array_real32_5d proc~torch_tensor_from_array_real32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_1d torch_tensor_from_array_real64_1d proc~torch_tensor_from_array_real64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_2d torch_tensor_from_array_real64_2d proc~torch_tensor_from_array_real64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_3d torch_tensor_from_array_real64_3d proc~torch_tensor_from_array_real64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_4d torch_tensor_from_array_real64_4d proc~torch_tensor_from_array_real64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_5d torch_tensor_from_array_real64_5d proc~torch_tensor_from_array_real64_5d->proc~torch_tensor_from_blob interface~torch_tensor_from_array torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_from_blob ( tensor , data , ndims , tensor_shape , layout , dtype , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_ptr type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor type ( c_ptr ), intent ( in ) :: data !! Pointer to data integer ( c_int ), intent ( in ) :: ndims !! Number of dimensions of the tensor integer ( c_int64_t ), intent ( in ) :: tensor_shape (:) !! Shape of the tensor integer ( c_int ), intent ( in ) :: layout (:) !! Layout for strides for accessing data integer ( c_int ), intent ( in ) :: dtype !! Data type of the tensor integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor integer ( c_int ) :: i !! loop index integer ( c_int64_t ) :: strides ( ndims ) !! Strides for accessing data integer ( c_int ) :: device_index_value !! device index used logical ( c_bool ) :: requires_grad_value !! Whether gradients need to be computed for the created tensor if (. not . present ( requires_grad )) then requires_grad_value = logical (. false ., c_bool ) else requires_grad_value = requires_grad end if strides (:) = 0 do i = 1 , ndims if ( i == 1 ) then strides ( layout ( i )) = 1 else strides ( layout ( i )) = strides ( layout ( i - 1 )) * tensor_shape ( layout ( i - 1 )) end if end do ! Process optional arguments if ( present ( device_index )) then device_index_value = device_index else if ( device_type == torch_kCPU ) then device_index_value = - 1 else device_index_value = 0 endif tensor % p = torch_from_blob_c ( data , ndims , tensor_shape , strides , dtype , & device_type , device_index_value , & requires_grad_value ) end subroutine torch_tensor_from_blob","tags":"","url":"proc/torch_tensor_from_blob.html"},{"title":"torch_tensor_get_gradient – FTorch","text":"public  subroutine torch_tensor_get_gradient(gradient, tensor) Retrieves the gradient with respect to a Torch Tensor. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(inout) :: gradient Tensor holding the gradient type( torch_tensor ), intent(in) :: tensor Tensor to compute the gradient with respect to Source Code subroutine torch_tensor_get_gradient ( gradient , tensor ) type ( torch_tensor ), intent ( inout ) :: gradient !! Tensor holding the gradient type ( torch_tensor ), intent ( in ) :: tensor !! Tensor to compute the gradient with respect to interface subroutine torch_tensor_get_gradient_c ( tensor_c , gradient_c ) & bind ( c , name = 'torch_tensor_get_gradient' ) use , intrinsic :: iso_c_binding , only : c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: tensor_c type ( c_ptr ), value , intent ( in ) :: gradient_c end subroutine torch_tensor_get_gradient_c end interface if (. not . c_associated ( gradient % p )) then write ( * , * ) \"Error :: tensors for holding gradients must be constructed before retrieving values\" stop 1 end if call torch_tensor_get_gradient_c ( tensor % p , gradient % p ) end subroutine torch_tensor_get_gradient","tags":"","url":"proc/torch_tensor_get_gradient.html"},{"title":"torch_tensor_mean – FTorch","text":"public  subroutine torch_tensor_mean(output, tensor) Uses iso_c_binding proc~~torch_tensor_mean~~UsesGraph proc~torch_tensor_mean torch_tensor_mean iso_c_binding iso_c_binding proc~torch_tensor_mean->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Overloads mean operator over the values in a tensor. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(inout) :: output Tensor holding the averaged values type( torch_tensor ), intent(in) :: tensor Tensor to average the values of Source Code subroutine torch_tensor_mean ( output , tensor ) use , intrinsic :: iso_c_binding , only : c_associated type ( torch_tensor ), intent ( inout ) :: output !! Tensor holding the averaged values type ( torch_tensor ), intent ( in ) :: tensor !! Tensor to average the values of interface subroutine torch_tensor_mean_c ( output_c , tensor_c ) & bind ( c , name = 'torch_tensor_mean' ) use , intrinsic :: iso_c_binding , only : c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: output_c type ( c_ptr ), value , intent ( in ) :: tensor_c end subroutine torch_tensor_mean_c end interface if (. not . c_associated ( output % p )) then write ( * , * ) \"Error :: output tensor has not been constructed\" stop 1 end if call torch_tensor_mean_c ( output % p , tensor % p ) end subroutine torch_tensor_mean","tags":"","url":"proc/torch_tensor_mean.html"},{"title":"torch_tensor_ones – FTorch","text":"public  subroutine torch_tensor_ones(tensor, ndims, tensor_shape, dtype, device_type, device_index, requires_grad) Uses iso_c_binding proc~~torch_tensor_ones~~UsesGraph proc~torch_tensor_ones torch_tensor_ones iso_c_binding iso_c_binding proc~torch_tensor_ones->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Returns a tensor filled with the scalar value 1. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=c_int), intent(in) :: ndims Number of dimensions of the tensor integer(kind=c_int64_t), intent(in) :: tensor_shape (:) Shape of the tensor integer(kind=c_int), intent(in) :: dtype Data type of the tensor integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Called by proc~~torch_tensor_ones~~CalledByGraph proc~torch_tensor_ones torch_tensor_ones proc~torch_tensor_backward torch_tensor_backward proc~torch_tensor_backward->proc~torch_tensor_ones Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_ones ( tensor , ndims , tensor_shape , dtype , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor integer ( c_int ), intent ( in ) :: ndims !! Number of dimensions of the tensor integer ( c_int64_t ), intent ( in ) :: tensor_shape (:) !! Shape of the tensor integer ( c_int ), intent ( in ) :: dtype !! Data type of the tensor integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor integer ( c_int ) :: device_index_value !! device index used logical ( c_bool ) :: requires_grad_value !! Whether gradients need to be computed for the created tensor interface function torch_ones_c ( ndims_c , tensor_shape_c , dtype_c , & device_type_c , device_index_c , requires_grad_c ) result ( tensor_c ) & bind ( c , name = 'torch_ones' ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_ptr implicit none integer ( c_int ), value , intent ( in ) :: ndims_c integer ( c_int64_t ), intent ( in ) :: tensor_shape_c ( * ) integer ( c_int ), value , intent ( in ) :: dtype_c integer ( c_int ), value , intent ( in ) :: device_type_c integer ( c_int ), value , intent ( in ) :: device_index_c logical ( c_bool ), value , intent ( in ) :: requires_grad_c type ( c_ptr ) :: tensor_c end function torch_ones_c end interface ! Process optional arguments if ( present ( device_index )) then device_index_value = device_index else if ( device_type == torch_kCPU ) then device_index_value = - 1 else device_index_value = 0 endif if (. not . present ( requires_grad )) then requires_grad_value = logical (. false ., c_bool ) else requires_grad_value = requires_grad end if tensor % p = torch_ones_c ( ndims , tensor_shape , dtype , device_type , & device_index_value , requires_grad_value ) end subroutine torch_tensor_ones","tags":"","url":"proc/torch_tensor_ones.html"},{"title":"torch_tensor_print – FTorch","text":"public  subroutine torch_tensor_print(tensor) Prints the contents of a tensor. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor Tensor to print the contents of Source Code subroutine torch_tensor_print ( tensor ) type ( torch_tensor ), intent ( in ) :: tensor !! Tensor to print the contents of interface subroutine torch_tensor_print_c ( tensor_c ) & bind ( c , name = 'torch_tensor_print' ) use , intrinsic :: iso_c_binding , only : c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: tensor_c end subroutine torch_tensor_print_c end interface call torch_tensor_print_c ( tensor % p ) end subroutine torch_tensor_print","tags":"","url":"proc/torch_tensor_print.html"},{"title":"torch_tensor_sum – FTorch","text":"public  subroutine torch_tensor_sum(output, tensor) Uses iso_c_binding proc~~torch_tensor_sum~~UsesGraph proc~torch_tensor_sum torch_tensor_sum iso_c_binding iso_c_binding proc~torch_tensor_sum->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Overloads summation operator over the values in a tensor. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(inout) :: output Tensor holding the summed values type( torch_tensor ), intent(in) :: tensor Tensor to sum the values of Source Code subroutine torch_tensor_sum ( output , tensor ) use , intrinsic :: iso_c_binding , only : c_associated type ( torch_tensor ), intent ( inout ) :: output !! Tensor holding the summed values type ( torch_tensor ), intent ( in ) :: tensor !! Tensor to sum the values of interface subroutine torch_tensor_sum_c ( output_c , tensor_c ) & bind ( c , name = 'torch_tensor_sum' ) use , intrinsic :: iso_c_binding , only : c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: output_c type ( c_ptr ), value , intent ( in ) :: tensor_c end subroutine torch_tensor_sum_c end interface if (. not . c_associated ( output % p )) then write ( * , * ) \"Error :: output tensor has not been constructed\" stop 1 end if call torch_tensor_sum_c ( output % p , tensor % p ) end subroutine torch_tensor_sum","tags":"","url":"proc/torch_tensor_sum.html"},{"title":"torch_tensor_to – FTorch","text":"public  subroutine torch_tensor_to(source_tensor, target_tensor, non_blocking) Uses iso_c_binding proc~~torch_tensor_to~~UsesGraph proc~torch_tensor_to torch_tensor_to iso_c_binding iso_c_binding proc~torch_tensor_to->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Moves a source_tensor tensor to a target tensor's device and dtype Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: source_tensor Source tensor to be moved type( torch_tensor ), intent(inout) :: target_tensor Target tensor with the desired device and dtype logical, intent(in), optional :: non_blocking Whether to perform asynchronous copy Calls proc~~torch_tensor_to~~CallsGraph proc~torch_tensor_to torch_tensor_to proc~torch_tensor_get_rank torch_tensor%torch_tensor_get_rank proc~torch_tensor_to->proc~torch_tensor_get_rank proc~torch_tensor_get_shape torch_tensor%torch_tensor_get_shape proc~torch_tensor_to->proc~torch_tensor_get_shape proc~torch_tensor_get_shape->proc~torch_tensor_get_rank Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine torch_tensor_to ( source_tensor , target_tensor , non_blocking ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t type ( torch_tensor ), intent ( in ) :: source_tensor !! Source tensor to be moved type ( torch_tensor ), intent ( inout ) :: target_tensor !! Target tensor with the desired device and dtype logical , optional , intent ( in ) :: non_blocking !! Whether to perform asynchronous copy logical ( c_bool ) :: non_blocking_value integer ( c_int ) :: source_rank , target_rank , i integer ( c_int64_t ), pointer :: source_shape (:), target_shape (:) interface subroutine torch_tensor_to_c ( source_tensor_c , target_tensor_c , non_blocking_c ) & bind ( c , name = 'torch_tensor_to' ) use , intrinsic :: iso_c_binding , only : c_bool , c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: source_tensor_c type ( c_ptr ), value , intent ( in ) :: target_tensor_c logical ( c_bool ), value , intent ( in ) :: non_blocking_c end subroutine torch_tensor_to_c end interface ! Check for rank and shape consistency between the source and target tensors source_rank = source_tensor % get_rank () target_rank = target_tensor % get_rank () if ( source_rank /= target_rank ) then write ( * , * ) \"Error in torch_tensor_to :: Cannot move source_tensor to target_tensor because the ranks do not match.\" write ( * , * ) \"Source tensor rank:\" , source_rank , \"Target tensor rank:\" , target_rank stop 1 end if source_shape => source_tensor % get_shape () target_shape => target_tensor % get_shape () do i = 1 , source_rank if ( source_shape ( i ) /= target_shape ( i )) then write ( * , * ) \"Error in torch_tensor_to :: Cannot move source_tensor to target_tensor because the shapes do not match.\" write ( * , * ) \"Dimension\" , i , \"mismatch: source_tensor =\" , source_shape ( i ), & \"Target =\" , target_shape ( i ) stop 1 end if end do ! Process optional arguments if ( present ( non_blocking )) then non_blocking_value = non_blocking else non_blocking_value = . false . end if call torch_tensor_to_c ( source_tensor % p , target_tensor % p , non_blocking_value ) end subroutine torch_tensor_to","tags":"","url":"proc/torch_tensor_to.html"},{"title":"torch_tensor_zero – FTorch","text":"public  subroutine torch_tensor_zero(tensor) Uses iso_c_binding proc~~torch_tensor_zero~~UsesGraph proc~torch_tensor_zero torch_tensor%torch_tensor_zero iso_c_binding iso_c_binding proc~torch_tensor_zero->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Fills a tensor with the scalar value 0. Type Bound torch_tensor Arguments Type Intent Optional Attributes Name class( torch_tensor ), intent(inout) :: tensor Tensor whose values are to be zeroed Source Code subroutine torch_tensor_zero ( tensor ) use , intrinsic :: iso_c_binding , only : c_associated class ( torch_tensor ), intent ( inout ) :: tensor !! Tensor whose values are to be zeroed interface subroutine torch_tensor_zero_c ( tensor_c ) bind ( c , name = 'torch_tensor_zero' ) use , intrinsic :: iso_c_binding , only : c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: tensor_c end subroutine torch_tensor_zero_c end interface if (. not . c_associated ( tensor % p )) then write ( * , * ) \"Error :: tensor must be constructed before zeroing values\" stop 1 end if call torch_tensor_zero_c ( tensor % p ) end subroutine torch_tensor_zero","tags":"","url":"proc/torch_tensor_zero.html"},{"title":"torch_tensor_zero_grad – FTorch","text":"public  subroutine torch_tensor_zero_grad(tensor) Uses iso_c_binding proc~~torch_tensor_zero_grad~~UsesGraph proc~torch_tensor_zero_grad torch_tensor%torch_tensor_zero_grad iso_c_binding iso_c_binding proc~torch_tensor_zero_grad->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Resets a tensor's gradient to zero. Type Bound torch_tensor Arguments Type Intent Optional Attributes Name class( torch_tensor ), intent(inout) :: tensor Tensor to zero the gradient of Source Code subroutine torch_tensor_zero_grad ( tensor ) use , intrinsic :: iso_c_binding , only : c_associated class ( torch_tensor ), intent ( inout ) :: tensor !! Tensor to zero the gradient of interface subroutine torch_tensor_zero_grad_c ( tensor_c ) bind ( c , name = 'torch_tensor_zero_grad' ) use , intrinsic :: iso_c_binding , only : c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: tensor_c end subroutine torch_tensor_zero_grad_c end interface ! TODO: Call torch_tensor_get_gradient to check it exists? call torch_tensor_zero_grad_c ( tensor % p ) end subroutine torch_tensor_zero_grad","tags":"","url":"proc/torch_tensor_zero_grad.html"},{"title":"torch_tensor_zeros – FTorch","text":"public  subroutine torch_tensor_zeros(tensor, ndims, tensor_shape, dtype, device_type, device_index, requires_grad) Uses iso_c_binding proc~~torch_tensor_zeros~~UsesGraph proc~torch_tensor_zeros torch_tensor_zeros iso_c_binding iso_c_binding proc~torch_tensor_zeros->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Returns a tensor filled with the scalar value 0. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=c_int), intent(in) :: ndims Number of dimensions of the tensor integer(kind=c_int64_t), intent(in) :: tensor_shape (:) Shape of the tensor integer(kind=c_int), intent(in) :: dtype Data type of the tensor integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor Source Code subroutine torch_tensor_zeros ( tensor , ndims , tensor_shape , dtype , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor integer ( c_int ), intent ( in ) :: ndims !! Number of dimensions of the tensor integer ( c_int64_t ), intent ( in ) :: tensor_shape (:) !! Shape of the tensor integer ( c_int ), intent ( in ) :: dtype !! Data type of the tensor integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor integer ( c_int ) :: device_index_value !! device index used logical ( c_bool ) :: requires_grad_value !! Whether gradients need to be computed for the created tensor interface function torch_zeros_c ( ndims_c , tensor_shape_c , dtype_c , & device_type_c , device_index_c , requires_grad_c ) result ( tensor_c ) & bind ( c , name = 'torch_zeros' ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_ptr implicit none integer ( c_int ), value , intent ( in ) :: ndims_c integer ( c_int64_t ), intent ( in ) :: tensor_shape_c ( * ) integer ( c_int ), value , intent ( in ) :: dtype_c integer ( c_int ), value , intent ( in ) :: device_type_c integer ( c_int ), value , intent ( in ) :: device_index_c logical ( c_bool ), value , intent ( in ) :: requires_grad_c type ( c_ptr ) :: tensor_c end function torch_zeros_c end interface ! Process optional arguments if ( present ( device_index )) then device_index_value = device_index else if ( device_type == torch_kCPU ) then device_index_value = - 1 else device_index_value = 0 endif if (. not . present ( requires_grad )) then requires_grad_value = logical (. false ., c_bool ) else requires_grad_value = requires_grad end if tensor % p = torch_zeros_c ( ndims , tensor_shape , dtype , device_type , & device_index_value , requires_grad_value ) end subroutine torch_tensor_zeros","tags":"","url":"proc/torch_tensor_zeros.html"},{"title":"assignment (=) – FTorch","text":"public interface assignment (=) Calls interface~~assignment (=)~~CallsGraph interface~assignment (=) assignment (=) proc~torch_tensor_assign torch_tensor_assign interface~assignment (=)->proc~torch_tensor_assign proc~torch_tensor_empty torch_tensor_empty proc~torch_tensor_assign->proc~torch_tensor_empty proc~torch_tensor_get_device_index torch_tensor%torch_tensor_get_device_index proc~torch_tensor_assign->proc~torch_tensor_get_device_index proc~torch_tensor_get_device_type torch_tensor%torch_tensor_get_device_type proc~torch_tensor_assign->proc~torch_tensor_get_device_type proc~torch_tensor_get_dtype torch_tensor%torch_tensor_get_dtype proc~torch_tensor_assign->proc~torch_tensor_get_dtype proc~torch_tensor_get_rank torch_tensor%torch_tensor_get_rank proc~torch_tensor_assign->proc~torch_tensor_get_rank proc~torch_tensor_get_shape torch_tensor%torch_tensor_get_shape proc~torch_tensor_assign->proc~torch_tensor_get_shape proc~torch_tensor_requires_grad torch_tensor%torch_tensor_requires_grad proc~torch_tensor_assign->proc~torch_tensor_requires_grad proc~torch_tensor_get_shape->proc~torch_tensor_get_rank Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public  subroutine torch_tensor_assign (output, input) Overloads assignment operator for tensors. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(inout) :: output Tensor to assign values to type( torch_tensor ), intent(in) :: input Tensor whose values are to be used","tags":"","url":"interface/assignment (=).html"},{"title":"operator (*) – FTorch","text":"public interface operator (*) Calls interface~~operator (ASTERISK)~~CallsGraph interface~operator (ASTERISK) operator (*) proc~torch_tensor_multiply torch_tensor_multiply interface~operator (ASTERISK)->proc~torch_tensor_multiply interface~torch_tensor_multiply_c torch_tensor_multiply_c proc~torch_tensor_multiply->interface~torch_tensor_multiply_c proc~torch_tensor_empty torch_tensor_empty proc~torch_tensor_multiply->proc~torch_tensor_empty proc~torch_tensor_get_device_index torch_tensor%torch_tensor_get_device_index proc~torch_tensor_multiply->proc~torch_tensor_get_device_index proc~torch_tensor_get_device_type torch_tensor%torch_tensor_get_device_type proc~torch_tensor_multiply->proc~torch_tensor_get_device_type proc~torch_tensor_get_dtype torch_tensor%torch_tensor_get_dtype proc~torch_tensor_multiply->proc~torch_tensor_get_dtype proc~torch_tensor_get_rank torch_tensor%torch_tensor_get_rank proc~torch_tensor_multiply->proc~torch_tensor_get_rank proc~torch_tensor_get_shape torch_tensor%torch_tensor_get_shape proc~torch_tensor_multiply->proc~torch_tensor_get_shape proc~torch_tensor_requires_grad torch_tensor%torch_tensor_requires_grad proc~torch_tensor_multiply->proc~torch_tensor_requires_grad proc~torch_tensor_get_shape->proc~torch_tensor_get_rank Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public  function torch_tensor_multiply (tensor1, tensor2) result(output) Overloads multiplication operator for two tensors. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor1 First tensor to be multiplied type( torch_tensor ), intent(in) :: tensor2 Second tensor to be multiplied Return Value type( torch_tensor ) Tensor to hold the product","tags":"","url":"interface/operator (ASTERISK).html"},{"title":"operator (**) – FTorch","text":"public interface operator (**) Calls interface~~operator (ASTERISKASTERISK)~~CallsGraph interface~operator (ASTERISKASTERISK) operator (**) proc~torch_tensor_power_int16 torch_tensor_power_int16 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_int16 proc~torch_tensor_power_int32 torch_tensor_power_int32 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_int32 proc~torch_tensor_power_int64 torch_tensor_power_int64 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_int64 proc~torch_tensor_power_int8 torch_tensor_power_int8 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_int8 proc~torch_tensor_power_real32 torch_tensor_power_real32 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_real32 proc~torch_tensor_power_real64 torch_tensor_power_real64 interface~operator (ASTERISKASTERISK)->proc~torch_tensor_power_real64 proc~torch_tensor_empty torch_tensor_empty proc~torch_tensor_power_int16->proc~torch_tensor_empty proc~torch_tensor_get_device_index torch_tensor%torch_tensor_get_device_index proc~torch_tensor_power_int16->proc~torch_tensor_get_device_index proc~torch_tensor_get_device_type torch_tensor%torch_tensor_get_device_type proc~torch_tensor_power_int16->proc~torch_tensor_get_device_type proc~torch_tensor_get_dtype torch_tensor%torch_tensor_get_dtype proc~torch_tensor_power_int16->proc~torch_tensor_get_dtype proc~torch_tensor_get_rank torch_tensor%torch_tensor_get_rank proc~torch_tensor_power_int16->proc~torch_tensor_get_rank proc~torch_tensor_get_shape torch_tensor%torch_tensor_get_shape proc~torch_tensor_power_int16->proc~torch_tensor_get_shape proc~torch_tensor_requires_grad torch_tensor%torch_tensor_requires_grad proc~torch_tensor_power_int16->proc~torch_tensor_requires_grad proc~torch_tensor_power_int32->proc~torch_tensor_empty proc~torch_tensor_power_int32->proc~torch_tensor_get_device_index proc~torch_tensor_power_int32->proc~torch_tensor_get_device_type proc~torch_tensor_power_int32->proc~torch_tensor_get_dtype proc~torch_tensor_power_int32->proc~torch_tensor_get_rank proc~torch_tensor_power_int32->proc~torch_tensor_get_shape proc~torch_tensor_power_int32->proc~torch_tensor_requires_grad proc~torch_tensor_power_int64->proc~torch_tensor_empty proc~torch_tensor_power_int64->proc~torch_tensor_get_device_index proc~torch_tensor_power_int64->proc~torch_tensor_get_device_type proc~torch_tensor_power_int64->proc~torch_tensor_get_dtype proc~torch_tensor_power_int64->proc~torch_tensor_get_rank proc~torch_tensor_power_int64->proc~torch_tensor_get_shape proc~torch_tensor_power_int64->proc~torch_tensor_requires_grad proc~torch_tensor_power_int8->proc~torch_tensor_empty proc~torch_tensor_power_int8->proc~torch_tensor_get_device_index proc~torch_tensor_power_int8->proc~torch_tensor_get_device_type proc~torch_tensor_power_int8->proc~torch_tensor_get_dtype proc~torch_tensor_power_int8->proc~torch_tensor_get_rank proc~torch_tensor_power_int8->proc~torch_tensor_get_shape proc~torch_tensor_power_int8->proc~torch_tensor_requires_grad proc~torch_tensor_power_real32->proc~torch_tensor_empty proc~torch_tensor_power_real32->proc~torch_tensor_get_device_index proc~torch_tensor_power_real32->proc~torch_tensor_get_device_type proc~torch_tensor_power_real32->proc~torch_tensor_get_dtype proc~torch_tensor_power_real32->proc~torch_tensor_get_rank proc~torch_tensor_power_real32->proc~torch_tensor_get_shape proc~torch_tensor_power_real32->proc~torch_tensor_requires_grad proc~torch_tensor_power_real64->proc~torch_tensor_empty proc~torch_tensor_power_real64->proc~torch_tensor_get_device_index proc~torch_tensor_power_real64->proc~torch_tensor_get_device_type proc~torch_tensor_power_real64->proc~torch_tensor_get_dtype proc~torch_tensor_power_real64->proc~torch_tensor_get_rank proc~torch_tensor_power_real64->proc~torch_tensor_get_shape proc~torch_tensor_power_real64->proc~torch_tensor_requires_grad proc~torch_tensor_get_shape->proc~torch_tensor_get_rank Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public  function torch_tensor_power_int8 (tensor, power) result(output) Overloads exponentiation operator for a tensor and a scalar of type int8 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor Tensor to take the power of integer(kind=int8), intent(in), target :: power Integer exponent Return Value type( torch_tensor ) Tensor to hold the exponentiation public  function torch_tensor_power_int16 (tensor, power) result(output) Overloads exponentiation operator for a tensor and a scalar of type int16 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor Tensor to take the power of integer(kind=int16), intent(in), target :: power Integer exponent Return Value type( torch_tensor ) Tensor to hold the exponentiation public  function torch_tensor_power_int32 (tensor, power) result(output) Overloads exponentiation operator for a tensor and a scalar of type int32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor Tensor to take the power of integer(kind=int32), intent(in), target :: power Integer exponent Return Value type( torch_tensor ) Tensor to hold the exponentiation public  function torch_tensor_power_int64 (tensor, power) result(output) Overloads exponentiation operator for a tensor and a scalar of type int64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor Tensor to take the power of integer(kind=int64), intent(in), target :: power Integer exponent Return Value type( torch_tensor ) Tensor to hold the exponentiation public  function torch_tensor_power_real32 (tensor, power) result(output) Overloads exponentiation operator for a tensor and a scalar of type real32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor Tensor to take the power of real(kind=real32), intent(in), target :: power Floating point exponent Return Value type( torch_tensor ) Tensor to hold the exponentiation public  function torch_tensor_power_real64 (tensor, power) result(output) Overloads exponentiation operator for a tensor and a scalar of type real64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor Tensor to take the power of real(kind=real64), intent(in), target :: power Floating point exponent Return Value type( torch_tensor ) Tensor to hold the exponentiation","tags":"","url":"interface/operator (ASTERISKASTERISK).html"},{"title":"operator (+) – FTorch","text":"public interface operator (+) Calls interface~~operator (+)~~CallsGraph interface~operator (+) operator (+) proc~torch_tensor_add torch_tensor_add interface~operator (+)->proc~torch_tensor_add proc~torch_tensor_empty torch_tensor_empty proc~torch_tensor_add->proc~torch_tensor_empty proc~torch_tensor_get_device_index torch_tensor%torch_tensor_get_device_index proc~torch_tensor_add->proc~torch_tensor_get_device_index proc~torch_tensor_get_device_type torch_tensor%torch_tensor_get_device_type proc~torch_tensor_add->proc~torch_tensor_get_device_type proc~torch_tensor_get_dtype torch_tensor%torch_tensor_get_dtype proc~torch_tensor_add->proc~torch_tensor_get_dtype proc~torch_tensor_get_rank torch_tensor%torch_tensor_get_rank proc~torch_tensor_add->proc~torch_tensor_get_rank proc~torch_tensor_get_shape torch_tensor%torch_tensor_get_shape proc~torch_tensor_add->proc~torch_tensor_get_shape proc~torch_tensor_requires_grad torch_tensor%torch_tensor_requires_grad proc~torch_tensor_add->proc~torch_tensor_requires_grad proc~torch_tensor_get_shape->proc~torch_tensor_get_rank Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public  function torch_tensor_add (tensor1, tensor2) result(output) Overloads addition operator for two tensors. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor1 First tensor to be added type( torch_tensor ), intent(in) :: tensor2 Second tensor to be added Return Value type( torch_tensor ) Tensor to hold the sum","tags":"","url":"interface/operator (+).html"},{"title":"operator (-) – FTorch","text":"public interface operator (-) Calls interface~~operator (-)~~CallsGraph interface~operator (-) operator (-) proc~torch_tensor_negative torch_tensor_negative interface~operator (-)->proc~torch_tensor_negative proc~torch_tensor_subtract torch_tensor_subtract interface~operator (-)->proc~torch_tensor_subtract proc~torch_tensor_empty torch_tensor_empty proc~torch_tensor_negative->proc~torch_tensor_empty proc~torch_tensor_get_device_index torch_tensor%torch_tensor_get_device_index proc~torch_tensor_negative->proc~torch_tensor_get_device_index proc~torch_tensor_get_device_type torch_tensor%torch_tensor_get_device_type proc~torch_tensor_negative->proc~torch_tensor_get_device_type proc~torch_tensor_get_dtype torch_tensor%torch_tensor_get_dtype proc~torch_tensor_negative->proc~torch_tensor_get_dtype proc~torch_tensor_get_rank torch_tensor%torch_tensor_get_rank proc~torch_tensor_negative->proc~torch_tensor_get_rank proc~torch_tensor_get_shape torch_tensor%torch_tensor_get_shape proc~torch_tensor_negative->proc~torch_tensor_get_shape proc~torch_tensor_requires_grad torch_tensor%torch_tensor_requires_grad proc~torch_tensor_negative->proc~torch_tensor_requires_grad proc~torch_tensor_subtract->proc~torch_tensor_empty proc~torch_tensor_subtract->proc~torch_tensor_get_device_index proc~torch_tensor_subtract->proc~torch_tensor_get_device_type proc~torch_tensor_subtract->proc~torch_tensor_get_dtype proc~torch_tensor_subtract->proc~torch_tensor_get_rank proc~torch_tensor_subtract->proc~torch_tensor_get_shape proc~torch_tensor_subtract->proc~torch_tensor_requires_grad proc~torch_tensor_get_shape->proc~torch_tensor_get_rank Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public  function torch_tensor_negative (tensor) result(output) Overloads negative operator for a single tensor. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor Tensor to take the negative of Return Value type( torch_tensor ) Tensor to hold the negative values public  function torch_tensor_subtract (tensor1, tensor2) result(output) Overloads subtraction operator for two tensors. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor1 First tensor for the subtraction type( torch_tensor ), intent(in) :: tensor2 Second tensor for the subtraction Return Value type( torch_tensor ) Tensor to hold the difference","tags":"","url":"interface/operator (-).html"},{"title":"operator (/) – FTorch","text":"public interface operator (/) Calls interface~~operator (SLASH)~~CallsGraph interface~operator (SLASH) operator (/) proc~torch_tensor_divide torch_tensor_divide interface~operator (SLASH)->proc~torch_tensor_divide interface~torch_tensor_divide_c torch_tensor_divide_c proc~torch_tensor_divide->interface~torch_tensor_divide_c proc~torch_tensor_empty torch_tensor_empty proc~torch_tensor_divide->proc~torch_tensor_empty proc~torch_tensor_get_device_index torch_tensor%torch_tensor_get_device_index proc~torch_tensor_divide->proc~torch_tensor_get_device_index proc~torch_tensor_get_device_type torch_tensor%torch_tensor_get_device_type proc~torch_tensor_divide->proc~torch_tensor_get_device_type proc~torch_tensor_get_dtype torch_tensor%torch_tensor_get_dtype proc~torch_tensor_divide->proc~torch_tensor_get_dtype proc~torch_tensor_get_rank torch_tensor%torch_tensor_get_rank proc~torch_tensor_divide->proc~torch_tensor_get_rank proc~torch_tensor_get_shape torch_tensor%torch_tensor_get_shape proc~torch_tensor_divide->proc~torch_tensor_get_shape proc~torch_tensor_requires_grad torch_tensor%torch_tensor_requires_grad proc~torch_tensor_divide->proc~torch_tensor_requires_grad proc~torch_tensor_get_shape->proc~torch_tensor_get_rank Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public  function torch_tensor_divide (tensor1, tensor2) result(output) Overloads division operator for two tensors. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor1 First tensor for the division type( torch_tensor ), intent(in) :: tensor2 Second tensor for the division Return Value type( torch_tensor ) Tensor to hold the quotient","tags":"","url":"interface/operator (SLASH).html"},{"title":"torch_delete – FTorch","text":"public interface torch_delete Interface for deleting generic torch objects Calls interface~~torch_delete~~CallsGraph interface~torch_delete torch_delete proc~torch_model_delete torch_model_delete interface~torch_delete->proc~torch_model_delete proc~torch_tensor_array_delete torch_tensor_array_delete interface~torch_delete->proc~torch_tensor_array_delete proc~torch_tensor_delete torch_tensor_delete interface~torch_delete->proc~torch_tensor_delete proc~torch_tensor_array_delete->proc~torch_tensor_delete Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public  subroutine torch_model_delete (model) Deallocates a TorchScript model Arguments Type Intent Optional Attributes Name type( torch_model ), intent(in) :: model Torch Model to deallocate public  subroutine torch_tensor_delete (tensor) Deallocates a tensor. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(inout) :: tensor Tensor to deallocate public  subroutine torch_tensor_array_delete (tensor_array) Deallocates an array of tensors. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(inout), dimension(:) :: tensor_array Array of tensors to deallocate","tags":"","url":"interface/torch_delete.html"},{"title":"torch_from_blob_c – FTorch","text":"interface Called by interface~~torch_from_blob_c~~CalledByGraph interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_blob->interface~torch_from_blob_c proc~torch_tensor_from_array_int16_1d torch_tensor_from_array_int16_1d proc~torch_tensor_from_array_int16_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_2d torch_tensor_from_array_int16_2d proc~torch_tensor_from_array_int16_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_3d torch_tensor_from_array_int16_3d proc~torch_tensor_from_array_int16_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_4d torch_tensor_from_array_int16_4d proc~torch_tensor_from_array_int16_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_5d torch_tensor_from_array_int16_5d proc~torch_tensor_from_array_int16_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_1d torch_tensor_from_array_int32_1d proc~torch_tensor_from_array_int32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_2d torch_tensor_from_array_int32_2d proc~torch_tensor_from_array_int32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_3d torch_tensor_from_array_int32_3d proc~torch_tensor_from_array_int32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_4d torch_tensor_from_array_int32_4d proc~torch_tensor_from_array_int32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_5d torch_tensor_from_array_int32_5d proc~torch_tensor_from_array_int32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_1d torch_tensor_from_array_int64_1d proc~torch_tensor_from_array_int64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_2d torch_tensor_from_array_int64_2d proc~torch_tensor_from_array_int64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_3d torch_tensor_from_array_int64_3d proc~torch_tensor_from_array_int64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_4d torch_tensor_from_array_int64_4d proc~torch_tensor_from_array_int64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_5d torch_tensor_from_array_int64_5d proc~torch_tensor_from_array_int64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_1d torch_tensor_from_array_int8_1d proc~torch_tensor_from_array_int8_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_2d torch_tensor_from_array_int8_2d proc~torch_tensor_from_array_int8_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_3d torch_tensor_from_array_int8_3d proc~torch_tensor_from_array_int8_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_4d torch_tensor_from_array_int8_4d proc~torch_tensor_from_array_int8_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_5d torch_tensor_from_array_int8_5d proc~torch_tensor_from_array_int8_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_1d torch_tensor_from_array_real32_1d proc~torch_tensor_from_array_real32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_2d torch_tensor_from_array_real32_2d proc~torch_tensor_from_array_real32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_3d torch_tensor_from_array_real32_3d proc~torch_tensor_from_array_real32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_4d torch_tensor_from_array_real32_4d proc~torch_tensor_from_array_real32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_5d torch_tensor_from_array_real32_5d proc~torch_tensor_from_array_real32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_1d torch_tensor_from_array_real64_1d proc~torch_tensor_from_array_real64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_2d torch_tensor_from_array_real64_2d proc~torch_tensor_from_array_real64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_3d torch_tensor_from_array_real64_3d proc~torch_tensor_from_array_real64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_4d torch_tensor_from_array_real64_4d proc~torch_tensor_from_array_real64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_5d torch_tensor_from_array_real64_5d proc~torch_tensor_from_array_real64_5d->proc~torch_tensor_from_blob interface~torch_tensor_from_array torch_tensor_from_array interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  function torch_from_blob_c(data, ndims, tensor_shape, strides, dtype, device_type, device_index, requires_grad) result(tensor_p) bind(c, name = 'torch_from_blob') Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: data integer(kind=c_int), intent(in), value :: ndims integer(kind=c_int64_t), intent(in) :: tensor_shape (*) integer(kind=c_int64_t), intent(in) :: strides (*) integer(kind=c_int), intent(in), value :: dtype integer(kind=c_int), intent(in), value :: device_type integer(kind=c_int), intent(in), value :: device_index logical(kind=c_bool), intent(in), value :: requires_grad Return Value type(c_ptr)","tags":"","url":"interface/torch_from_blob_c.html"},{"title":"torch_tensor_divide_c – FTorch","text":"interface Called by interface~~torch_tensor_divide_c~~CalledByGraph interface~torch_tensor_divide_c torch_tensor_divide_c proc~torch_tensor_divide torch_tensor_divide proc~torch_tensor_divide->interface~torch_tensor_divide_c interface~operator (SLASH) operator (/) interface~operator (SLASH)->proc~torch_tensor_divide Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  subroutine torch_tensor_divide_c(output_c, tensor1_c, tensor2_c) bind(c, name = 'torch_tensor_divide') Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: output_c type(c_ptr), intent(in), value :: tensor1_c type(c_ptr), intent(in), value :: tensor2_c","tags":"","url":"interface/torch_tensor_divide_c.html"},{"title":"torch_tensor_from_array – FTorch","text":"public interface torch_tensor_from_array Interface for directing torch_tensor_from_array to possible input types and ranks Calls interface~~torch_tensor_from_array~~CallsGraph interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int16_1d torch_tensor_from_array_int16_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d torch_tensor_from_array_int16_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d torch_tensor_from_array_int16_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d torch_tensor_from_array_int16_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d torch_tensor_from_array_int16_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d torch_tensor_from_array_int32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d torch_tensor_from_array_int32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d torch_tensor_from_array_int32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d torch_tensor_from_array_int32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d torch_tensor_from_array_int32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d torch_tensor_from_array_int64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d torch_tensor_from_array_int64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d torch_tensor_from_array_int64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d torch_tensor_from_array_int64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d torch_tensor_from_array_int64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d torch_tensor_from_array_int8_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d torch_tensor_from_array_int8_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d torch_tensor_from_array_int8_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d torch_tensor_from_array_int8_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d torch_tensor_from_array_int8_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d torch_tensor_from_array_real32_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d torch_tensor_from_array_real32_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d torch_tensor_from_array_real32_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d torch_tensor_from_array_real32_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d torch_tensor_from_array_real32_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d torch_tensor_from_array_real64_1d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d torch_tensor_from_array_real64_2d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d torch_tensor_from_array_real64_3d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d torch_tensor_from_array_real64_4d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d torch_tensor_from_array_real64_5d interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_blob torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d->proc~torch_tensor_from_blob proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array interface~torch_from_blob_c torch_from_blob_c proc~torch_tensor_from_blob->interface~torch_from_blob_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~torch_tensor_from_array~~CalledByGraph interface~torch_tensor_from_array torch_tensor_from_array proc~torch_tensor_from_array_int16_1d_default_layout torch_tensor_from_array_int16_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_1d_default_layout proc~torch_tensor_from_array_int16_2d_default_layout torch_tensor_from_array_int16_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_2d_default_layout proc~torch_tensor_from_array_int16_3d_default_layout torch_tensor_from_array_int16_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_3d_default_layout proc~torch_tensor_from_array_int16_4d_default_layout torch_tensor_from_array_int16_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_4d_default_layout proc~torch_tensor_from_array_int16_5d_default_layout torch_tensor_from_array_int16_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int16_5d_default_layout proc~torch_tensor_from_array_int32_1d_default_layout torch_tensor_from_array_int32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_1d_default_layout proc~torch_tensor_from_array_int32_2d_default_layout torch_tensor_from_array_int32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_2d_default_layout proc~torch_tensor_from_array_int32_3d_default_layout torch_tensor_from_array_int32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_3d_default_layout proc~torch_tensor_from_array_int32_4d_default_layout torch_tensor_from_array_int32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_4d_default_layout proc~torch_tensor_from_array_int32_5d_default_layout torch_tensor_from_array_int32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int32_5d_default_layout proc~torch_tensor_from_array_int64_1d_default_layout torch_tensor_from_array_int64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_1d_default_layout proc~torch_tensor_from_array_int64_2d_default_layout torch_tensor_from_array_int64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_2d_default_layout proc~torch_tensor_from_array_int64_3d_default_layout torch_tensor_from_array_int64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_3d_default_layout proc~torch_tensor_from_array_int64_4d_default_layout torch_tensor_from_array_int64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_4d_default_layout proc~torch_tensor_from_array_int64_5d_default_layout torch_tensor_from_array_int64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int64_5d_default_layout proc~torch_tensor_from_array_int8_1d_default_layout torch_tensor_from_array_int8_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_1d_default_layout proc~torch_tensor_from_array_int8_2d_default_layout torch_tensor_from_array_int8_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_2d_default_layout proc~torch_tensor_from_array_int8_3d_default_layout torch_tensor_from_array_int8_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_3d_default_layout proc~torch_tensor_from_array_int8_4d_default_layout torch_tensor_from_array_int8_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_4d_default_layout proc~torch_tensor_from_array_int8_5d_default_layout torch_tensor_from_array_int8_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_int8_5d_default_layout proc~torch_tensor_from_array_real32_1d_default_layout torch_tensor_from_array_real32_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_1d_default_layout proc~torch_tensor_from_array_real32_2d_default_layout torch_tensor_from_array_real32_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_2d_default_layout proc~torch_tensor_from_array_real32_3d_default_layout torch_tensor_from_array_real32_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_3d_default_layout proc~torch_tensor_from_array_real32_4d_default_layout torch_tensor_from_array_real32_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_4d_default_layout proc~torch_tensor_from_array_real32_5d_default_layout torch_tensor_from_array_real32_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real32_5d_default_layout proc~torch_tensor_from_array_real64_1d_default_layout torch_tensor_from_array_real64_1d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_1d_default_layout proc~torch_tensor_from_array_real64_2d_default_layout torch_tensor_from_array_real64_2d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_2d_default_layout proc~torch_tensor_from_array_real64_3d_default_layout torch_tensor_from_array_real64_3d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_3d_default_layout proc~torch_tensor_from_array_real64_4d_default_layout torch_tensor_from_array_real64_4d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_4d_default_layout proc~torch_tensor_from_array_real64_5d_default_layout torch_tensor_from_array_real64_5d_default_layout interface~torch_tensor_from_array->proc~torch_tensor_from_array_real64_5d_default_layout proc~torch_tensor_from_array_int16_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int16_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int64_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_int8_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real32_5d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_1d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_2d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_3d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_4d_default_layout->interface~torch_tensor_from_array proc~torch_tensor_from_array_real64_5d_default_layout->interface~torch_tensor_from_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public  subroutine torch_tensor_from_array_int8_1d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 1 containing data of type int8 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (1) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int8_2d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 2 containing data of type int8 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (2) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int8_3d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 3 containing data of type int8 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (3) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int8_4d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 4 containing data of type int8 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (4) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int8_5d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 5 containing data of type int8 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (5) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int16_1d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 1 containing data of type int16 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (1) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int16_2d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 2 containing data of type int16 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (2) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int16_3d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 3 containing data of type int16 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (3) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int16_4d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 4 containing data of type int16 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (4) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int16_5d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 5 containing data of type int16 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (5) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int32_1d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 1 containing data of type int32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (1) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int32_2d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 2 containing data of type int32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (2) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int32_3d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 3 containing data of type int32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (3) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int32_4d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 4 containing data of type int32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (4) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int32_5d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 5 containing data of type int32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (5) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int64_1d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 1 containing data of type int64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (1) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int64_2d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 2 containing data of type int64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (2) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int64_3d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 3 containing data of type int64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (3) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int64_4d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 4 containing data of type int64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (4) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int64_5d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 5 containing data of type int64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (5) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real32_1d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 1 containing data of type real32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (1) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real32_2d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 2 containing data of type real32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (2) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real32_3d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 3 containing data of type real32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (3) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real32_4d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 4 containing data of type real32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (4) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real32_5d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 5 containing data of type real32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (5) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real64_1d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 1 containing data of type real64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (1) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real64_2d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 2 containing data of type real64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (2) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real64_3d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 3 containing data of type real64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (3) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real64_4d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 4 containing data of type real64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (4) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real64_5d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 5 containing data of type real64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (5) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int8_1d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 1 containing data of type int8 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int8_2d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 2 containing data of type int8 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int8_3d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 3 containing data of type int8 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int8_4d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 4 containing data of type int8 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int8_5d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 5 containing data of type int8 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int16_1d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 1 containing data of type int16 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int16_2d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 2 containing data of type int16 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int16_3d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 3 containing data of type int16 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int16_4d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 4 containing data of type int16 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int16_5d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 5 containing data of type int16 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int32_1d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 1 containing data of type int32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int32_2d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 2 containing data of type int32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int32_3d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 3 containing data of type int32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int32_4d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 4 containing data of type int32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int32_5d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 5 containing data of type int32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int64_1d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 1 containing data of type int64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int64_2d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 2 containing data of type int64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int64_3d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 3 containing data of type int64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int64_4d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 4 containing data of type int64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int64_5d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 5 containing data of type int64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real32_1d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 1 containing data of type real32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real32_2d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 2 containing data of type real32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real32_3d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 3 containing data of type real32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real32_4d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 4 containing data of type real32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real32_5d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 5 containing data of type real32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real64_1d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 1 containing data of type real64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real64_2d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 2 containing data of type real64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real64_3d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 3 containing data of type real64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real64_4d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 4 containing data of type real64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real64_5d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 5 containing data of type real64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor","tags":"","url":"interface/torch_tensor_from_array.html"},{"title":"torch_tensor_multiply_c – FTorch","text":"interface Called by interface~~torch_tensor_multiply_c~~CalledByGraph interface~torch_tensor_multiply_c torch_tensor_multiply_c proc~torch_tensor_multiply torch_tensor_multiply proc~torch_tensor_multiply->interface~torch_tensor_multiply_c interface~operator (ASTERISK) operator (*) interface~operator (ASTERISK)->proc~torch_tensor_multiply Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  subroutine torch_tensor_multiply_c(output_c, tensor1_c, tensor2_c) bind(c, name = 'torch_tensor_multiply') Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: output_c type(c_ptr), intent(in), value :: tensor1_c type(c_ptr), intent(in), value :: tensor2_c","tags":"","url":"interface/torch_tensor_multiply_c.html"},{"title":"assert_allclose_real32_1d – FTorch","text":"public  function assert_allclose_real32_1d(got, expect, test_name, rtol, print_result) result(test_pass) Asserts that two real32-valued 1D arrays coincide to a given relative tolerance Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: got The array of values to be tested real(kind=real32), intent(in), dimension(:) :: expect The array of expected values character(len=*), intent(in) :: test_name Name of the test being run real(kind=real32), intent(in), optional :: rtol Optional relative tolerance (defaults to 1e-5) logical, intent(in), optional :: print_result Optionally print test result to screen (defaults to .true.) Return Value logical Did the assertion pass? Calls proc~~assert_allclose_real32_1d~~CallsGraph proc~assert_allclose_real32_1d assert_allclose_real32_1d proc~test_print test_print proc~assert_allclose_real32_1d->proc~test_print Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~assert_allclose_real32_1d~~CalledByGraph proc~assert_allclose_real32_1d assert_allclose_real32_1d interface~assert_allclose assert_allclose interface~assert_allclose->proc~assert_allclose_real32_1d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function assert_allclose_real32_1d ( got , expect , test_name , rtol , print_result ) result ( test_pass ) character ( len =* ), intent ( in ) :: test_name !! Name of the test being run real ( kind = real32 ), intent ( in ), dimension (:) :: got !! The array of values to be tested real ( kind = real32 ), intent ( in ), dimension (:) :: expect !! The array of expected values real ( kind = real32 ), intent ( in ), optional :: rtol !! Optional relative tolerance (defaults to 1e-5) logical , intent ( in ), optional :: print_result !! Optionally print test result to screen (defaults to .true.) logical :: test_pass !! Did the assertion pass? character ( len = 80 ) :: message real ( kind = real32 ) :: rtol_value integer :: shape_error logical :: print_result_value if (. not . present ( rtol )) then rtol_value = 1.0e-5 else rtol_value = rtol end if if (. not . present ( print_result )) then print_result_value = . true . else print_result_value = print_result end if ! Check the shapes of the arrays match shape_error = maxval ( abs ( shape ( got ) - shape ( expect ))) test_pass = ( shape_error == 0 ) if ( test_pass ) then test_pass = all ( abs ( got - expect ) <= rtol_value * abs ( expect )) if ( print_result_value ) then write ( message , '(\"relative tolerance = \", E11.4)' ) rtol_value call test_print ( test_name , message , test_pass ) end if else if ( print_result_value ) then call test_print ( test_name , \"Arrays have mismatching shapes.\" , test_pass ) endif end function assert_allclose_real32_1d","tags":"","url":"proc/assert_allclose_real32_1d.html"},{"title":"assert_allclose_real32_2d – FTorch","text":"public  function assert_allclose_real32_2d(got, expect, test_name, rtol, print_result) result(test_pass) Asserts that two real32-valued 2D arrays coincide to a given relative tolerance Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:) :: got The array of values to be tested real(kind=real32), intent(in), dimension(:,:) :: expect The array of expected values character(len=*), intent(in) :: test_name Name of the test being run real(kind=real32), intent(in), optional :: rtol Optional relative tolerance (defaults to 1e-5) logical, intent(in), optional :: print_result Optionally print test result to screen (defaults to .true.) Return Value logical Did the assertion pass? Calls proc~~assert_allclose_real32_2d~~CallsGraph proc~assert_allclose_real32_2d assert_allclose_real32_2d proc~test_print test_print proc~assert_allclose_real32_2d->proc~test_print Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~assert_allclose_real32_2d~~CalledByGraph proc~assert_allclose_real32_2d assert_allclose_real32_2d interface~assert_allclose assert_allclose interface~assert_allclose->proc~assert_allclose_real32_2d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function assert_allclose_real32_2d ( got , expect , test_name , rtol , print_result ) result ( test_pass ) character ( len =* ), intent ( in ) :: test_name !! Name of the test being run real ( kind = real32 ), intent ( in ), dimension (:,:) :: got !! The array of values to be tested real ( kind = real32 ), intent ( in ), dimension (:,:) :: expect !! The array of expected values real ( kind = real32 ), intent ( in ), optional :: rtol !! Optional relative tolerance (defaults to 1e-5) logical , intent ( in ), optional :: print_result !! Optionally print test result to screen (defaults to .true.) logical :: test_pass !! Did the assertion pass? character ( len = 80 ) :: message real ( kind = real32 ) :: rtol_value integer :: shape_error logical :: print_result_value if (. not . present ( rtol )) then rtol_value = 1.0e-5 else rtol_value = rtol end if if (. not . present ( print_result )) then print_result_value = . true . else print_result_value = print_result end if ! Check the shapes of the arrays match shape_error = maxval ( abs ( shape ( got ) - shape ( expect ))) test_pass = ( shape_error == 0 ) if ( test_pass ) then test_pass = all ( abs ( got - expect ) <= rtol_value * abs ( expect )) if ( print_result_value ) then write ( message , '(\"relative tolerance = \", E11.4)' ) rtol_value call test_print ( test_name , message , test_pass ) end if else if ( print_result_value ) then call test_print ( test_name , \"Arrays have mismatching shapes.\" , test_pass ) endif end function assert_allclose_real32_2d","tags":"","url":"proc/assert_allclose_real32_2d.html"},{"title":"assert_allclose_real32_3d – FTorch","text":"public  function assert_allclose_real32_3d(got, expect, test_name, rtol, print_result) result(test_pass) Asserts that two real32-valued 3D arrays coincide to a given relative tolerance Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:) :: got The array of values to be tested real(kind=real32), intent(in), dimension(:,:,:) :: expect The array of expected values character(len=*), intent(in) :: test_name Name of the test being run real(kind=real32), intent(in), optional :: rtol Optional relative tolerance (defaults to 1e-5) logical, intent(in), optional :: print_result Optionally print test result to screen (defaults to .true.) Return Value logical Did the assertion pass? Calls proc~~assert_allclose_real32_3d~~CallsGraph proc~assert_allclose_real32_3d assert_allclose_real32_3d proc~test_print test_print proc~assert_allclose_real32_3d->proc~test_print Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~assert_allclose_real32_3d~~CalledByGraph proc~assert_allclose_real32_3d assert_allclose_real32_3d interface~assert_allclose assert_allclose interface~assert_allclose->proc~assert_allclose_real32_3d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function assert_allclose_real32_3d ( got , expect , test_name , rtol , print_result ) result ( test_pass ) character ( len =* ), intent ( in ) :: test_name !! Name of the test being run real ( kind = real32 ), intent ( in ), dimension (:,:,:) :: got !! The array of values to be tested real ( kind = real32 ), intent ( in ), dimension (:,:,:) :: expect !! The array of expected values real ( kind = real32 ), intent ( in ), optional :: rtol !! Optional relative tolerance (defaults to 1e-5) logical , intent ( in ), optional :: print_result !! Optionally print test result to screen (defaults to .true.) logical :: test_pass !! Did the assertion pass? character ( len = 80 ) :: message real ( kind = real32 ) :: rtol_value integer :: shape_error logical :: print_result_value if (. not . present ( rtol )) then rtol_value = 1.0e-5 else rtol_value = rtol end if if (. not . present ( print_result )) then print_result_value = . true . else print_result_value = print_result end if ! Check the shapes of the arrays match shape_error = maxval ( abs ( shape ( got ) - shape ( expect ))) test_pass = ( shape_error == 0 ) if ( test_pass ) then test_pass = all ( abs ( got - expect ) <= rtol_value * abs ( expect )) if ( print_result_value ) then write ( message , '(\"relative tolerance = \", E11.4)' ) rtol_value call test_print ( test_name , message , test_pass ) end if else if ( print_result_value ) then call test_print ( test_name , \"Arrays have mismatching shapes.\" , test_pass ) endif end function assert_allclose_real32_3d","tags":"","url":"proc/assert_allclose_real32_3d.html"},{"title":"assert_allclose_real64_1d – FTorch","text":"public  function assert_allclose_real64_1d(got, expect, test_name, rtol, print_result) result(test_pass) Asserts that two real64-valued 1D arrays coincide to a given relative tolerance Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: got The array of values to be tested real(kind=real64), intent(in), dimension(:) :: expect The array of expected values character(len=*), intent(in) :: test_name Name of the test being run real(kind=real64), intent(in), optional :: rtol Optional relative tolerance (defaults to 1e-5) logical, intent(in), optional :: print_result Optionally print test result to screen (defaults to .true.) Return Value logical Did the assertion pass? Calls proc~~assert_allclose_real64_1d~~CallsGraph proc~assert_allclose_real64_1d assert_allclose_real64_1d proc~test_print test_print proc~assert_allclose_real64_1d->proc~test_print Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~assert_allclose_real64_1d~~CalledByGraph proc~assert_allclose_real64_1d assert_allclose_real64_1d interface~assert_allclose assert_allclose interface~assert_allclose->proc~assert_allclose_real64_1d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function assert_allclose_real64_1d ( got , expect , test_name , rtol , print_result ) result ( test_pass ) character ( len =* ), intent ( in ) :: test_name !! Name of the test being run real ( kind = real64 ), intent ( in ), dimension (:) :: got !! The array of values to be tested real ( kind = real64 ), intent ( in ), dimension (:) :: expect !! The array of expected values real ( kind = real64 ), intent ( in ), optional :: rtol !! Optional relative tolerance (defaults to 1e-5) logical , intent ( in ), optional :: print_result !! Optionally print test result to screen (defaults to .true.) logical :: test_pass !! Did the assertion pass? character ( len = 80 ) :: message real ( kind = real64 ) :: rtol_value integer :: shape_error logical :: print_result_value if (. not . present ( rtol )) then rtol_value = 1.0e-5 else rtol_value = rtol end if if (. not . present ( print_result )) then print_result_value = . true . else print_result_value = print_result end if ! Check the shapes of the arrays match shape_error = maxval ( abs ( shape ( got ) - shape ( expect ))) test_pass = ( shape_error == 0 ) if ( test_pass ) then test_pass = all ( abs ( got - expect ) <= rtol_value * abs ( expect )) if ( print_result_value ) then write ( message , '(\"relative tolerance = \", E11.4)' ) rtol_value call test_print ( test_name , message , test_pass ) end if else if ( print_result_value ) then call test_print ( test_name , \"Arrays have mismatching shapes.\" , test_pass ) endif end function assert_allclose_real64_1d","tags":"","url":"proc/assert_allclose_real64_1d.html"},{"title":"assert_allclose_real64_2d – FTorch","text":"public  function assert_allclose_real64_2d(got, expect, test_name, rtol, print_result) result(test_pass) Asserts that two real64-valued 2D arrays coincide to a given relative tolerance Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: got The array of values to be tested real(kind=real64), intent(in), dimension(:,:) :: expect The array of expected values character(len=*), intent(in) :: test_name Name of the test being run real(kind=real64), intent(in), optional :: rtol Optional relative tolerance (defaults to 1e-5) logical, intent(in), optional :: print_result Optionally print test result to screen (defaults to .true.) Return Value logical Did the assertion pass? Calls proc~~assert_allclose_real64_2d~~CallsGraph proc~assert_allclose_real64_2d assert_allclose_real64_2d proc~test_print test_print proc~assert_allclose_real64_2d->proc~test_print Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~assert_allclose_real64_2d~~CalledByGraph proc~assert_allclose_real64_2d assert_allclose_real64_2d interface~assert_allclose assert_allclose interface~assert_allclose->proc~assert_allclose_real64_2d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function assert_allclose_real64_2d ( got , expect , test_name , rtol , print_result ) result ( test_pass ) character ( len =* ), intent ( in ) :: test_name !! Name of the test being run real ( kind = real64 ), intent ( in ), dimension (:,:) :: got !! The array of values to be tested real ( kind = real64 ), intent ( in ), dimension (:,:) :: expect !! The array of expected values real ( kind = real64 ), intent ( in ), optional :: rtol !! Optional relative tolerance (defaults to 1e-5) logical , intent ( in ), optional :: print_result !! Optionally print test result to screen (defaults to .true.) logical :: test_pass !! Did the assertion pass? character ( len = 80 ) :: message real ( kind = real64 ) :: rtol_value integer :: shape_error logical :: print_result_value if (. not . present ( rtol )) then rtol_value = 1.0e-5 else rtol_value = rtol end if if (. not . present ( print_result )) then print_result_value = . true . else print_result_value = print_result end if ! Check the shapes of the arrays match shape_error = maxval ( abs ( shape ( got ) - shape ( expect ))) test_pass = ( shape_error == 0 ) if ( test_pass ) then test_pass = all ( abs ( got - expect ) <= rtol_value * abs ( expect )) if ( print_result_value ) then write ( message , '(\"relative tolerance = \", E11.4)' ) rtol_value call test_print ( test_name , message , test_pass ) end if else if ( print_result_value ) then call test_print ( test_name , \"Arrays have mismatching shapes.\" , test_pass ) endif end function assert_allclose_real64_2d","tags":"","url":"proc/assert_allclose_real64_2d.html"},{"title":"assert_allclose_real64_3d – FTorch","text":"public  function assert_allclose_real64_3d(got, expect, test_name, rtol, print_result) result(test_pass) Asserts that two real64-valued 3D arrays coincide to a given relative tolerance Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:) :: got The array of values to be tested real(kind=real64), intent(in), dimension(:,:,:) :: expect The array of expected values character(len=*), intent(in) :: test_name Name of the test being run real(kind=real64), intent(in), optional :: rtol Optional relative tolerance (defaults to 1e-5) logical, intent(in), optional :: print_result Optionally print test result to screen (defaults to .true.) Return Value logical Did the assertion pass? Calls proc~~assert_allclose_real64_3d~~CallsGraph proc~assert_allclose_real64_3d assert_allclose_real64_3d proc~test_print test_print proc~assert_allclose_real64_3d->proc~test_print Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~assert_allclose_real64_3d~~CalledByGraph proc~assert_allclose_real64_3d assert_allclose_real64_3d interface~assert_allclose assert_allclose interface~assert_allclose->proc~assert_allclose_real64_3d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function assert_allclose_real64_3d ( got , expect , test_name , rtol , print_result ) result ( test_pass ) character ( len =* ), intent ( in ) :: test_name !! Name of the test being run real ( kind = real64 ), intent ( in ), dimension (:,:,:) :: got !! The array of values to be tested real ( kind = real64 ), intent ( in ), dimension (:,:,:) :: expect !! The array of expected values real ( kind = real64 ), intent ( in ), optional :: rtol !! Optional relative tolerance (defaults to 1e-5) logical , intent ( in ), optional :: print_result !! Optionally print test result to screen (defaults to .true.) logical :: test_pass !! Did the assertion pass? character ( len = 80 ) :: message real ( kind = real64 ) :: rtol_value integer :: shape_error logical :: print_result_value if (. not . present ( rtol )) then rtol_value = 1.0e-5 else rtol_value = rtol end if if (. not . present ( print_result )) then print_result_value = . true . else print_result_value = print_result end if ! Check the shapes of the arrays match shape_error = maxval ( abs ( shape ( got ) - shape ( expect ))) test_pass = ( shape_error == 0 ) if ( test_pass ) then test_pass = all ( abs ( got - expect ) <= rtol_value * abs ( expect )) if ( print_result_value ) then write ( message , '(\"relative tolerance = \", E11.4)' ) rtol_value call test_print ( test_name , message , test_pass ) end if else if ( print_result_value ) then call test_print ( test_name , \"Arrays have mismatching shapes.\" , test_pass ) endif end function assert_allclose_real64_3d","tags":"","url":"proc/assert_allclose_real64_3d.html"},{"title":"assert_isclose_real32 – FTorch","text":"public  function assert_isclose_real32(got, expect, test_name, rtol, print_result) result(test_pass) Asserts that two real32 values coincide to a given relative tolerance Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: got The value to be tested real(kind=real32), intent(in) :: expect The expected value character(len=*), intent(in) :: test_name Name of the test being run real(kind=real32), intent(in), optional :: rtol Optional relative tolerance (defaults to 1e-5) logical, intent(in), optional :: print_result Optionally print test result to screen (defaults to .true.) Return Value logical Did the assertion pass? Calls proc~~assert_isclose_real32~~CallsGraph proc~assert_isclose_real32 assert_isclose_real32 proc~test_print test_print proc~assert_isclose_real32->proc~test_print Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~assert_isclose_real32~~CalledByGraph proc~assert_isclose_real32 assert_isclose_real32 interface~assert_isclose assert_isclose interface~assert_isclose->proc~assert_isclose_real32 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function assert_isclose_real32 ( got , expect , test_name , rtol , print_result ) result ( test_pass ) character ( len =* ), intent ( in ) :: test_name !! Name of the test being run real ( kind = real32 ), intent ( in ) :: got !! The value to be tested real ( kind = real32 ), intent ( in ) :: expect !! The expected value real ( kind = real32 ), intent ( in ), optional :: rtol !! Optional relative tolerance (defaults to 1e-5) logical , intent ( in ), optional :: print_result !! Optionally print test result to screen (defaults to .true.) logical :: test_pass !! Did the assertion pass? character ( len = 80 ) :: message real ( kind = real32 ) :: rtol_value logical :: print_result_value if (. not . present ( rtol )) then rtol_value = 1e-5 else rtol_value = rtol end if if (. not . present ( print_result )) then print_result_value = . true . else print_result_value = print_result end if test_pass = ( abs ( got - expect ) <= rtol_value * abs ( expect )) if ( print_result_value ) then write ( message , '(\"relative tolerance = \", E11.4)' ) rtol_value call test_print ( test_name , message , test_pass ) end if end function assert_isclose_real32","tags":"","url":"proc/assert_isclose_real32.html"},{"title":"assert_isclose_real64 – FTorch","text":"public  function assert_isclose_real64(got, expect, test_name, rtol, print_result) result(test_pass) Asserts that two real64 values coincide to a given relative tolerance Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: got The value to be tested real(kind=real64), intent(in) :: expect The expected value character(len=*), intent(in) :: test_name Name of the test being run real(kind=real64), intent(in), optional :: rtol Optional relative tolerance (defaults to 1e-5) logical, intent(in), optional :: print_result Optionally print test result to screen (defaults to .true.) Return Value logical Did the assertion pass? Calls proc~~assert_isclose_real64~~CallsGraph proc~assert_isclose_real64 assert_isclose_real64 proc~test_print test_print proc~assert_isclose_real64->proc~test_print Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~assert_isclose_real64~~CalledByGraph proc~assert_isclose_real64 assert_isclose_real64 interface~assert_isclose assert_isclose interface~assert_isclose->proc~assert_isclose_real64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function assert_isclose_real64 ( got , expect , test_name , rtol , print_result ) result ( test_pass ) character ( len =* ), intent ( in ) :: test_name !! Name of the test being run real ( kind = real64 ), intent ( in ) :: got !! The value to be tested real ( kind = real64 ), intent ( in ) :: expect !! The expected value real ( kind = real64 ), intent ( in ), optional :: rtol !! Optional relative tolerance (defaults to 1e-5) logical , intent ( in ), optional :: print_result !! Optionally print test result to screen (defaults to .true.) logical :: test_pass !! Did the assertion pass? character ( len = 80 ) :: message real ( kind = real64 ) :: rtol_value logical :: print_result_value if (. not . present ( rtol )) then rtol_value = 1e-5 else rtol_value = rtol end if if (. not . present ( print_result )) then print_result_value = . true . else print_result_value = print_result end if test_pass = ( abs ( got - expect ) <= rtol_value * abs ( expect )) if ( print_result_value ) then write ( message , '(\"relative tolerance = \", E11.4)' ) rtol_value call test_print ( test_name , message , test_pass ) end if end function assert_isclose_real64","tags":"","url":"proc/assert_isclose_real64.html"},{"title":"test_print – FTorch","text":"public  subroutine test_print(test_name, message, test_pass) Print the result of a test to the terminal Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: test_name Name of the test being run character(len=*), intent(in) :: message Message to print logical, intent(in) :: test_pass Result of the assertion Called by proc~~test_print~~CalledByGraph proc~test_print test_print proc~assert_allclose_real32_1d assert_allclose_real32_1d proc~assert_allclose_real32_1d->proc~test_print proc~assert_allclose_real32_2d assert_allclose_real32_2d proc~assert_allclose_real32_2d->proc~test_print proc~assert_allclose_real32_3d assert_allclose_real32_3d proc~assert_allclose_real32_3d->proc~test_print proc~assert_allclose_real64_1d assert_allclose_real64_1d proc~assert_allclose_real64_1d->proc~test_print proc~assert_allclose_real64_2d assert_allclose_real64_2d proc~assert_allclose_real64_2d->proc~test_print proc~assert_allclose_real64_3d assert_allclose_real64_3d proc~assert_allclose_real64_3d->proc~test_print proc~assert_isclose_real32 assert_isclose_real32 proc~assert_isclose_real32->proc~test_print proc~assert_isclose_real64 assert_isclose_real64 proc~assert_isclose_real64->proc~test_print interface~assert_allclose assert_allclose interface~assert_allclose->proc~assert_allclose_real32_1d interface~assert_allclose->proc~assert_allclose_real32_2d interface~assert_allclose->proc~assert_allclose_real32_3d interface~assert_allclose->proc~assert_allclose_real64_1d interface~assert_allclose->proc~assert_allclose_real64_2d interface~assert_allclose->proc~assert_allclose_real64_3d interface~assert_isclose assert_isclose interface~assert_isclose->proc~assert_isclose_real32 interface~assert_isclose->proc~assert_isclose_real64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine test_print ( test_name , message , test_pass ) character ( len =* ), intent ( in ) :: test_name !! Name of the test being run character ( len =* ), intent ( in ) :: message !! Message to print logical , intent ( in ) :: test_pass !! Result of the assertion character ( len = 15 ) :: report if ( test_pass ) then report = char ( 27 ) // '[32m' // 'PASSED' // char ( 27 ) // '[0m' else report = char ( 27 ) // '[31m' // 'FAILED' // char ( 27 ) // '[0m' end if write ( * , '(A, \" :: [\", A, \"] \", A)' ) report , trim ( test_name ), trim ( message ) end subroutine test_print","tags":"","url":"proc/test_print.html"},{"title":"assert_allclose – FTorch","text":"public interface assert_allclose Calls interface~~assert_allclose~~CallsGraph interface~assert_allclose assert_allclose proc~assert_allclose_real32_1d assert_allclose_real32_1d interface~assert_allclose->proc~assert_allclose_real32_1d proc~assert_allclose_real32_2d assert_allclose_real32_2d interface~assert_allclose->proc~assert_allclose_real32_2d proc~assert_allclose_real32_3d assert_allclose_real32_3d interface~assert_allclose->proc~assert_allclose_real32_3d proc~assert_allclose_real64_1d assert_allclose_real64_1d interface~assert_allclose->proc~assert_allclose_real64_1d proc~assert_allclose_real64_2d assert_allclose_real64_2d interface~assert_allclose->proc~assert_allclose_real64_2d proc~assert_allclose_real64_3d assert_allclose_real64_3d interface~assert_allclose->proc~assert_allclose_real64_3d proc~test_print test_print proc~assert_allclose_real32_1d->proc~test_print proc~assert_allclose_real32_2d->proc~test_print proc~assert_allclose_real32_3d->proc~test_print proc~assert_allclose_real64_1d->proc~test_print proc~assert_allclose_real64_2d->proc~test_print proc~assert_allclose_real64_3d->proc~test_print Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public  function assert_allclose_real32_1d (got, expect, test_name, rtol, print_result) result(test_pass) Asserts that two real32-valued 1D arrays coincide to a given relative tolerance Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: got The array of values to be tested real(kind=real32), intent(in), dimension(:) :: expect The array of expected values character(len=*), intent(in) :: test_name Name of the test being run real(kind=real32), intent(in), optional :: rtol Optional relative tolerance (defaults to 1e-5) logical, intent(in), optional :: print_result Optionally print test result to screen (defaults to .true.) Return Value logical Did the assertion pass? public  function assert_allclose_real32_2d (got, expect, test_name, rtol, print_result) result(test_pass) Asserts that two real32-valued 2D arrays coincide to a given relative tolerance Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:) :: got The array of values to be tested real(kind=real32), intent(in), dimension(:,:) :: expect The array of expected values character(len=*), intent(in) :: test_name Name of the test being run real(kind=real32), intent(in), optional :: rtol Optional relative tolerance (defaults to 1e-5) logical, intent(in), optional :: print_result Optionally print test result to screen (defaults to .true.) Return Value logical Did the assertion pass? public  function assert_allclose_real32_3d (got, expect, test_name, rtol, print_result) result(test_pass) Asserts that two real32-valued 3D arrays coincide to a given relative tolerance Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:) :: got The array of values to be tested real(kind=real32), intent(in), dimension(:,:,:) :: expect The array of expected values character(len=*), intent(in) :: test_name Name of the test being run real(kind=real32), intent(in), optional :: rtol Optional relative tolerance (defaults to 1e-5) logical, intent(in), optional :: print_result Optionally print test result to screen (defaults to .true.) Return Value logical Did the assertion pass? public  function assert_allclose_real64_1d (got, expect, test_name, rtol, print_result) result(test_pass) Asserts that two real64-valued 1D arrays coincide to a given relative tolerance Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: got The array of values to be tested real(kind=real64), intent(in), dimension(:) :: expect The array of expected values character(len=*), intent(in) :: test_name Name of the test being run real(kind=real64), intent(in), optional :: rtol Optional relative tolerance (defaults to 1e-5) logical, intent(in), optional :: print_result Optionally print test result to screen (defaults to .true.) Return Value logical Did the assertion pass? public  function assert_allclose_real64_2d (got, expect, test_name, rtol, print_result) result(test_pass) Asserts that two real64-valued 2D arrays coincide to a given relative tolerance Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: got The array of values to be tested real(kind=real64), intent(in), dimension(:,:) :: expect The array of expected values character(len=*), intent(in) :: test_name Name of the test being run real(kind=real64), intent(in), optional :: rtol Optional relative tolerance (defaults to 1e-5) logical, intent(in), optional :: print_result Optionally print test result to screen (defaults to .true.) Return Value logical Did the assertion pass? public  function assert_allclose_real64_3d (got, expect, test_name, rtol, print_result) result(test_pass) Asserts that two real64-valued 3D arrays coincide to a given relative tolerance Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:) :: got The array of values to be tested real(kind=real64), intent(in), dimension(:,:,:) :: expect The array of expected values character(len=*), intent(in) :: test_name Name of the test being run real(kind=real64), intent(in), optional :: rtol Optional relative tolerance (defaults to 1e-5) logical, intent(in), optional :: print_result Optionally print test result to screen (defaults to .true.) Return Value logical Did the assertion pass?","tags":"","url":"interface/assert_allclose.html"},{"title":"assert_isclose – FTorch","text":"public interface assert_isclose Calls interface~~assert_isclose~~CallsGraph interface~assert_isclose assert_isclose proc~assert_isclose_real32 assert_isclose_real32 interface~assert_isclose->proc~assert_isclose_real32 proc~assert_isclose_real64 assert_isclose_real64 interface~assert_isclose->proc~assert_isclose_real64 proc~test_print test_print proc~assert_isclose_real32->proc~test_print proc~assert_isclose_real64->proc~test_print Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public  function assert_isclose_real32 (got, expect, test_name, rtol, print_result) result(test_pass) Asserts that two real32 values coincide to a given relative tolerance Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: got The value to be tested real(kind=real32), intent(in) :: expect The expected value character(len=*), intent(in) :: test_name Name of the test being run real(kind=real32), intent(in), optional :: rtol Optional relative tolerance (defaults to 1e-5) logical, intent(in), optional :: print_result Optionally print test result to screen (defaults to .true.) Return Value logical Did the assertion pass? public  function assert_isclose_real64 (got, expect, test_name, rtol, print_result) result(test_pass) Asserts that two real64 values coincide to a given relative tolerance Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: got The value to be tested real(kind=real64), intent(in) :: expect The expected value character(len=*), intent(in) :: test_name Name of the test being run real(kind=real64), intent(in), optional :: rtol Optional relative tolerance (defaults to 1e-5) logical, intent(in), optional :: print_result Optionally print test result to screen (defaults to .true.) Return Value logical Did the assertion pass?","tags":"","url":"interface/assert_isclose.html"},{"title":"ftorch – FTorch","text":"Main module for FTorch containing types and procedures.\n Generated from ftorch.fypp using the fypp Fortran preprocessor . License\n   FTorch is released under an MIT license.\n   See the LICENSE file for details. Uses iso_fortran_env iso_c_binding module~~ftorch~~UsesGraph module~ftorch ftorch iso_c_binding iso_c_binding module~ftorch->iso_c_binding iso_fortran_env iso_fortran_env module~ftorch->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: ftorch_int = int32 Enumerations enum, bind(c) Enumerators enumerator :: torch_kUInt8 = 0 enumerator :: torch_kInt8 = 1 enumerator :: torch_kInt16 = 2 enumerator :: torch_kInt32 = 3 enumerator :: torch_kInt64 = 4 enumerator :: torch_kFloat16 = 5 enumerator :: torch_kFloat32 = 6 enumerator :: torch_kFloat64 = 7 Description Enumerator for Torch data types\n From c_torch.h (torch_data_t)\n Note that 0 torch_kUInt8 and 5 torch_kFloat16 are not sypported in Fortran enum, bind(c) Enumerators enumerator :: torch_kCPU = 0 enumerator :: torch_kCUDA = 1 enumerator :: torch_kHIP = 1 enumerator :: torch_kXPU = 11 enumerator :: torch_kMPS = 12 Description Enumerator for Torch devices\n From c_torch.h (torch_device_t)\n NOTE: Defined in main CMakeLists and passed via preprocessor Interfaces public        interface assignment (=) public  subroutine torch_tensor_assign (output, input) Overloads assignment operator for tensors. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(inout) :: output Tensor to assign values to type( torch_tensor ), intent(in) :: input Tensor whose values are to be used public        interface operator (*) public  function torch_tensor_multiply (tensor1, tensor2) result(output) Overloads multiplication operator for two tensors. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor1 First tensor to be multiplied type( torch_tensor ), intent(in) :: tensor2 Second tensor to be multiplied Return Value type( torch_tensor ) Tensor to hold the product public        interface operator (**) public  function torch_tensor_power_int8 (tensor, power) result(output) Overloads exponentiation operator for a tensor and a scalar of type int8 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor Tensor to take the power of integer(kind=int8), intent(in), target :: power Integer exponent Return Value type( torch_tensor ) Tensor to hold the exponentiation public  function torch_tensor_power_int16 (tensor, power) result(output) Overloads exponentiation operator for a tensor and a scalar of type int16 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor Tensor to take the power of integer(kind=int16), intent(in), target :: power Integer exponent Return Value type( torch_tensor ) Tensor to hold the exponentiation public  function torch_tensor_power_int32 (tensor, power) result(output) Overloads exponentiation operator for a tensor and a scalar of type int32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor Tensor to take the power of integer(kind=int32), intent(in), target :: power Integer exponent Return Value type( torch_tensor ) Tensor to hold the exponentiation public  function torch_tensor_power_int64 (tensor, power) result(output) Overloads exponentiation operator for a tensor and a scalar of type int64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor Tensor to take the power of integer(kind=int64), intent(in), target :: power Integer exponent Return Value type( torch_tensor ) Tensor to hold the exponentiation public  function torch_tensor_power_real32 (tensor, power) result(output) Overloads exponentiation operator for a tensor and a scalar of type real32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor Tensor to take the power of real(kind=real32), intent(in), target :: power Floating point exponent Return Value type( torch_tensor ) Tensor to hold the exponentiation public  function torch_tensor_power_real64 (tensor, power) result(output) Overloads exponentiation operator for a tensor and a scalar of type real64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor Tensor to take the power of real(kind=real64), intent(in), target :: power Floating point exponent Return Value type( torch_tensor ) Tensor to hold the exponentiation public        interface operator (+) public  function torch_tensor_add (tensor1, tensor2) result(output) Overloads addition operator for two tensors. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor1 First tensor to be added type( torch_tensor ), intent(in) :: tensor2 Second tensor to be added Return Value type( torch_tensor ) Tensor to hold the sum public        interface operator (-) public  function torch_tensor_negative (tensor) result(output) Overloads negative operator for a single tensor. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor Tensor to take the negative of Return Value type( torch_tensor ) Tensor to hold the negative values public  function torch_tensor_subtract (tensor1, tensor2) result(output) Overloads subtraction operator for two tensors. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor1 First tensor for the subtraction type( torch_tensor ), intent(in) :: tensor2 Second tensor for the subtraction Return Value type( torch_tensor ) Tensor to hold the difference public        interface operator (/) public  function torch_tensor_divide (tensor1, tensor2) result(output) Overloads division operator for two tensors. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor1 First tensor for the division type( torch_tensor ), intent(in) :: tensor2 Second tensor for the division Return Value type( torch_tensor ) Tensor to hold the quotient public        interface torch_delete Interface for deleting generic torch objects public  subroutine torch_model_delete (model) Deallocates a TorchScript model Arguments Type Intent Optional Attributes Name type( torch_model ), intent(in) :: model Torch Model to deallocate public  subroutine torch_tensor_delete (tensor) Deallocates a tensor. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(inout) :: tensor Tensor to deallocate public  subroutine torch_tensor_array_delete (tensor_array) Deallocates an array of tensors. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(inout), dimension(:) :: tensor_array Array of tensors to deallocate interface public  function torch_from_blob_c(data, ndims, tensor_shape, strides, dtype, device_type, device_index, requires_grad) result(tensor_p) bind(c, name = 'torch_from_blob') Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: data integer(kind=c_int), intent(in), value :: ndims integer(kind=c_int64_t), intent(in) :: tensor_shape (*) integer(kind=c_int64_t), intent(in) :: strides (*) integer(kind=c_int), intent(in), value :: dtype integer(kind=c_int), intent(in), value :: device_type integer(kind=c_int), intent(in), value :: device_index logical(kind=c_bool), intent(in), value :: requires_grad Return Value type(c_ptr) interface public  subroutine torch_tensor_divide_c(output_c, tensor1_c, tensor2_c) bind(c, name = 'torch_tensor_divide') Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: output_c type(c_ptr), intent(in), value :: tensor1_c type(c_ptr), intent(in), value :: tensor2_c public        interface torch_tensor_from_array Interface for directing torch_tensor_from_array to possible input types and ranks public  subroutine torch_tensor_from_array_int8_1d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 1 containing data of type int8 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (1) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int8_2d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 2 containing data of type int8 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (2) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int8_3d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 3 containing data of type int8 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (3) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int8_4d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 4 containing data of type int8 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (4) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int8_5d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 5 containing data of type int8 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (5) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int16_1d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 1 containing data of type int16 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (1) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int16_2d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 2 containing data of type int16 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (2) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int16_3d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 3 containing data of type int16 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (3) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int16_4d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 4 containing data of type int16 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (4) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int16_5d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 5 containing data of type int16 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (5) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int32_1d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 1 containing data of type int32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (1) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int32_2d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 2 containing data of type int32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (2) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int32_3d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 3 containing data of type int32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (3) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int32_4d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 4 containing data of type int32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (4) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int32_5d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 5 containing data of type int32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (5) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int64_1d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 1 containing data of type int64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (1) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int64_2d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 2 containing data of type int64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (2) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int64_3d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 3 containing data of type int64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (3) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int64_4d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 4 containing data of type int64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (4) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int64_5d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 5 containing data of type int64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (5) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real32_1d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 1 containing data of type real32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (1) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real32_2d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 2 containing data of type real32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (2) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real32_3d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 3 containing data of type real32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (3) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real32_4d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 4 containing data of type real32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (4) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real32_5d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 5 containing data of type real32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (5) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real64_1d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 1 containing data of type real64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (1) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real64_2d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 2 containing data of type real64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (2) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real64_3d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 3 containing data of type real64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (3) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real64_4d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 4 containing data of type real64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (4) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real64_5d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 5 containing data of type real64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (5) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int8_1d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 1 containing data of type int8 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int8_2d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 2 containing data of type int8 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int8_3d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 3 containing data of type int8 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int8_4d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 4 containing data of type int8 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int8_5d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 5 containing data of type int8 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int16_1d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 1 containing data of type int16 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int16_2d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 2 containing data of type int16 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int16_3d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 3 containing data of type int16 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int16_4d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 4 containing data of type int16 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int16_5d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 5 containing data of type int16 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int32_1d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 1 containing data of type int32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int32_2d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 2 containing data of type int32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int32_3d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 3 containing data of type int32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int32_4d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 4 containing data of type int32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int32_5d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 5 containing data of type int32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int64_1d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 1 containing data of type int64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int64_2d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 2 containing data of type int64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int64_3d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 3 containing data of type int64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int64_4d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 4 containing data of type int64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int64_5d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 5 containing data of type int64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real32_1d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 1 containing data of type real32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real32_2d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 2 containing data of type real32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real32_3d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 3 containing data of type real32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real32_4d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 4 containing data of type real32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real32_5d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 5 containing data of type real32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real64_1d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 1 containing data of type real64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real64_2d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 2 containing data of type real64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real64_3d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 3 containing data of type real64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real64_4d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 4 containing data of type real64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real64_5d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 5 containing data of type real64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor interface public  subroutine torch_tensor_multiply_c(output_c, tensor1_c, tensor2_c) bind(c, name = 'torch_tensor_multiply') Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: output_c type(c_ptr), intent(in), value :: tensor1_c type(c_ptr), intent(in), value :: tensor2_c Derived Types type, public :: torch_model Type for holding a torch neural net (nn.Module). Components Type Visibility Attributes Name Initial type(c_ptr), public :: p = c_null_ptr pointer to the neural net in memory type, public :: torch_tensor Type for holding a Torch tensor. Components Type Visibility Attributes Name Initial type(c_ptr), public :: p = c_null_ptr pointer to the tensor in memory Finalizations Procedures final :: torch_tensor_delete Type-Bound Procedures procedure, public :: get_device_index => torch_tensor_get_device_index procedure, public :: get_device_type => torch_tensor_get_device_type procedure, public :: get_dtype => torch_tensor_get_dtype procedure, public :: get_rank => torch_tensor_get_rank procedure, public :: get_shape => torch_tensor_get_shape procedure, public :: get_stride => torch_tensor_get_stride procedure, public :: requires_grad => torch_tensor_requires_grad procedure, public :: zero => torch_tensor_zero procedure, public :: zero_grad => torch_tensor_zero_grad Functions public  function torch_tensor_add (tensor1, tensor2) result(output) Overloads addition operator for two tensors. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor1 First tensor to be added type( torch_tensor ), intent(in) :: tensor2 Second tensor to be added Return Value type( torch_tensor ) Tensor to hold the sum public  function torch_tensor_divide (tensor1, tensor2) result(output) Overloads division operator for two tensors. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor1 First tensor for the division type( torch_tensor ), intent(in) :: tensor2 Second tensor for the division Return Value type( torch_tensor ) Tensor to hold the quotient public  function torch_tensor_get_device_index (self) result(device_index) Determines the device index of a tensor. Arguments Type Intent Optional Attributes Name class( torch_tensor ), intent(in) :: self Tensor to get the device index of Return Value integer(kind=c_int) Device index of tensor public  function torch_tensor_get_device_type (self) result(device_type) Returns the device type of a tensor. Arguments Type Intent Optional Attributes Name class( torch_tensor ), intent(in) :: self Tensor to get the device type of Return Value integer(kind=c_int) Device type of tensor public  function torch_tensor_get_dtype (self) result(dtype) Returns the data type of a tensor. Arguments Type Intent Optional Attributes Name class( torch_tensor ), intent(in) :: self Tensor to get the data type of Return Value integer(kind=c_int) Data type of tensor public  function torch_tensor_get_rank (self) result(rank) Determines the rank of a tensor. Arguments Type Intent Optional Attributes Name class( torch_tensor ), intent(in) :: self Tensor to get the rank of Return Value integer(kind=int32) Rank of tensor public  function torch_tensor_get_shape (self) result(sizes) Determines the shape of a tensor. Arguments Type Intent Optional Attributes Name class( torch_tensor ), intent(in) :: self Tensor to get the shape of Return Value integer(kind=c_int64_t), pointer, (:) Pointer to tensor data public  function torch_tensor_get_stride (self) result(strides) Return the strides of the tensor Arguments Type Intent Optional Attributes Name class( torch_tensor ), intent(in) :: self Tensor to get the strides of Return Value integer(kind=c_int64_t), pointer, (:) Pointer to tensor data public  function torch_tensor_multiply (tensor1, tensor2) result(output) Overloads multiplication operator for two tensors. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor1 First tensor to be multiplied type( torch_tensor ), intent(in) :: tensor2 Second tensor to be multiplied Return Value type( torch_tensor ) Tensor to hold the product public  function torch_tensor_negative (tensor) result(output) Overloads negative operator for a single tensor. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor Tensor to take the negative of Return Value type( torch_tensor ) Tensor to hold the negative values public  function torch_tensor_power_int16 (tensor, power) result(output) Overloads exponentiation operator for a tensor and a scalar of type int16 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor Tensor to take the power of integer(kind=int16), intent(in), target :: power Integer exponent Return Value type( torch_tensor ) Tensor to hold the exponentiation public  function torch_tensor_power_int32 (tensor, power) result(output) Overloads exponentiation operator for a tensor and a scalar of type int32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor Tensor to take the power of integer(kind=int32), intent(in), target :: power Integer exponent Return Value type( torch_tensor ) Tensor to hold the exponentiation public  function torch_tensor_power_int64 (tensor, power) result(output) Overloads exponentiation operator for a tensor and a scalar of type int64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor Tensor to take the power of integer(kind=int64), intent(in), target :: power Integer exponent Return Value type( torch_tensor ) Tensor to hold the exponentiation public  function torch_tensor_power_int8 (tensor, power) result(output) Overloads exponentiation operator for a tensor and a scalar of type int8 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor Tensor to take the power of integer(kind=int8), intent(in), target :: power Integer exponent Return Value type( torch_tensor ) Tensor to hold the exponentiation public  function torch_tensor_power_real32 (tensor, power) result(output) Overloads exponentiation operator for a tensor and a scalar of type real32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor Tensor to take the power of real(kind=real32), intent(in), target :: power Floating point exponent Return Value type( torch_tensor ) Tensor to hold the exponentiation public  function torch_tensor_power_real64 (tensor, power) result(output) Overloads exponentiation operator for a tensor and a scalar of type real64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor Tensor to take the power of real(kind=real64), intent(in), target :: power Floating point exponent Return Value type( torch_tensor ) Tensor to hold the exponentiation public  function torch_tensor_requires_grad (self) result(requires_grad) Determines whether a tensor requires the autograd module. Arguments Type Intent Optional Attributes Name class( torch_tensor ), intent(in) :: self Tensor to query Return Value logical Whether the tensor requires autograd public  function torch_tensor_subtract (tensor1, tensor2) result(output) Overloads subtraction operator for two tensors. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor1 First tensor for the subtraction type( torch_tensor ), intent(in) :: tensor2 Second tensor for the subtraction Return Value type( torch_tensor ) Tensor to hold the difference Subroutines public  subroutine torch_model_delete (model) Deallocates a TorchScript model Arguments Type Intent Optional Attributes Name type( torch_model ), intent(in) :: model Torch Model to deallocate public  subroutine torch_model_forward (model, input_tensors, output_tensors, requires_grad) Performs a forward pass of the model with the input tensors Arguments Type Intent Optional Attributes Name type( torch_model ), intent(in) :: model Model type( torch_tensor ), intent(in), dimension(:) :: input_tensors Array of Input tensors type( torch_tensor ), intent(in), dimension(:) :: output_tensors Returned output tensors logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_model_load (model, filename, device_type, device_index, requires_grad, is_training) Loads a TorchScript nn.module (pre-trained PyTorch model saved with TorchScript) Arguments Type Intent Optional Attributes Name type( torch_model ), intent(out) :: model Returned deserialized model character(len=*), intent(in) :: filename Filename of saved TorchScript model integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer(kind=c_int), intent(in), optional :: device_index device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor logical, intent(in), optional :: is_training Whether the model is being trained, rather than evaluated public  subroutine torch_tensor_array_delete (tensor_array) Deallocates an array of tensors. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(inout), dimension(:) :: tensor_array Array of tensors to deallocate public  subroutine torch_tensor_assign (output, input) Overloads assignment operator for tensors. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(inout) :: output Tensor to assign values to type( torch_tensor ), intent(in) :: input Tensor whose values are to be used public  subroutine torch_tensor_backward (tensor, retain_graph) Performs back-propagation on a Torch Tensor, given some external gradient. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor Tensor to compute gradients of logical, intent(in), optional :: retain_graph Should the computational graph be retained? public  subroutine torch_tensor_delete (tensor) Deallocates a tensor. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(inout) :: tensor Tensor to deallocate public  subroutine torch_tensor_empty (tensor, ndims, tensor_shape, dtype, device_type, device_index, requires_grad) Returns a tensor with uninitialised values. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=c_int), intent(in) :: ndims Number of dimensions of the tensor integer(kind=c_int64_t), intent(in) :: tensor_shape (:) Shape of the tensor integer(kind=c_int), intent(in) :: dtype Data type of the tensor integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int16_1d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 1 containing data of type int16 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (1) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int16_1d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 1 containing data of type int16 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int16_2d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 2 containing data of type int16 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (2) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int16_2d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 2 containing data of type int16 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int16_3d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 3 containing data of type int16 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (3) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int16_3d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 3 containing data of type int16 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int16_4d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 4 containing data of type int16 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (4) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int16_4d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 4 containing data of type int16 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int16_5d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 5 containing data of type int16 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (5) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int16_5d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 5 containing data of type int16 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int16), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int32_1d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 1 containing data of type int32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (1) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int32_1d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 1 containing data of type int32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int32_2d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 2 containing data of type int32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (2) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int32_2d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 2 containing data of type int32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int32_3d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 3 containing data of type int32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (3) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int32_3d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 3 containing data of type int32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int32_4d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 4 containing data of type int32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (4) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int32_4d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 4 containing data of type int32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int32_5d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 5 containing data of type int32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (5) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int32_5d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 5 containing data of type int32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int32), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int64_1d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 1 containing data of type int64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (1) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int64_1d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 1 containing data of type int64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int64_2d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 2 containing data of type int64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (2) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int64_2d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 2 containing data of type int64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int64_3d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 3 containing data of type int64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (3) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int64_3d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 3 containing data of type int64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int64_4d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 4 containing data of type int64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (4) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int64_4d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 4 containing data of type int64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int64_5d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 5 containing data of type int64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (5) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int64_5d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 5 containing data of type int64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int64), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int8_1d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 1 containing data of type int8 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (1) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int8_1d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 1 containing data of type int8 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int8_2d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 2 containing data of type int8 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (2) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int8_2d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 2 containing data of type int8 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int8_3d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 3 containing data of type int8 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (3) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int8_3d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 3 containing data of type int8 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int8_4d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 4 containing data of type int8 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (4) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int8_4d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 4 containing data of type int8 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int8_5d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 5 containing data of type int8 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (5) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_int8_5d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 5 containing data of type int8 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=int8), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real32_1d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 1 containing data of type real32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (1) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real32_1d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 1 containing data of type real32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real32_2d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 2 containing data of type real32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (2) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real32_2d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 2 containing data of type real32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real32_3d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 3 containing data of type real32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (3) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real32_3d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 3 containing data of type real32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real32_4d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 4 containing data of type real32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (4) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real32_4d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 4 containing data of type real32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real32_5d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 5 containing data of type real32 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (5) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real32_5d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 5 containing data of type real32 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real32), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real64_1d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 1 containing data of type real64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (1) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real64_1d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 1 containing data of type real64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real64_2d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 2 containing data of type real64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (2) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real64_2d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 2 containing data of type real64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real64_3d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 3 containing data of type real64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (3) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real64_3d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 3 containing data of type real64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real64_4d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 4 containing data of type real64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (4) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real64_4d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 4 containing data of type real64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real64_5d (tensor, data_in, layout, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 5 containing data of type real64 Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=ftorch_int), intent(in) :: layout (5) Control order of indices integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_array_real64_5d_default_layout (tensor, data_in, device_type, device_index, requires_grad) Return a Torch tensor pointing to data_in array of rank 5 containing data of type real64 with default layout [1, 2, ..., n]. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor real(kind=real64), intent(in), target :: data_in (:,:,:,:,:) Input data that tensor will point at integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_from_blob (tensor, data, ndims, tensor_shape, layout, dtype, device_type, device_index, requires_grad) Exposes the given data as a tensor without taking ownership of the original data.\n This routine will take an (i, j, k) array and return an (k, j, i) tensor. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor type(c_ptr), intent(in) :: data Pointer to data integer(kind=c_int), intent(in) :: ndims Number of dimensions of the tensor integer(kind=c_int64_t), intent(in) :: tensor_shape (:) Shape of the tensor integer(kind=c_int), intent(in) :: layout (:) Layout for strides for accessing data integer(kind=c_int), intent(in) :: dtype Data type of the tensor integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_get_gradient (gradient, tensor) Retrieves the gradient with respect to a Torch Tensor. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(inout) :: gradient Tensor holding the gradient type( torch_tensor ), intent(in) :: tensor Tensor to compute the gradient with respect to public  subroutine torch_tensor_mean (output, tensor) Overloads mean operator over the values in a tensor. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(inout) :: output Tensor holding the averaged values type( torch_tensor ), intent(in) :: tensor Tensor to average the values of public  subroutine torch_tensor_ones (tensor, ndims, tensor_shape, dtype, device_type, device_index, requires_grad) Returns a tensor filled with the scalar value 1. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=c_int), intent(in) :: ndims Number of dimensions of the tensor integer(kind=c_int64_t), intent(in) :: tensor_shape (:) Shape of the tensor integer(kind=c_int), intent(in) :: dtype Data type of the tensor integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor public  subroutine torch_tensor_print (tensor) Prints the contents of a tensor. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: tensor Tensor to print the contents of public  subroutine torch_tensor_sum (output, tensor) Overloads summation operator over the values in a tensor. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(inout) :: output Tensor holding the summed values type( torch_tensor ), intent(in) :: tensor Tensor to sum the values of public  subroutine torch_tensor_to (source_tensor, target_tensor, non_blocking) Moves a source_tensor tensor to a target tensor's device and dtype Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(in) :: source_tensor Source tensor to be moved type( torch_tensor ), intent(inout) :: target_tensor Target tensor with the desired device and dtype logical, intent(in), optional :: non_blocking Whether to perform asynchronous copy public  subroutine torch_tensor_zero (tensor) Fills a tensor with the scalar value 0. Arguments Type Intent Optional Attributes Name class( torch_tensor ), intent(inout) :: tensor Tensor whose values are to be zeroed public  subroutine torch_tensor_zero_grad (tensor) Resets a tensor's gradient to zero. Arguments Type Intent Optional Attributes Name class( torch_tensor ), intent(inout) :: tensor Tensor to zero the gradient of public  subroutine torch_tensor_zeros (tensor, ndims, tensor_shape, dtype, device_type, device_index, requires_grad) Returns a tensor filled with the scalar value 0. Arguments Type Intent Optional Attributes Name type( torch_tensor ), intent(out) :: tensor Returned tensor integer(kind=c_int), intent(in) :: ndims Number of dimensions of the tensor integer(kind=c_int64_t), intent(in) :: tensor_shape (:) Shape of the tensor integer(kind=c_int), intent(in) :: dtype Data type of the tensor integer(kind=c_int), intent(in) :: device_type Device type the tensor will live on ( torch_kCPU or torch_kCUDA ) integer, intent(in), optional :: device_index Device index to use for torch_kCUDA case logical, intent(in), optional :: requires_grad Whether gradients need to be computed for the created tensor","tags":"","url":"module/ftorch.html"},{"title":"ftorch_test_utils – FTorch","text":"Utils module for FTorch containing assertions for testing License\n   FTorch is released under an MIT license.\n   See the LICENSE file for details. Uses iso_fortran_env module~~ftorch_test_utils~~UsesGraph module~ftorch_test_utils ftorch_test_utils iso_fortran_env iso_fortran_env module~ftorch_test_utils->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface assert_allclose public  function assert_allclose_real32_1d (got, expect, test_name, rtol, print_result) result(test_pass) Asserts that two real32-valued 1D arrays coincide to a given relative tolerance Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: got The array of values to be tested real(kind=real32), intent(in), dimension(:) :: expect The array of expected values character(len=*), intent(in) :: test_name Name of the test being run real(kind=real32), intent(in), optional :: rtol Optional relative tolerance (defaults to 1e-5) logical, intent(in), optional :: print_result Optionally print test result to screen (defaults to .true.) Return Value logical Did the assertion pass? public  function assert_allclose_real32_2d (got, expect, test_name, rtol, print_result) result(test_pass) Asserts that two real32-valued 2D arrays coincide to a given relative tolerance Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:) :: got The array of values to be tested real(kind=real32), intent(in), dimension(:,:) :: expect The array of expected values character(len=*), intent(in) :: test_name Name of the test being run real(kind=real32), intent(in), optional :: rtol Optional relative tolerance (defaults to 1e-5) logical, intent(in), optional :: print_result Optionally print test result to screen (defaults to .true.) Return Value logical Did the assertion pass? public  function assert_allclose_real32_3d (got, expect, test_name, rtol, print_result) result(test_pass) Asserts that two real32-valued 3D arrays coincide to a given relative tolerance Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:) :: got The array of values to be tested real(kind=real32), intent(in), dimension(:,:,:) :: expect The array of expected values character(len=*), intent(in) :: test_name Name of the test being run real(kind=real32), intent(in), optional :: rtol Optional relative tolerance (defaults to 1e-5) logical, intent(in), optional :: print_result Optionally print test result to screen (defaults to .true.) Return Value logical Did the assertion pass? public  function assert_allclose_real64_1d (got, expect, test_name, rtol, print_result) result(test_pass) Asserts that two real64-valued 1D arrays coincide to a given relative tolerance Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: got The array of values to be tested real(kind=real64), intent(in), dimension(:) :: expect The array of expected values character(len=*), intent(in) :: test_name Name of the test being run real(kind=real64), intent(in), optional :: rtol Optional relative tolerance (defaults to 1e-5) logical, intent(in), optional :: print_result Optionally print test result to screen (defaults to .true.) Return Value logical Did the assertion pass? public  function assert_allclose_real64_2d (got, expect, test_name, rtol, print_result) result(test_pass) Asserts that two real64-valued 2D arrays coincide to a given relative tolerance Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: got The array of values to be tested real(kind=real64), intent(in), dimension(:,:) :: expect The array of expected values character(len=*), intent(in) :: test_name Name of the test being run real(kind=real64), intent(in), optional :: rtol Optional relative tolerance (defaults to 1e-5) logical, intent(in), optional :: print_result Optionally print test result to screen (defaults to .true.) Return Value logical Did the assertion pass? public  function assert_allclose_real64_3d (got, expect, test_name, rtol, print_result) result(test_pass) Asserts that two real64-valued 3D arrays coincide to a given relative tolerance Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:) :: got The array of values to be tested real(kind=real64), intent(in), dimension(:,:,:) :: expect The array of expected values character(len=*), intent(in) :: test_name Name of the test being run real(kind=real64), intent(in), optional :: rtol Optional relative tolerance (defaults to 1e-5) logical, intent(in), optional :: print_result Optionally print test result to screen (defaults to .true.) Return Value logical Did the assertion pass? public        interface assert_isclose public  function assert_isclose_real32 (got, expect, test_name, rtol, print_result) result(test_pass) Asserts that two real32 values coincide to a given relative tolerance Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: got The value to be tested real(kind=real32), intent(in) :: expect The expected value character(len=*), intent(in) :: test_name Name of the test being run real(kind=real32), intent(in), optional :: rtol Optional relative tolerance (defaults to 1e-5) logical, intent(in), optional :: print_result Optionally print test result to screen (defaults to .true.) Return Value logical Did the assertion pass? public  function assert_isclose_real64 (got, expect, test_name, rtol, print_result) result(test_pass) Asserts that two real64 values coincide to a given relative tolerance Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: got The value to be tested real(kind=real64), intent(in) :: expect The expected value character(len=*), intent(in) :: test_name Name of the test being run real(kind=real64), intent(in), optional :: rtol Optional relative tolerance (defaults to 1e-5) logical, intent(in), optional :: print_result Optionally print test result to screen (defaults to .true.) Return Value logical Did the assertion pass? Functions public  function assert_allclose_real32_1d (got, expect, test_name, rtol, print_result) result(test_pass) Asserts that two real32-valued 1D arrays coincide to a given relative tolerance Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: got The array of values to be tested real(kind=real32), intent(in), dimension(:) :: expect The array of expected values character(len=*), intent(in) :: test_name Name of the test being run real(kind=real32), intent(in), optional :: rtol Optional relative tolerance (defaults to 1e-5) logical, intent(in), optional :: print_result Optionally print test result to screen (defaults to .true.) Return Value logical Did the assertion pass? public  function assert_allclose_real32_2d (got, expect, test_name, rtol, print_result) result(test_pass) Asserts that two real32-valued 2D arrays coincide to a given relative tolerance Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:) :: got The array of values to be tested real(kind=real32), intent(in), dimension(:,:) :: expect The array of expected values character(len=*), intent(in) :: test_name Name of the test being run real(kind=real32), intent(in), optional :: rtol Optional relative tolerance (defaults to 1e-5) logical, intent(in), optional :: print_result Optionally print test result to screen (defaults to .true.) Return Value logical Did the assertion pass? public  function assert_allclose_real32_3d (got, expect, test_name, rtol, print_result) result(test_pass) Asserts that two real32-valued 3D arrays coincide to a given relative tolerance Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:) :: got The array of values to be tested real(kind=real32), intent(in), dimension(:,:,:) :: expect The array of expected values character(len=*), intent(in) :: test_name Name of the test being run real(kind=real32), intent(in), optional :: rtol Optional relative tolerance (defaults to 1e-5) logical, intent(in), optional :: print_result Optionally print test result to screen (defaults to .true.) Return Value logical Did the assertion pass? public  function assert_allclose_real64_1d (got, expect, test_name, rtol, print_result) result(test_pass) Asserts that two real64-valued 1D arrays coincide to a given relative tolerance Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: got The array of values to be tested real(kind=real64), intent(in), dimension(:) :: expect The array of expected values character(len=*), intent(in) :: test_name Name of the test being run real(kind=real64), intent(in), optional :: rtol Optional relative tolerance (defaults to 1e-5) logical, intent(in), optional :: print_result Optionally print test result to screen (defaults to .true.) Return Value logical Did the assertion pass? public  function assert_allclose_real64_2d (got, expect, test_name, rtol, print_result) result(test_pass) Asserts that two real64-valued 2D arrays coincide to a given relative tolerance Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: got The array of values to be tested real(kind=real64), intent(in), dimension(:,:) :: expect The array of expected values character(len=*), intent(in) :: test_name Name of the test being run real(kind=real64), intent(in), optional :: rtol Optional relative tolerance (defaults to 1e-5) logical, intent(in), optional :: print_result Optionally print test result to screen (defaults to .true.) Return Value logical Did the assertion pass? public  function assert_allclose_real64_3d (got, expect, test_name, rtol, print_result) result(test_pass) Asserts that two real64-valued 3D arrays coincide to a given relative tolerance Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:) :: got The array of values to be tested real(kind=real64), intent(in), dimension(:,:,:) :: expect The array of expected values character(len=*), intent(in) :: test_name Name of the test being run real(kind=real64), intent(in), optional :: rtol Optional relative tolerance (defaults to 1e-5) logical, intent(in), optional :: print_result Optionally print test result to screen (defaults to .true.) Return Value logical Did the assertion pass? public  function assert_isclose_real32 (got, expect, test_name, rtol, print_result) result(test_pass) Asserts that two real32 values coincide to a given relative tolerance Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: got The value to be tested real(kind=real32), intent(in) :: expect The expected value character(len=*), intent(in) :: test_name Name of the test being run real(kind=real32), intent(in), optional :: rtol Optional relative tolerance (defaults to 1e-5) logical, intent(in), optional :: print_result Optionally print test result to screen (defaults to .true.) Return Value logical Did the assertion pass? public  function assert_isclose_real64 (got, expect, test_name, rtol, print_result) result(test_pass) Asserts that two real64 values coincide to a given relative tolerance Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: got The value to be tested real(kind=real64), intent(in) :: expect The expected value character(len=*), intent(in) :: test_name Name of the test being run real(kind=real64), intent(in), optional :: rtol Optional relative tolerance (defaults to 1e-5) logical, intent(in), optional :: print_result Optionally print test result to screen (defaults to .true.) Return Value logical Did the assertion pass? Subroutines public  subroutine test_print (test_name, message, test_pass) Print the result of a test to the terminal Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: test_name Name of the test being run character(len=*), intent(in) :: message Message to print logical, intent(in) :: test_pass Result of the assertion","tags":"","url":"module/ftorch_test_utils.html"},{"title":"ftorch.F90 – FTorch","text":"Source Code !| Main module for FTorch containing types and procedures. !  Generated from `ftorch.fypp` using the [fypp Fortran preprocessor](https://fypp.readthedocs.io/en/stable/index.html). ! !  * License !    FTorch is released under an MIT license. !    See the [LICENSE](https://github.com/Cambridge-ICCS/FTorch/blob/main/LICENSE) !    file for details. module ftorch use , intrinsic :: iso_c_binding , only : c_associated , c_null_ptr , c_ptr use , intrinsic :: iso_fortran_env , only : int32 implicit none public ! Set integer size for FTorch library integer , parameter :: ftorch_int = int32 ! ============================================================================ ! --- Derived types and enums ! ============================================================================ !> Type for holding a torch neural net (nn.Module). type torch_model type ( c_ptr ) :: p = c_null_ptr !! pointer to the neural net in memory end type torch_model !> Type for holding a Torch tensor. type torch_tensor type ( c_ptr ) :: p = c_null_ptr !! pointer to the tensor in memory contains procedure :: get_rank => torch_tensor_get_rank procedure :: get_shape => torch_tensor_get_shape procedure :: get_stride => torch_tensor_get_stride procedure :: get_dtype => torch_tensor_get_dtype procedure :: get_device_type => torch_tensor_get_device_type procedure :: get_device_index => torch_tensor_get_device_index procedure :: requires_grad => torch_tensor_requires_grad procedure :: zero => torch_tensor_zero procedure :: zero_grad => torch_tensor_zero_grad final :: torch_tensor_delete end type torch_tensor !| Enumerator for Torch data types !  From c_torch.h (torch_data_t) !  Note that 0 `torch_kUInt8` and 5 `torch_kFloat16` are not sypported in Fortran enum , bind ( c ) enumerator :: torch_kUInt8 = 0 ! not supported in Fortran enumerator :: torch_kInt8 = 1 enumerator :: torch_kInt16 = 2 enumerator :: torch_kInt32 = 3 enumerator :: torch_kInt64 = 4 enumerator :: torch_kFloat16 = 5 ! not supported in Fortran enumerator :: torch_kFloat32 = 6 enumerator :: torch_kFloat64 = 7 end enum !| Enumerator for Torch devices !  From c_torch.h (torch_device_t) !  NOTE: Defined in main CMakeLists and passed via preprocessor enum , bind ( c ) enumerator :: torch_kCPU = GPU_DEVICE_NONE enumerator :: torch_kCUDA = GPU_DEVICE_CUDA enumerator :: torch_kHIP = GPU_DEVICE_HIP enumerator :: torch_kXPU = GPU_DEVICE_XPU enumerator :: torch_kMPS = GPU_DEVICE_MPS end enum ! ============================================================================ ! --- Interfaces for core FTorch procedures ! ============================================================================ !> Interface for directing `torch_tensor_from_array` to possible input types and ranks interface torch_tensor_from_array module procedure torch_tensor_from_array_int8_1d module procedure torch_tensor_from_array_int8_2d module procedure torch_tensor_from_array_int8_3d module procedure torch_tensor_from_array_int8_4d module procedure torch_tensor_from_array_int8_5d module procedure torch_tensor_from_array_int16_1d module procedure torch_tensor_from_array_int16_2d module procedure torch_tensor_from_array_int16_3d module procedure torch_tensor_from_array_int16_4d module procedure torch_tensor_from_array_int16_5d module procedure torch_tensor_from_array_int32_1d module procedure torch_tensor_from_array_int32_2d module procedure torch_tensor_from_array_int32_3d module procedure torch_tensor_from_array_int32_4d module procedure torch_tensor_from_array_int32_5d module procedure torch_tensor_from_array_int64_1d module procedure torch_tensor_from_array_int64_2d module procedure torch_tensor_from_array_int64_3d module procedure torch_tensor_from_array_int64_4d module procedure torch_tensor_from_array_int64_5d module procedure torch_tensor_from_array_real32_1d module procedure torch_tensor_from_array_real32_2d module procedure torch_tensor_from_array_real32_3d module procedure torch_tensor_from_array_real32_4d module procedure torch_tensor_from_array_real32_5d module procedure torch_tensor_from_array_real64_1d module procedure torch_tensor_from_array_real64_2d module procedure torch_tensor_from_array_real64_3d module procedure torch_tensor_from_array_real64_4d module procedure torch_tensor_from_array_real64_5d module procedure torch_tensor_from_array_int8_1d_default_layout module procedure torch_tensor_from_array_int8_2d_default_layout module procedure torch_tensor_from_array_int8_3d_default_layout module procedure torch_tensor_from_array_int8_4d_default_layout module procedure torch_tensor_from_array_int8_5d_default_layout module procedure torch_tensor_from_array_int16_1d_default_layout module procedure torch_tensor_from_array_int16_2d_default_layout module procedure torch_tensor_from_array_int16_3d_default_layout module procedure torch_tensor_from_array_int16_4d_default_layout module procedure torch_tensor_from_array_int16_5d_default_layout module procedure torch_tensor_from_array_int32_1d_default_layout module procedure torch_tensor_from_array_int32_2d_default_layout module procedure torch_tensor_from_array_int32_3d_default_layout module procedure torch_tensor_from_array_int32_4d_default_layout module procedure torch_tensor_from_array_int32_5d_default_layout module procedure torch_tensor_from_array_int64_1d_default_layout module procedure torch_tensor_from_array_int64_2d_default_layout module procedure torch_tensor_from_array_int64_3d_default_layout module procedure torch_tensor_from_array_int64_4d_default_layout module procedure torch_tensor_from_array_int64_5d_default_layout module procedure torch_tensor_from_array_real32_1d_default_layout module procedure torch_tensor_from_array_real32_2d_default_layout module procedure torch_tensor_from_array_real32_3d_default_layout module procedure torch_tensor_from_array_real32_4d_default_layout module procedure torch_tensor_from_array_real32_5d_default_layout module procedure torch_tensor_from_array_real64_1d_default_layout module procedure torch_tensor_from_array_real64_2d_default_layout module procedure torch_tensor_from_array_real64_3d_default_layout module procedure torch_tensor_from_array_real64_4d_default_layout module procedure torch_tensor_from_array_real64_5d_default_layout end interface !> Interface for deleting generic torch objects interface torch_delete module procedure torch_model_delete module procedure torch_tensor_delete module procedure torch_tensor_array_delete end interface interface function torch_from_blob_c ( data , ndims , tensor_shape , strides , dtype , & device_type , device_index , & requires_grad ) result ( tensor_p ) & bind ( c , name = 'torch_from_blob' ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_ptr implicit none ! Arguments type ( c_ptr ), value , intent ( in ) :: data integer ( c_int ), value , intent ( in ) :: ndims integer ( c_int64_t ), intent ( in ) :: tensor_shape ( * ) integer ( c_int64_t ), intent ( in ) :: strides ( * ) integer ( c_int ), value , intent ( in ) :: dtype integer ( c_int ), value , intent ( in ) :: device_type integer ( c_int ), value , intent ( in ) :: device_index logical ( c_bool ), value , intent ( in ) :: requires_grad type ( c_ptr ) :: tensor_p end function torch_from_blob_c end interface ! ============================================================================ ! --- Interfaces for overloaded operators acting on tensors ! ============================================================================ interface assignment ( = ) module procedure torch_tensor_assign end interface interface operator ( + ) module procedure torch_tensor_add end interface interface operator ( - ) module procedure torch_tensor_negative module procedure torch_tensor_subtract end interface interface operator ( * ) module procedure torch_tensor_multiply end interface interface subroutine torch_tensor_multiply_c ( output_c , tensor1_c , tensor2_c ) & bind ( c , name = 'torch_tensor_multiply' ) use , intrinsic :: iso_c_binding , only : c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: output_c type ( c_ptr ), value , intent ( in ) :: tensor1_c type ( c_ptr ), value , intent ( in ) :: tensor2_c end subroutine torch_tensor_multiply_c end interface interface operator ( / ) module procedure torch_tensor_divide end interface interface subroutine torch_tensor_divide_c ( output_c , tensor1_c , tensor2_c ) & bind ( c , name = 'torch_tensor_divide' ) use , intrinsic :: iso_c_binding , only : c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: output_c type ( c_ptr ), value , intent ( in ) :: tensor1_c type ( c_ptr ), value , intent ( in ) :: tensor2_c end subroutine torch_tensor_divide_c end interface interface operator ( ** ) module procedure torch_tensor_power_int8 module procedure torch_tensor_power_int16 module procedure torch_tensor_power_int32 module procedure torch_tensor_power_int64 module procedure torch_tensor_power_real32 module procedure torch_tensor_power_real64 end interface contains ! ============================================================================ ! --- Procedures for constructing tensors ! ============================================================================ !> Returns a tensor with uninitialised values. subroutine torch_tensor_empty ( tensor , ndims , tensor_shape , dtype , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor integer ( c_int ), intent ( in ) :: ndims !! Number of dimensions of the tensor integer ( c_int64_t ), intent ( in ) :: tensor_shape (:) !! Shape of the tensor integer ( c_int ), intent ( in ) :: dtype !! Data type of the tensor integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor integer ( c_int ) :: device_index_value !! device index used logical ( c_bool ) :: requires_grad_value !! Whether gradients need to be computed for the created tensor interface function torch_empty_c ( ndims_c , tensor_shape_c , dtype_c , device_type_c , & device_index_c , requires_grad_c ) result ( tensor_c ) & bind ( c , name = 'torch_empty' ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_ptr implicit none integer ( c_int ), value , intent ( in ) :: ndims_c integer ( c_int64_t ), intent ( in ) :: tensor_shape_c ( * ) integer ( c_int ), value , intent ( in ) :: dtype_c integer ( c_int ), value , intent ( in ) :: device_type_c integer ( c_int ), value , intent ( in ) :: device_index_c logical ( c_bool ), value , intent ( in ) :: requires_grad_c type ( c_ptr ) :: tensor_c end function torch_empty_c end interface ! Process optional arguments if ( present ( device_index )) then device_index_value = device_index else if ( device_type == torch_kCPU ) then device_index_value = - 1 else device_index_value = 0 endif if (. not . present ( requires_grad )) then requires_grad_value = logical (. false ., c_bool ) else requires_grad_value = requires_grad end if tensor % p = torch_empty_c ( ndims , tensor_shape , dtype , device_type , & device_index_value , requires_grad_value ) end subroutine torch_tensor_empty !> Returns a tensor filled with the scalar value 0. subroutine torch_tensor_zeros ( tensor , ndims , tensor_shape , dtype , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor integer ( c_int ), intent ( in ) :: ndims !! Number of dimensions of the tensor integer ( c_int64_t ), intent ( in ) :: tensor_shape (:) !! Shape of the tensor integer ( c_int ), intent ( in ) :: dtype !! Data type of the tensor integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor integer ( c_int ) :: device_index_value !! device index used logical ( c_bool ) :: requires_grad_value !! Whether gradients need to be computed for the created tensor interface function torch_zeros_c ( ndims_c , tensor_shape_c , dtype_c , & device_type_c , device_index_c , requires_grad_c ) result ( tensor_c ) & bind ( c , name = 'torch_zeros' ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_ptr implicit none integer ( c_int ), value , intent ( in ) :: ndims_c integer ( c_int64_t ), intent ( in ) :: tensor_shape_c ( * ) integer ( c_int ), value , intent ( in ) :: dtype_c integer ( c_int ), value , intent ( in ) :: device_type_c integer ( c_int ), value , intent ( in ) :: device_index_c logical ( c_bool ), value , intent ( in ) :: requires_grad_c type ( c_ptr ) :: tensor_c end function torch_zeros_c end interface ! Process optional arguments if ( present ( device_index )) then device_index_value = device_index else if ( device_type == torch_kCPU ) then device_index_value = - 1 else device_index_value = 0 endif if (. not . present ( requires_grad )) then requires_grad_value = logical (. false ., c_bool ) else requires_grad_value = requires_grad end if tensor % p = torch_zeros_c ( ndims , tensor_shape , dtype , device_type , & device_index_value , requires_grad_value ) end subroutine torch_tensor_zeros !> Returns a tensor filled with the scalar value 1. subroutine torch_tensor_ones ( tensor , ndims , tensor_shape , dtype , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor integer ( c_int ), intent ( in ) :: ndims !! Number of dimensions of the tensor integer ( c_int64_t ), intent ( in ) :: tensor_shape (:) !! Shape of the tensor integer ( c_int ), intent ( in ) :: dtype !! Data type of the tensor integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor integer ( c_int ) :: device_index_value !! device index used logical ( c_bool ) :: requires_grad_value !! Whether gradients need to be computed for the created tensor interface function torch_ones_c ( ndims_c , tensor_shape_c , dtype_c , & device_type_c , device_index_c , requires_grad_c ) result ( tensor_c ) & bind ( c , name = 'torch_ones' ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_ptr implicit none integer ( c_int ), value , intent ( in ) :: ndims_c integer ( c_int64_t ), intent ( in ) :: tensor_shape_c ( * ) integer ( c_int ), value , intent ( in ) :: dtype_c integer ( c_int ), value , intent ( in ) :: device_type_c integer ( c_int ), value , intent ( in ) :: device_index_c logical ( c_bool ), value , intent ( in ) :: requires_grad_c type ( c_ptr ) :: tensor_c end function torch_ones_c end interface ! Process optional arguments if ( present ( device_index )) then device_index_value = device_index else if ( device_type == torch_kCPU ) then device_index_value = - 1 else device_index_value = 0 endif if (. not . present ( requires_grad )) then requires_grad_value = logical (. false ., c_bool ) else requires_grad_value = requires_grad end if tensor % p = torch_ones_c ( ndims , tensor_shape , dtype , device_type , & device_index_value , requires_grad_value ) end subroutine torch_tensor_ones !| Exposes the given data as a tensor without taking ownership of the original data. !  This routine will take an (i, j, k) array and return an (k, j, i) tensor. subroutine torch_tensor_from_blob ( tensor , data , ndims , tensor_shape , layout , dtype , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_ptr type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor type ( c_ptr ), intent ( in ) :: data !! Pointer to data integer ( c_int ), intent ( in ) :: ndims !! Number of dimensions of the tensor integer ( c_int64_t ), intent ( in ) :: tensor_shape (:) !! Shape of the tensor integer ( c_int ), intent ( in ) :: layout (:) !! Layout for strides for accessing data integer ( c_int ), intent ( in ) :: dtype !! Data type of the tensor integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor integer ( c_int ) :: i !! loop index integer ( c_int64_t ) :: strides ( ndims ) !! Strides for accessing data integer ( c_int ) :: device_index_value !! device index used logical ( c_bool ) :: requires_grad_value !! Whether gradients need to be computed for the created tensor if (. not . present ( requires_grad )) then requires_grad_value = logical (. false ., c_bool ) else requires_grad_value = requires_grad end if strides (:) = 0 do i = 1 , ndims if ( i == 1 ) then strides ( layout ( i )) = 1 else strides ( layout ( i )) = strides ( layout ( i - 1 )) * tensor_shape ( layout ( i - 1 )) end if end do ! Process optional arguments if ( present ( device_index )) then device_index_value = device_index else if ( device_type == torch_kCPU ) then device_index_value = - 1 else device_index_value = 0 endif tensor % p = torch_from_blob_c ( data , ndims , tensor_shape , strides , dtype , & device_type , device_index_value , & requires_grad_value ) end subroutine torch_tensor_from_blob !> Return a Torch tensor pointing to data_in array of rank 1 containing data of type `int8` subroutine torch_tensor_from_array_int8_1d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int8 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int8 ), intent ( in ), target :: data_in (:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 1 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 1 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt8 !! Data type integer ( c_int ), parameter :: ndims = 1 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int8_1d !> Return a Torch tensor pointing to data_in array of rank 2 containing data of type `int8` subroutine torch_tensor_from_array_int8_2d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int8 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int8 ), intent ( in ), target :: data_in (:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 2 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 2 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt8 !! Data type integer ( c_int ), parameter :: ndims = 2 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int8_2d !> Return a Torch tensor pointing to data_in array of rank 3 containing data of type `int8` subroutine torch_tensor_from_array_int8_3d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int8 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int8 ), intent ( in ), target :: data_in (:,:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 3 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 3 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt8 !! Data type integer ( c_int ), parameter :: ndims = 3 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int8_3d !> Return a Torch tensor pointing to data_in array of rank 4 containing data of type `int8` subroutine torch_tensor_from_array_int8_4d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int8 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int8 ), intent ( in ), target :: data_in (:,:,:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 4 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 4 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt8 !! Data type integer ( c_int ), parameter :: ndims = 4 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int8_4d !> Return a Torch tensor pointing to data_in array of rank 5 containing data of type `int8` subroutine torch_tensor_from_array_int8_5d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int8 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int8 ), intent ( in ), target :: data_in (:,:,:,:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 5 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 5 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt8 !! Data type integer ( c_int ), parameter :: ndims = 5 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int8_5d !> Return a Torch tensor pointing to data_in array of rank 1 containing data of type `int16` subroutine torch_tensor_from_array_int16_1d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int16 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int16 ), intent ( in ), target :: data_in (:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 1 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 1 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt16 !! Data type integer ( c_int ), parameter :: ndims = 1 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int16_1d !> Return a Torch tensor pointing to data_in array of rank 2 containing data of type `int16` subroutine torch_tensor_from_array_int16_2d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int16 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int16 ), intent ( in ), target :: data_in (:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 2 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 2 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt16 !! Data type integer ( c_int ), parameter :: ndims = 2 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int16_2d !> Return a Torch tensor pointing to data_in array of rank 3 containing data of type `int16` subroutine torch_tensor_from_array_int16_3d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int16 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int16 ), intent ( in ), target :: data_in (:,:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 3 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 3 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt16 !! Data type integer ( c_int ), parameter :: ndims = 3 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int16_3d !> Return a Torch tensor pointing to data_in array of rank 4 containing data of type `int16` subroutine torch_tensor_from_array_int16_4d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int16 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int16 ), intent ( in ), target :: data_in (:,:,:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 4 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 4 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt16 !! Data type integer ( c_int ), parameter :: ndims = 4 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int16_4d !> Return a Torch tensor pointing to data_in array of rank 5 containing data of type `int16` subroutine torch_tensor_from_array_int16_5d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int16 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int16 ), intent ( in ), target :: data_in (:,:,:,:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 5 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 5 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt16 !! Data type integer ( c_int ), parameter :: ndims = 5 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int16_5d !> Return a Torch tensor pointing to data_in array of rank 1 containing data of type `int32` subroutine torch_tensor_from_array_int32_1d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int32 ), intent ( in ), target :: data_in (:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 1 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 1 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt32 !! Data type integer ( c_int ), parameter :: ndims = 1 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int32_1d !> Return a Torch tensor pointing to data_in array of rank 2 containing data of type `int32` subroutine torch_tensor_from_array_int32_2d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int32 ), intent ( in ), target :: data_in (:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 2 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 2 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt32 !! Data type integer ( c_int ), parameter :: ndims = 2 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int32_2d !> Return a Torch tensor pointing to data_in array of rank 3 containing data of type `int32` subroutine torch_tensor_from_array_int32_3d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int32 ), intent ( in ), target :: data_in (:,:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 3 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 3 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt32 !! Data type integer ( c_int ), parameter :: ndims = 3 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int32_3d !> Return a Torch tensor pointing to data_in array of rank 4 containing data of type `int32` subroutine torch_tensor_from_array_int32_4d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int32 ), intent ( in ), target :: data_in (:,:,:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 4 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 4 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt32 !! Data type integer ( c_int ), parameter :: ndims = 4 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int32_4d !> Return a Torch tensor pointing to data_in array of rank 5 containing data of type `int32` subroutine torch_tensor_from_array_int32_5d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int32 ), intent ( in ), target :: data_in (:,:,:,:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 5 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 5 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt32 !! Data type integer ( c_int ), parameter :: ndims = 5 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int32_5d !> Return a Torch tensor pointing to data_in array of rank 1 containing data of type `int64` subroutine torch_tensor_from_array_int64_1d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int64 ), intent ( in ), target :: data_in (:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 1 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 1 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt64 !! Data type integer ( c_int ), parameter :: ndims = 1 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int64_1d !> Return a Torch tensor pointing to data_in array of rank 2 containing data of type `int64` subroutine torch_tensor_from_array_int64_2d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int64 ), intent ( in ), target :: data_in (:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 2 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 2 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt64 !! Data type integer ( c_int ), parameter :: ndims = 2 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int64_2d !> Return a Torch tensor pointing to data_in array of rank 3 containing data of type `int64` subroutine torch_tensor_from_array_int64_3d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int64 ), intent ( in ), target :: data_in (:,:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 3 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 3 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt64 !! Data type integer ( c_int ), parameter :: ndims = 3 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int64_3d !> Return a Torch tensor pointing to data_in array of rank 4 containing data of type `int64` subroutine torch_tensor_from_array_int64_4d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int64 ), intent ( in ), target :: data_in (:,:,:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 4 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 4 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt64 !! Data type integer ( c_int ), parameter :: ndims = 4 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int64_4d !> Return a Torch tensor pointing to data_in array of rank 5 containing data of type `int64` subroutine torch_tensor_from_array_int64_5d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : int64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int64 ), intent ( in ), target :: data_in (:,:,:,:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 5 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 5 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kInt64 !! Data type integer ( c_int ), parameter :: ndims = 5 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_int64_5d !> Return a Torch tensor pointing to data_in array of rank 1 containing data of type `real32` subroutine torch_tensor_from_array_real32_1d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : real32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real32 ), intent ( in ), target :: data_in (:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 1 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 1 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kFloat32 !! Data type integer ( c_int ), parameter :: ndims = 1 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_real32_1d !> Return a Torch tensor pointing to data_in array of rank 2 containing data of type `real32` subroutine torch_tensor_from_array_real32_2d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : real32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real32 ), intent ( in ), target :: data_in (:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 2 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 2 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kFloat32 !! Data type integer ( c_int ), parameter :: ndims = 2 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_real32_2d !> Return a Torch tensor pointing to data_in array of rank 3 containing data of type `real32` subroutine torch_tensor_from_array_real32_3d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : real32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real32 ), intent ( in ), target :: data_in (:,:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 3 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 3 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kFloat32 !! Data type integer ( c_int ), parameter :: ndims = 3 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_real32_3d !> Return a Torch tensor pointing to data_in array of rank 4 containing data of type `real32` subroutine torch_tensor_from_array_real32_4d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : real32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real32 ), intent ( in ), target :: data_in (:,:,:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 4 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 4 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kFloat32 !! Data type integer ( c_int ), parameter :: ndims = 4 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_real32_4d !> Return a Torch tensor pointing to data_in array of rank 5 containing data of type `real32` subroutine torch_tensor_from_array_real32_5d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : real32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real32 ), intent ( in ), target :: data_in (:,:,:,:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 5 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 5 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kFloat32 !! Data type integer ( c_int ), parameter :: ndims = 5 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_real32_5d !> Return a Torch tensor pointing to data_in array of rank 1 containing data of type `real64` subroutine torch_tensor_from_array_real64_1d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : real64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real64 ), intent ( in ), target :: data_in (:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 1 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 1 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kFloat64 !! Data type integer ( c_int ), parameter :: ndims = 1 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_real64_1d !> Return a Torch tensor pointing to data_in array of rank 2 containing data of type `real64` subroutine torch_tensor_from_array_real64_2d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : real64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real64 ), intent ( in ), target :: data_in (:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 2 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 2 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kFloat64 !! Data type integer ( c_int ), parameter :: ndims = 2 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_real64_2d !> Return a Torch tensor pointing to data_in array of rank 3 containing data of type `real64` subroutine torch_tensor_from_array_real64_3d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : real64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real64 ), intent ( in ), target :: data_in (:,:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 3 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 3 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kFloat64 !! Data type integer ( c_int ), parameter :: ndims = 3 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_real64_3d !> Return a Torch tensor pointing to data_in array of rank 4 containing data of type `real64` subroutine torch_tensor_from_array_real64_4d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : real64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real64 ), intent ( in ), target :: data_in (:,:,:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 4 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 4 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kFloat64 !! Data type integer ( c_int ), parameter :: ndims = 4 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_real64_4d !> Return a Torch tensor pointing to data_in array of rank 5 containing data of type `real64` subroutine torch_tensor_from_array_real64_5d ( tensor , data_in , layout , & device_type , device_index , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t , c_loc use , intrinsic :: iso_fortran_env , only : real64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real64 ), intent ( in ), target :: data_in (:,:,:,:,:) !! Input data that tensor will point at integer ( ftorch_int ), intent ( in ) :: layout ( 5 ) !! Control order of indices integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( c_int64_t ) :: tensor_shape ( 5 ) !! Shape of the tensor integer ( c_int ), parameter :: dtype = torch_kFloat64 !! Data type integer ( c_int ), parameter :: ndims = 5 !! Number of dimension of input data tensor_shape = shape ( data_in ) call torch_tensor_from_blob ( tensor , c_loc ( data_in ), ndims , tensor_shape , & layout , dtype , device_type , device_index , & requires_grad ) end subroutine torch_tensor_from_array_real64_5d ! TODO: Avoid the following variant of torch_tensor_from_array by making the `layout` argument !       optional. The reason this has not been done already is that it would require either making !       the `device_type` argument optional (which we do not want to do) or break the API. !> Return a Torch tensor pointing to data_in array of rank 1 containing data of type `int8` with default layout [1, 2, ..., n]. subroutine torch_tensor_from_array_int8_1d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int8 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int8 ), intent ( in ), target :: data_in (:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 1 ) !! Order of indices integer ( c_int ), parameter :: ndims = 1 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int8_1d_default_layout !> Return a Torch tensor pointing to data_in array of rank 2 containing data of type `int8` with default layout [1, 2, ..., n]. subroutine torch_tensor_from_array_int8_2d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int8 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int8 ), intent ( in ), target :: data_in (:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 2 ) !! Order of indices integer ( c_int ), parameter :: ndims = 2 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int8_2d_default_layout !> Return a Torch tensor pointing to data_in array of rank 3 containing data of type `int8` with default layout [1, 2, ..., n]. subroutine torch_tensor_from_array_int8_3d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int8 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int8 ), intent ( in ), target :: data_in (:,:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 3 ) !! Order of indices integer ( c_int ), parameter :: ndims = 3 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int8_3d_default_layout !> Return a Torch tensor pointing to data_in array of rank 4 containing data of type `int8` with default layout [1, 2, ..., n]. subroutine torch_tensor_from_array_int8_4d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int8 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int8 ), intent ( in ), target :: data_in (:,:,:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 4 ) !! Order of indices integer ( c_int ), parameter :: ndims = 4 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int8_4d_default_layout !> Return a Torch tensor pointing to data_in array of rank 5 containing data of type `int8` with default layout [1, 2, ..., n]. subroutine torch_tensor_from_array_int8_5d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int8 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int8 ), intent ( in ), target :: data_in (:,:,:,:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 5 ) !! Order of indices integer ( c_int ), parameter :: ndims = 5 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int8_5d_default_layout !> Return a Torch tensor pointing to data_in array of rank 1 containing data of type `int16` with default layout [1, 2, ..., n]. subroutine torch_tensor_from_array_int16_1d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int16 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int16 ), intent ( in ), target :: data_in (:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 1 ) !! Order of indices integer ( c_int ), parameter :: ndims = 1 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int16_1d_default_layout !> Return a Torch tensor pointing to data_in array of rank 2 containing data of type `int16` with default layout [1, 2, ..., n]. subroutine torch_tensor_from_array_int16_2d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int16 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int16 ), intent ( in ), target :: data_in (:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 2 ) !! Order of indices integer ( c_int ), parameter :: ndims = 2 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int16_2d_default_layout !> Return a Torch tensor pointing to data_in array of rank 3 containing data of type `int16` with default layout [1, 2, ..., n]. subroutine torch_tensor_from_array_int16_3d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int16 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int16 ), intent ( in ), target :: data_in (:,:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 3 ) !! Order of indices integer ( c_int ), parameter :: ndims = 3 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int16_3d_default_layout !> Return a Torch tensor pointing to data_in array of rank 4 containing data of type `int16` with default layout [1, 2, ..., n]. subroutine torch_tensor_from_array_int16_4d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int16 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int16 ), intent ( in ), target :: data_in (:,:,:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 4 ) !! Order of indices integer ( c_int ), parameter :: ndims = 4 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int16_4d_default_layout !> Return a Torch tensor pointing to data_in array of rank 5 containing data of type `int16` with default layout [1, 2, ..., n]. subroutine torch_tensor_from_array_int16_5d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int16 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int16 ), intent ( in ), target :: data_in (:,:,:,:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 5 ) !! Order of indices integer ( c_int ), parameter :: ndims = 5 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int16_5d_default_layout !> Return a Torch tensor pointing to data_in array of rank 1 containing data of type `int32` with default layout [1, 2, ..., n]. subroutine torch_tensor_from_array_int32_1d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int32 ), intent ( in ), target :: data_in (:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 1 ) !! Order of indices integer ( c_int ), parameter :: ndims = 1 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int32_1d_default_layout !> Return a Torch tensor pointing to data_in array of rank 2 containing data of type `int32` with default layout [1, 2, ..., n]. subroutine torch_tensor_from_array_int32_2d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int32 ), intent ( in ), target :: data_in (:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 2 ) !! Order of indices integer ( c_int ), parameter :: ndims = 2 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int32_2d_default_layout !> Return a Torch tensor pointing to data_in array of rank 3 containing data of type `int32` with default layout [1, 2, ..., n]. subroutine torch_tensor_from_array_int32_3d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int32 ), intent ( in ), target :: data_in (:,:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 3 ) !! Order of indices integer ( c_int ), parameter :: ndims = 3 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int32_3d_default_layout !> Return a Torch tensor pointing to data_in array of rank 4 containing data of type `int32` with default layout [1, 2, ..., n]. subroutine torch_tensor_from_array_int32_4d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int32 ), intent ( in ), target :: data_in (:,:,:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 4 ) !! Order of indices integer ( c_int ), parameter :: ndims = 4 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int32_4d_default_layout !> Return a Torch tensor pointing to data_in array of rank 5 containing data of type `int32` with default layout [1, 2, ..., n]. subroutine torch_tensor_from_array_int32_5d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int32 ), intent ( in ), target :: data_in (:,:,:,:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 5 ) !! Order of indices integer ( c_int ), parameter :: ndims = 5 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int32_5d_default_layout !> Return a Torch tensor pointing to data_in array of rank 1 containing data of type `int64` with default layout [1, 2, ..., n]. subroutine torch_tensor_from_array_int64_1d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int64 ), intent ( in ), target :: data_in (:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 1 ) !! Order of indices integer ( c_int ), parameter :: ndims = 1 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int64_1d_default_layout !> Return a Torch tensor pointing to data_in array of rank 2 containing data of type `int64` with default layout [1, 2, ..., n]. subroutine torch_tensor_from_array_int64_2d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int64 ), intent ( in ), target :: data_in (:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 2 ) !! Order of indices integer ( c_int ), parameter :: ndims = 2 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int64_2d_default_layout !> Return a Torch tensor pointing to data_in array of rank 3 containing data of type `int64` with default layout [1, 2, ..., n]. subroutine torch_tensor_from_array_int64_3d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int64 ), intent ( in ), target :: data_in (:,:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 3 ) !! Order of indices integer ( c_int ), parameter :: ndims = 3 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int64_3d_default_layout !> Return a Torch tensor pointing to data_in array of rank 4 containing data of type `int64` with default layout [1, 2, ..., n]. subroutine torch_tensor_from_array_int64_4d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int64 ), intent ( in ), target :: data_in (:,:,:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 4 ) !! Order of indices integer ( c_int ), parameter :: ndims = 4 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int64_4d_default_layout !> Return a Torch tensor pointing to data_in array of rank 5 containing data of type `int64` with default layout [1, 2, ..., n]. subroutine torch_tensor_from_array_int64_5d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : int64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs integer ( kind = int64 ), intent ( in ), target :: data_in (:,:,:,:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 5 ) !! Order of indices integer ( c_int ), parameter :: ndims = 5 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_int64_5d_default_layout !> Return a Torch tensor pointing to data_in array of rank 1 containing data of type `real32` with default layout [1, 2, ..., n]. subroutine torch_tensor_from_array_real32_1d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : real32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real32 ), intent ( in ), target :: data_in (:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 1 ) !! Order of indices integer ( c_int ), parameter :: ndims = 1 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_real32_1d_default_layout !> Return a Torch tensor pointing to data_in array of rank 2 containing data of type `real32` with default layout [1, 2, ..., n]. subroutine torch_tensor_from_array_real32_2d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : real32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real32 ), intent ( in ), target :: data_in (:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 2 ) !! Order of indices integer ( c_int ), parameter :: ndims = 2 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_real32_2d_default_layout !> Return a Torch tensor pointing to data_in array of rank 3 containing data of type `real32` with default layout [1, 2, ..., n]. subroutine torch_tensor_from_array_real32_3d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : real32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real32 ), intent ( in ), target :: data_in (:,:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 3 ) !! Order of indices integer ( c_int ), parameter :: ndims = 3 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_real32_3d_default_layout !> Return a Torch tensor pointing to data_in array of rank 4 containing data of type `real32` with default layout [1, 2, ..., n]. subroutine torch_tensor_from_array_real32_4d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : real32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real32 ), intent ( in ), target :: data_in (:,:,:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 4 ) !! Order of indices integer ( c_int ), parameter :: ndims = 4 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_real32_4d_default_layout !> Return a Torch tensor pointing to data_in array of rank 5 containing data of type `real32` with default layout [1, 2, ..., n]. subroutine torch_tensor_from_array_real32_5d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : real32 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real32 ), intent ( in ), target :: data_in (:,:,:,:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 5 ) !! Order of indices integer ( c_int ), parameter :: ndims = 5 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_real32_5d_default_layout !> Return a Torch tensor pointing to data_in array of rank 1 containing data of type `real64` with default layout [1, 2, ..., n]. subroutine torch_tensor_from_array_real64_1d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : real64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real64 ), intent ( in ), target :: data_in (:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 1 ) !! Order of indices integer ( c_int ), parameter :: ndims = 1 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_real64_1d_default_layout !> Return a Torch tensor pointing to data_in array of rank 2 containing data of type `real64` with default layout [1, 2, ..., n]. subroutine torch_tensor_from_array_real64_2d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : real64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real64 ), intent ( in ), target :: data_in (:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 2 ) !! Order of indices integer ( c_int ), parameter :: ndims = 2 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_real64_2d_default_layout !> Return a Torch tensor pointing to data_in array of rank 3 containing data of type `real64` with default layout [1, 2, ..., n]. subroutine torch_tensor_from_array_real64_3d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : real64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real64 ), intent ( in ), target :: data_in (:,:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 3 ) !! Order of indices integer ( c_int ), parameter :: ndims = 3 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_real64_3d_default_layout !> Return a Torch tensor pointing to data_in array of rank 4 containing data of type `real64` with default layout [1, 2, ..., n]. subroutine torch_tensor_from_array_real64_4d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : real64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real64 ), intent ( in ), target :: data_in (:,:,:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 4 ) !! Order of indices integer ( c_int ), parameter :: ndims = 4 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_real64_4d_default_layout !> Return a Torch tensor pointing to data_in array of rank 5 containing data of type `real64` with default layout [1, 2, ..., n]. subroutine torch_tensor_from_array_real64_5d_default_layout ( tensor , data_in , & device_type , device_index , & requires_grad ) use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : real64 ! output tensor type ( torch_tensor ), intent ( out ) :: tensor !! Returned tensor ! inputs real ( kind = real64 ), intent ( in ), target :: data_in (:,:,:,:,:) !! Input data that tensor will point at integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer , optional , intent ( in ) :: device_index !! Device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor ! local data integer ( ftorch_int ) :: layout ( 5 ) !! Order of indices integer ( c_int ), parameter :: ndims = 5 !! Number of dimension of input data integer :: i ! Set the default tensor layout do i = 1 , ndims layout ( i ) = i end do call torch_tensor_from_array ( tensor , data_in , layout , device_type , device_index , requires_grad ) end subroutine torch_tensor_from_array_real64_5d_default_layout ! ============================================================================ ! --- Procedures for interrogating tensors ! ============================================================================ !> Prints the contents of a tensor. subroutine torch_tensor_print ( tensor ) type ( torch_tensor ), intent ( in ) :: tensor !! Tensor to print the contents of interface subroutine torch_tensor_print_c ( tensor_c ) & bind ( c , name = 'torch_tensor_print' ) use , intrinsic :: iso_c_binding , only : c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: tensor_c end subroutine torch_tensor_print_c end interface call torch_tensor_print_c ( tensor % p ) end subroutine torch_tensor_print !> Determines the rank of a tensor. function torch_tensor_get_rank ( self ) result ( rank ) class ( torch_tensor ), intent ( in ) :: self !! Tensor to get the rank of integer ( kind = int32 ) :: rank !! Rank of tensor interface function torch_tensor_get_rank_c ( tensor_c ) result ( rank_c ) & bind ( c , name = 'torch_tensor_get_rank' ) use , intrinsic :: iso_c_binding , only : c_int , c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: tensor_c integer ( c_int ) :: rank_c end function torch_tensor_get_rank_c end interface if (. not . c_associated ( self % p )) then write ( * , * ) \"Error :: tensor has not been constructed so its rank is unset\" stop 1 end if rank = torch_tensor_get_rank_c ( self % p ) end function torch_tensor_get_rank !> Determines the shape of a tensor. function torch_tensor_get_shape ( self ) result ( sizes ) use , intrinsic :: iso_c_binding , only : c_f_pointer , c_int , c_int64_t , c_ptr class ( torch_tensor ), intent ( in ) :: self !! Tensor to get the shape of integer ( kind = c_int64_t ), pointer :: sizes (:) !! Pointer to tensor data ! Local data integer ( kind = int32 ) :: ndims ( 1 ) type ( c_ptr ) :: cptr interface function torch_tensor_get_sizes_c ( tensor_c ) result ( sizes_c ) & bind ( c , name = 'torch_tensor_get_sizes' ) use , intrinsic :: iso_c_binding , only : c_int , c_long , c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: tensor_c type ( c_ptr ) :: sizes_c end function torch_tensor_get_sizes_c end interface if (. not . c_associated ( self % p )) then write ( * , * ) \"Error :: tensor has not been constructed so its shape is unset\" stop 1 end if ndims ( 1 ) = self % get_rank () cptr = torch_tensor_get_sizes_c ( self % p ) call c_f_pointer ( cptr , sizes , ndims ) end function torch_tensor_get_shape !> Return the strides of the tensor function torch_tensor_get_stride ( self ) result ( strides ) use , intrinsic :: iso_c_binding , only : c_f_pointer , c_int , c_int64_t , c_ptr class ( torch_tensor ), intent ( in ) :: self !! Tensor to get the strides of integer ( kind = c_int64_t ), pointer :: strides (:) !! Pointer to tensor data ! Local data integer ( kind = int32 ) :: ndims ( 1 ) type ( c_ptr ) :: cptr interface function torch_tensor_get_stride_c ( tensor_c ) result ( strides_c ) & bind ( c , name = 'torch_tensor_get_stride' ) use , intrinsic :: iso_c_binding , only : c_int , c_long , c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: tensor_c type ( c_ptr ) :: strides_c end function torch_tensor_get_stride_c end interface if (. not . c_associated ( self % p )) then write ( * , * ) \"Error :: tensor has not been constructed so its strides are unset\" stop 1 end if ndims ( 1 ) = self % get_rank () cptr = torch_tensor_get_stride_c ( self % p ) call c_f_pointer ( cptr , strides , ndims ) end function torch_tensor_get_stride !> Returns the data type of a tensor. function torch_tensor_get_dtype ( self ) result ( dtype ) use , intrinsic :: iso_c_binding , only : c_int class ( torch_tensor ), intent ( in ) :: self !! Tensor to get the data type of integer ( c_int ) :: dtype !! Data type of tensor interface function torch_tensor_get_dtype_c ( tensor_c ) result ( dtype_c ) & bind ( c , name = 'torch_tensor_get_dtype' ) use , intrinsic :: iso_c_binding , only : c_int , c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: tensor_c integer ( c_int ) :: dtype_c end function torch_tensor_get_dtype_c end interface if (. not . c_associated ( self % p )) then write ( * , * ) \"Error :: tensor has not been constructed so its data type is unset\" stop 1 end if dtype = torch_tensor_get_dtype_c ( self % p ) end function torch_tensor_get_dtype !> Returns the device type of a tensor. function torch_tensor_get_device_type ( self ) result ( device_type ) use , intrinsic :: iso_c_binding , only : c_int class ( torch_tensor ), intent ( in ) :: self !! Tensor to get the device type of integer ( c_int ) :: device_type !! Device type of tensor interface function torch_tensor_get_device_type_c ( tensor_c ) result ( device_type_c ) & bind ( c , name = 'torch_tensor_get_device_type' ) use , intrinsic :: iso_c_binding , only : c_int , c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: tensor_c integer ( c_int ) :: device_type_c end function torch_tensor_get_device_type_c end interface if (. not . c_associated ( self % p )) then write ( * , * ) \"Error :: tensor has not been constructed so its device type is unset\" stop 1 end if device_type = torch_tensor_get_device_type_c ( self % p ) end function torch_tensor_get_device_type !> Determines the device index of a tensor. function torch_tensor_get_device_index ( self ) result ( device_index ) use , intrinsic :: iso_c_binding , only : c_int class ( torch_tensor ), intent ( in ) :: self !! Tensor to get the device index of integer ( c_int ) :: device_index !! Device index of tensor interface function torch_tensor_get_device_index_c ( tensor_c ) result ( device_index_c ) & bind ( c , name = 'torch_tensor_get_device_index' ) use , intrinsic :: iso_c_binding , only : c_int , c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: tensor_c integer ( c_int ) :: device_index_c end function torch_tensor_get_device_index_c end interface if (. not . c_associated ( self % p )) then write ( * , * ) \"Error :: tensor has not been constructed so its device index is unset\" stop 1 end if device_index = torch_tensor_get_device_index_c ( self % p ) end function torch_tensor_get_device_index !> Determines whether a tensor requires the autograd module. function torch_tensor_requires_grad ( self ) result ( requires_grad ) class ( torch_tensor ), intent ( in ) :: self !! Tensor to query logical :: requires_grad !! Whether the tensor requires autograd interface function torch_tensor_requires_grad_c ( tensor_c ) result ( requires_grad_c ) & bind ( c , name = 'torch_tensor_requires_grad' ) use , intrinsic :: iso_c_binding , only : c_bool , c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: tensor_c logical ( c_bool ) :: requires_grad_c end function torch_tensor_requires_grad_c end interface requires_grad = torch_tensor_requires_grad_c ( self % p ) end function torch_tensor_requires_grad ! ============================================================================ ! --- Procedures for deallocating tensors ! ============================================================================ !> Deallocates an array of tensors. subroutine torch_tensor_array_delete ( tensor_array ) type ( torch_tensor ), dimension (:), intent ( inout ) :: tensor_array !! Array of tensors to deallocate ! Local data integer ( ftorch_int ) :: i ! use bounds rather than (1, N) because it's safer do i = lbound ( tensor_array , dim = 1 ), ubound ( tensor_array , dim = 1 ) call torch_tensor_delete ( tensor_array ( i )) end do end subroutine torch_tensor_array_delete !> Deallocates a tensor. subroutine torch_tensor_delete ( tensor ) use , intrinsic :: iso_c_binding , only : c_associated , c_null_ptr type ( torch_tensor ), intent ( inout ) :: tensor !! Tensor to deallocate interface subroutine torch_tensor_delete_c ( tensor_c ) & bind ( c , name = 'torch_tensor_delete' ) use , intrinsic :: iso_c_binding , only : c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: tensor_c end subroutine torch_tensor_delete_c end interface ! Call the destructor, if it hasn't already been called if ( c_associated ( tensor % p )) then call torch_tensor_delete_c ( tensor % p ) tensor % p = c_null_ptr end if end subroutine torch_tensor_delete ! ============================================================================ ! --- Procedures for manipulating tensors ! ============================================================================ !> Fills a tensor with the scalar value 0. subroutine torch_tensor_zero ( tensor ) use , intrinsic :: iso_c_binding , only : c_associated class ( torch_tensor ), intent ( inout ) :: tensor !! Tensor whose values are to be zeroed interface subroutine torch_tensor_zero_c ( tensor_c ) bind ( c , name = 'torch_tensor_zero' ) use , intrinsic :: iso_c_binding , only : c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: tensor_c end subroutine torch_tensor_zero_c end interface if (. not . c_associated ( tensor % p )) then write ( * , * ) \"Error :: tensor must be constructed before zeroing values\" stop 1 end if call torch_tensor_zero_c ( tensor % p ) end subroutine torch_tensor_zero !> Moves a source_tensor tensor to a target tensor's device and dtype subroutine torch_tensor_to ( source_tensor , target_tensor , non_blocking ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_int64_t type ( torch_tensor ), intent ( in ) :: source_tensor !! Source tensor to be moved type ( torch_tensor ), intent ( inout ) :: target_tensor !! Target tensor with the desired device and dtype logical , optional , intent ( in ) :: non_blocking !! Whether to perform asynchronous copy logical ( c_bool ) :: non_blocking_value integer ( c_int ) :: source_rank , target_rank , i integer ( c_int64_t ), pointer :: source_shape (:), target_shape (:) interface subroutine torch_tensor_to_c ( source_tensor_c , target_tensor_c , non_blocking_c ) & bind ( c , name = 'torch_tensor_to' ) use , intrinsic :: iso_c_binding , only : c_bool , c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: source_tensor_c type ( c_ptr ), value , intent ( in ) :: target_tensor_c logical ( c_bool ), value , intent ( in ) :: non_blocking_c end subroutine torch_tensor_to_c end interface ! Check for rank and shape consistency between the source and target tensors source_rank = source_tensor % get_rank () target_rank = target_tensor % get_rank () if ( source_rank /= target_rank ) then write ( * , * ) \"Error in torch_tensor_to :: Cannot move source_tensor to target_tensor because the ranks do not match.\" write ( * , * ) \"Source tensor rank:\" , source_rank , \"Target tensor rank:\" , target_rank stop 1 end if source_shape => source_tensor % get_shape () target_shape => target_tensor % get_shape () do i = 1 , source_rank if ( source_shape ( i ) /= target_shape ( i )) then write ( * , * ) \"Error in torch_tensor_to :: Cannot move source_tensor to target_tensor because the shapes do not match.\" write ( * , * ) \"Dimension\" , i , \"mismatch: source_tensor =\" , source_shape ( i ), & \"Target =\" , target_shape ( i ) stop 1 end if end do ! Process optional arguments if ( present ( non_blocking )) then non_blocking_value = non_blocking else non_blocking_value = . false . end if call torch_tensor_to_c ( source_tensor % p , target_tensor % p , non_blocking_value ) end subroutine torch_tensor_to ! ============================================================================ ! --- Overloaded operators acting on tensors ! ============================================================================ !> Overloads assignment operator for tensors. subroutine torch_tensor_assign ( output , input ) use , intrinsic :: iso_c_binding , only : c_associated type ( torch_tensor ), intent ( in ) :: input !! Tensor whose values are to be used type ( torch_tensor ), intent ( inout ) :: output !! Tensor to assign values to interface subroutine torch_tensor_assign_c ( output_c , input_c ) bind ( c , name = 'torch_tensor_assign' ) use , intrinsic :: iso_c_binding , only : c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: output_c type ( c_ptr ), value , intent ( in ) :: input_c end subroutine torch_tensor_assign_c end interface if (. not . c_associated ( output % p )) then call torch_tensor_empty ( output , input % get_rank (), input % get_shape (), input % get_dtype (), & input % get_device_type (), device_index = input % get_device_index (), & requires_grad = input % requires_grad ()) else if ( input % get_device_type () /= output % get_device_type ()) then write ( * , * ) \"Error :: cannot assign tensors with different device types\" stop 1 end if call torch_tensor_assign_c ( output % p , input % p ) end subroutine torch_tensor_assign !> Overloads addition operator for two tensors. function torch_tensor_add ( tensor1 , tensor2 ) result ( output ) use , intrinsic :: iso_c_binding , only : c_associated type ( torch_tensor ), intent ( in ) :: tensor1 !! First tensor to be added type ( torch_tensor ), intent ( in ) :: tensor2 !! Second tensor to be added type ( torch_tensor ) :: output !! Tensor to hold the sum interface subroutine torch_tensor_add_c ( output_c , tensor1_c , tensor2_c ) & bind ( c , name = 'torch_tensor_add' ) use , intrinsic :: iso_c_binding , only : c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: tensor1_c type ( c_ptr ), value , intent ( in ) :: tensor2_c type ( c_ptr ), value , intent ( in ) :: output_c end subroutine torch_tensor_add_c end interface if ( tensor1 % get_device_type () /= tensor2 % get_device_type ()) then write ( * , * ) \"Error :: cannot add tensors with different device types\" stop 1 end if if (. not . c_associated ( output % p )) then call torch_tensor_empty ( output , tensor1 % get_rank (), tensor1 % get_shape (), & tensor1 % get_dtype (), tensor1 % get_device_type (), & device_index = tensor1 % get_device_index (), & requires_grad = tensor1 % requires_grad ()) end if call torch_tensor_add_c ( output % p , tensor1 % p , tensor2 % p ) end function torch_tensor_add !> Overloads negative operator for a single tensor. function torch_tensor_negative ( tensor ) result ( output ) use , intrinsic :: iso_c_binding , only : c_associated type ( torch_tensor ), intent ( in ) :: tensor !! Tensor to take the negative of type ( torch_tensor ) :: output !! Tensor to hold the negative values interface subroutine torch_tensor_negative_c ( output_c , tensor_c ) bind ( c , name = 'torch_tensor_negative' ) use , intrinsic :: iso_c_binding , only : c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: tensor_c type ( c_ptr ), value , intent ( in ) :: output_c end subroutine torch_tensor_negative_c end interface if (. not . c_associated ( output % p )) then call torch_tensor_empty ( output , tensor % get_rank (), tensor % get_shape (), tensor % get_dtype (), & tensor % get_device_type (), device_index = tensor % get_device_index (), & requires_grad = tensor % requires_grad ()) end if call torch_tensor_negative_c ( output % p , tensor % p ) end function torch_tensor_negative !> Overloads subtraction operator for two tensors. function torch_tensor_subtract ( tensor1 , tensor2 ) result ( output ) use , intrinsic :: iso_c_binding , only : c_associated type ( torch_tensor ), intent ( in ) :: tensor1 !! First tensor for the subtraction type ( torch_tensor ), intent ( in ) :: tensor2 !! Second tensor for the subtraction type ( torch_tensor ) :: output !! Tensor to hold the difference interface subroutine torch_tensor_subtract_c ( output_c , tensor1_c , tensor2_c ) & bind ( c , name = 'torch_tensor_subtract' ) use , intrinsic :: iso_c_binding , only : c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: output_c type ( c_ptr ), value , intent ( in ) :: tensor1_c type ( c_ptr ), value , intent ( in ) :: tensor2_c end subroutine torch_tensor_subtract_c end interface if ( tensor1 % get_device_type () /= tensor2 % get_device_type ()) then write ( * , * ) \"Error :: cannot subtract tensors with different device types\" stop 1 end if if (. not . c_associated ( output % p )) then call torch_tensor_empty ( output , tensor1 % get_rank (), tensor1 % get_shape (), & tensor1 % get_dtype (), tensor1 % get_device_type (), & device_index = tensor1 % get_device_index (), & requires_grad = tensor1 % requires_grad ()) end if call torch_tensor_subtract_c ( output % p , tensor1 % p , tensor2 % p ) end function torch_tensor_subtract !> Overloads multiplication operator for two tensors. function torch_tensor_multiply ( tensor1 , tensor2 ) result ( output ) use , intrinsic :: iso_c_binding , only : c_associated type ( torch_tensor ), intent ( in ) :: tensor1 !! First tensor to be multiplied type ( torch_tensor ), intent ( in ) :: tensor2 !! Second tensor to be multiplied type ( torch_tensor ) :: output !! Tensor to hold the product if ( tensor1 % get_device_type () /= tensor2 % get_device_type ()) then write ( * , * ) \"Error :: cannot multiply tensors with different device types\" stop 1 end if if (. not . c_associated ( output % p )) then call torch_tensor_empty ( output , tensor1 % get_rank (), tensor1 % get_shape (), & tensor1 % get_dtype (), tensor1 % get_device_type (), & device_index = tensor1 % get_device_index (), & requires_grad = tensor1 % requires_grad ()) end if call torch_tensor_multiply_c ( output % p , tensor1 % p , tensor2 % p ) end function torch_tensor_multiply !> Overloads division operator for two tensors. function torch_tensor_divide ( tensor1 , tensor2 ) result ( output ) use , intrinsic :: iso_c_binding , only : c_associated type ( torch_tensor ), intent ( in ) :: tensor1 !! First tensor for the division type ( torch_tensor ), intent ( in ) :: tensor2 !! Second tensor for the division type ( torch_tensor ) :: output !! Tensor to hold the quotient if ( tensor1 % get_device_type () /= tensor2 % get_device_type ()) then write ( * , * ) \"Error :: cannot divide tensors with different device types\" stop 1 end if if (. not . c_associated ( output % p )) then call torch_tensor_empty ( output , tensor1 % get_rank (), tensor1 % get_shape (), & tensor1 % get_dtype (), tensor1 % get_device_type (), & device_index = tensor1 % get_device_index (), & requires_grad = tensor1 % requires_grad ()) end if call torch_tensor_divide_c ( output % p , tensor1 % p , tensor2 % p ) end function torch_tensor_divide !> Overloads exponentiation operator for a tensor and a scalar of type `int8` function torch_tensor_power_int8 ( tensor , power ) result ( output ) use , intrinsic :: iso_c_binding , only : c_associated , c_loc use , intrinsic :: iso_fortran_env , only : int8 type ( torch_tensor ), intent ( in ) :: tensor !! Tensor to take the power of integer ( int8 ), target , intent ( in ) :: power !! Integer exponent type ( torch_tensor ) :: output !! Tensor to hold the exponentiation interface subroutine torch_tensor_power_int_c ( output_c , tensor_c , power_c ) & bind ( c , name = 'torch_tensor_power_int' ) use , intrinsic :: iso_c_binding , only : c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: output_c type ( c_ptr ), value , intent ( in ) :: tensor_c type ( c_ptr ), value , intent ( in ) :: power_c end subroutine torch_tensor_power_int_c end interface if (. not . c_associated ( output % p )) then call torch_tensor_empty ( output , tensor % get_rank (), tensor % get_shape (), tensor % get_dtype (), & tensor % get_device_type (), device_index = tensor % get_device_index (), & requires_grad = tensor % requires_grad ()) end if call torch_tensor_power_int_c ( output % p , tensor % p , c_loc ( power )) end function torch_tensor_power_int8 !> Overloads exponentiation operator for a tensor and a scalar of type `int16` function torch_tensor_power_int16 ( tensor , power ) result ( output ) use , intrinsic :: iso_c_binding , only : c_associated , c_loc use , intrinsic :: iso_fortran_env , only : int16 type ( torch_tensor ), intent ( in ) :: tensor !! Tensor to take the power of integer ( int16 ), target , intent ( in ) :: power !! Integer exponent type ( torch_tensor ) :: output !! Tensor to hold the exponentiation interface subroutine torch_tensor_power_int_c ( output_c , tensor_c , power_c ) & bind ( c , name = 'torch_tensor_power_int' ) use , intrinsic :: iso_c_binding , only : c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: output_c type ( c_ptr ), value , intent ( in ) :: tensor_c type ( c_ptr ), value , intent ( in ) :: power_c end subroutine torch_tensor_power_int_c end interface if (. not . c_associated ( output % p )) then call torch_tensor_empty ( output , tensor % get_rank (), tensor % get_shape (), tensor % get_dtype (), & tensor % get_device_type (), device_index = tensor % get_device_index (), & requires_grad = tensor % requires_grad ()) end if call torch_tensor_power_int_c ( output % p , tensor % p , c_loc ( power )) end function torch_tensor_power_int16 !> Overloads exponentiation operator for a tensor and a scalar of type `int32` function torch_tensor_power_int32 ( tensor , power ) result ( output ) use , intrinsic :: iso_c_binding , only : c_associated , c_loc use , intrinsic :: iso_fortran_env , only : int32 type ( torch_tensor ), intent ( in ) :: tensor !! Tensor to take the power of integer ( int32 ), target , intent ( in ) :: power !! Integer exponent type ( torch_tensor ) :: output !! Tensor to hold the exponentiation interface subroutine torch_tensor_power_int_c ( output_c , tensor_c , power_c ) & bind ( c , name = 'torch_tensor_power_int' ) use , intrinsic :: iso_c_binding , only : c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: output_c type ( c_ptr ), value , intent ( in ) :: tensor_c type ( c_ptr ), value , intent ( in ) :: power_c end subroutine torch_tensor_power_int_c end interface if (. not . c_associated ( output % p )) then call torch_tensor_empty ( output , tensor % get_rank (), tensor % get_shape (), tensor % get_dtype (), & tensor % get_device_type (), device_index = tensor % get_device_index (), & requires_grad = tensor % requires_grad ()) end if call torch_tensor_power_int_c ( output % p , tensor % p , c_loc ( power )) end function torch_tensor_power_int32 !> Overloads exponentiation operator for a tensor and a scalar of type `int64` function torch_tensor_power_int64 ( tensor , power ) result ( output ) use , intrinsic :: iso_c_binding , only : c_associated , c_loc use , intrinsic :: iso_fortran_env , only : int64 type ( torch_tensor ), intent ( in ) :: tensor !! Tensor to take the power of integer ( int64 ), target , intent ( in ) :: power !! Integer exponent type ( torch_tensor ) :: output !! Tensor to hold the exponentiation interface subroutine torch_tensor_power_int_c ( output_c , tensor_c , power_c ) & bind ( c , name = 'torch_tensor_power_int' ) use , intrinsic :: iso_c_binding , only : c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: output_c type ( c_ptr ), value , intent ( in ) :: tensor_c type ( c_ptr ), value , intent ( in ) :: power_c end subroutine torch_tensor_power_int_c end interface if (. not . c_associated ( output % p )) then call torch_tensor_empty ( output , tensor % get_rank (), tensor % get_shape (), tensor % get_dtype (), & tensor % get_device_type (), device_index = tensor % get_device_index (), & requires_grad = tensor % requires_grad ()) end if call torch_tensor_power_int_c ( output % p , tensor % p , c_loc ( power )) end function torch_tensor_power_int64 !> Overloads exponentiation operator for a tensor and a scalar of type `real32` function torch_tensor_power_real32 ( tensor , power ) result ( output ) use , intrinsic :: iso_c_binding , only : c_associated , c_loc use , intrinsic :: iso_fortran_env , only : real32 type ( torch_tensor ), intent ( in ) :: tensor !! Tensor to take the power of real ( kind = real32 ), target , intent ( in ) :: power !! Floating point exponent type ( torch_tensor ) :: output !! Tensor to hold the exponentiation interface subroutine torch_tensor_power_float_c ( output_c , tensor_c , power_c ) & bind ( c , name = 'torch_tensor_power_float' ) use , intrinsic :: iso_c_binding , only : c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: output_c type ( c_ptr ), value , intent ( in ) :: tensor_c type ( c_ptr ), value , intent ( in ) :: power_c end subroutine torch_tensor_power_float_c end interface if (. not . c_associated ( output % p )) then call torch_tensor_empty ( output , tensor % get_rank (), tensor % get_shape (), tensor % get_dtype (), & tensor % get_device_type (), device_index = tensor % get_device_index (), & requires_grad = tensor % requires_grad ()) end if call torch_tensor_power_float_c ( output % p , tensor % p , c_loc ( power )) end function torch_tensor_power_real32 !> Overloads exponentiation operator for a tensor and a scalar of type `real64` function torch_tensor_power_real64 ( tensor , power ) result ( output ) use , intrinsic :: iso_c_binding , only : c_associated , c_loc use , intrinsic :: iso_fortran_env , only : real64 type ( torch_tensor ), intent ( in ) :: tensor !! Tensor to take the power of real ( kind = real64 ), target , intent ( in ) :: power !! Floating point exponent type ( torch_tensor ) :: output !! Tensor to hold the exponentiation interface subroutine torch_tensor_power_float_c ( output_c , tensor_c , power_c ) & bind ( c , name = 'torch_tensor_power_float' ) use , intrinsic :: iso_c_binding , only : c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: output_c type ( c_ptr ), value , intent ( in ) :: tensor_c type ( c_ptr ), value , intent ( in ) :: power_c end subroutine torch_tensor_power_float_c end interface if (. not . c_associated ( output % p )) then call torch_tensor_empty ( output , tensor % get_rank (), tensor % get_shape (), tensor % get_dtype (), & tensor % get_device_type (), device_index = tensor % get_device_index (), & requires_grad = tensor % requires_grad ()) end if call torch_tensor_power_float_c ( output % p , tensor % p , c_loc ( power )) end function torch_tensor_power_real64 ! ============================================================================ ! --- Other operators for computations involving tensors ! ============================================================================ !> Overloads summation operator over the values in a tensor. subroutine torch_tensor_sum ( output , tensor ) use , intrinsic :: iso_c_binding , only : c_associated type ( torch_tensor ), intent ( inout ) :: output !! Tensor holding the summed values type ( torch_tensor ), intent ( in ) :: tensor !! Tensor to sum the values of interface subroutine torch_tensor_sum_c ( output_c , tensor_c ) & bind ( c , name = 'torch_tensor_sum' ) use , intrinsic :: iso_c_binding , only : c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: output_c type ( c_ptr ), value , intent ( in ) :: tensor_c end subroutine torch_tensor_sum_c end interface if (. not . c_associated ( output % p )) then write ( * , * ) \"Error :: output tensor has not been constructed\" stop 1 end if call torch_tensor_sum_c ( output % p , tensor % p ) end subroutine torch_tensor_sum !> Overloads mean operator over the values in a tensor. subroutine torch_tensor_mean ( output , tensor ) use , intrinsic :: iso_c_binding , only : c_associated type ( torch_tensor ), intent ( inout ) :: output !! Tensor holding the averaged values type ( torch_tensor ), intent ( in ) :: tensor !! Tensor to average the values of interface subroutine torch_tensor_mean_c ( output_c , tensor_c ) & bind ( c , name = 'torch_tensor_mean' ) use , intrinsic :: iso_c_binding , only : c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: output_c type ( c_ptr ), value , intent ( in ) :: tensor_c end subroutine torch_tensor_mean_c end interface if (. not . c_associated ( output % p )) then write ( * , * ) \"Error :: output tensor has not been constructed\" stop 1 end if call torch_tensor_mean_c ( output % p , tensor % p ) end subroutine torch_tensor_mean ! ============================================================================ ! --- Procedures related to automatic differentation functionality for tensors ! ============================================================================ !> Resets a tensor's gradient to zero. subroutine torch_tensor_zero_grad ( tensor ) use , intrinsic :: iso_c_binding , only : c_associated class ( torch_tensor ), intent ( inout ) :: tensor !! Tensor to zero the gradient of interface subroutine torch_tensor_zero_grad_c ( tensor_c ) bind ( c , name = 'torch_tensor_zero_grad' ) use , intrinsic :: iso_c_binding , only : c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: tensor_c end subroutine torch_tensor_zero_grad_c end interface ! TODO: Call torch_tensor_get_gradient to check it exists? call torch_tensor_zero_grad_c ( tensor % p ) end subroutine torch_tensor_zero_grad !> Performs back-propagation on a Torch Tensor, given some external gradient. subroutine torch_tensor_backward ( tensor , retain_graph ) use , intrinsic :: iso_c_binding , only : c_bool type ( torch_tensor ), intent ( in ) :: tensor !! Tensor to compute gradients of logical , optional , intent ( in ) :: retain_graph !! Should the computational graph be retained? ! Local arguments type ( torch_tensor ) :: external_gradient !! External tensor used as an initial scaling of the gradient calculation logical ( c_bool ) :: retain_graph_value interface subroutine torch_tensor_backward_c ( tensor_c , external_gradient_c , retain_graph_c ) & bind ( c , name = 'torch_tensor_backward' ) use , intrinsic :: iso_c_binding , only : c_bool , c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: tensor_c type ( c_ptr ), value , intent ( in ) :: external_gradient_c logical ( c_bool ), value , intent ( in ) :: retain_graph_c end subroutine torch_tensor_backward_c end interface ! External gradient to provide to the back-propagation consisting of a tensor of ones ! TODO: Accept other external gradients as an optional argument call torch_tensor_ones ( external_gradient , tensor % get_rank (), tensor % get_shape (), & tensor % get_dtype (), tensor % get_device_type (), & device_index = tensor % get_device_index ()) ! Do not retain the graph by default if ( present ( retain_graph )) then retain_graph_value = retain_graph else retain_graph_value = . false . end if ! Call back-propagation with the provided external gradient call torch_tensor_backward_c ( tensor % p , external_gradient % p , retain_graph_value ) ! Delete the external gradient tensor call torch_tensor_delete ( external_gradient ) end subroutine torch_tensor_backward !> Retrieves the gradient with respect to a Torch Tensor. subroutine torch_tensor_get_gradient ( gradient , tensor ) type ( torch_tensor ), intent ( inout ) :: gradient !! Tensor holding the gradient type ( torch_tensor ), intent ( in ) :: tensor !! Tensor to compute the gradient with respect to interface subroutine torch_tensor_get_gradient_c ( tensor_c , gradient_c ) & bind ( c , name = 'torch_tensor_get_gradient' ) use , intrinsic :: iso_c_binding , only : c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: tensor_c type ( c_ptr ), value , intent ( in ) :: gradient_c end subroutine torch_tensor_get_gradient_c end interface if (. not . c_associated ( gradient % p )) then write ( * , * ) \"Error :: tensors for holding gradients must be constructed before retrieving values\" stop 1 end if call torch_tensor_get_gradient_c ( tensor % p , gradient % p ) end subroutine torch_tensor_get_gradient ! ============================================================================ ! --- Torch Model API ! ============================================================================ !> Loads a TorchScript nn.module (pre-trained PyTorch model saved with TorchScript) subroutine torch_model_load ( model , filename , device_type , device_index , & requires_grad , is_training ) use , intrinsic :: iso_c_binding , only : c_bool , c_int , c_null_char type ( torch_model ), intent ( out ) :: model !! Returned deserialized model character ( * ), intent ( in ) :: filename !! Filename of saved TorchScript model integer ( c_int ), intent ( in ) :: device_type !! Device type the tensor will live on (`torch_kCPU` or `torch_kCUDA`) integer ( c_int ), optional , intent ( in ) :: device_index !! device index to use for `torch_kCUDA` case logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor logical , optional , intent ( in ) :: is_training !! Whether the model is being trained, rather than evaluated integer ( c_int ) :: device_index_value logical :: requires_grad_value !! Whether gradients need to be computed for the created tensor logical :: is_training_value !! Whether the model is being trained, rather than evaluated interface function torch_jit_load_c ( filename_c , device_type_c , device_index_c , & requires_grad_c , is_training_c ) result ( model_c ) & bind ( c , name = 'torch_jit_load' ) use , intrinsic :: iso_c_binding , only : c_bool , c_char , c_int , c_ptr implicit none character ( c_char ), intent ( in ) :: filename_c ( * ) integer ( c_int ), value , intent ( in ) :: device_type_c integer ( c_int ), value , intent ( in ) :: device_index_c logical ( c_bool ), value , intent ( in ) :: requires_grad_c logical ( c_bool ), value , intent ( in ) :: is_training_c type ( c_ptr ) :: model_c end function torch_jit_load_c end interface ! Process optional arguments if ( present ( device_index )) then device_index_value = device_index else if ( device_type == torch_kCPU ) then device_index_value = - 1 else device_index_value = 0 endif if (. not . present ( requires_grad )) then requires_grad_value = . false . else requires_grad_value = requires_grad end if if (. not . present ( is_training )) then is_training_value = . false . else is_training_value = is_training end if ! Need to append c_null_char at end of filename model % p = torch_jit_load_c ( trim ( adjustl ( filename )) // c_null_char , device_type , & device_index_value , logical ( requires_grad_value , c_bool ), & logical ( is_training_value , c_bool )) end subroutine torch_model_load !> Performs a forward pass of the model with the input tensors subroutine torch_model_forward ( model , input_tensors , output_tensors , requires_grad ) use , intrinsic :: iso_c_binding , only : c_bool , c_ptr , c_int , c_loc type ( torch_model ), intent ( in ) :: model !! Model type ( torch_tensor ), intent ( in ), dimension (:) :: input_tensors !! Array of Input tensors type ( torch_tensor ), intent ( in ), dimension (:) :: output_tensors !! Returned output tensors logical , optional , intent ( in ) :: requires_grad !! Whether gradients need to be computed for the created tensor logical :: requires_grad_value !! Whether gradients need to be computed for the created tensor integer ( ftorch_int ) :: i integer ( c_int ) :: n_inputs integer ( c_int ) :: n_outputs type ( c_ptr ), dimension ( size ( input_tensors )), target :: input_ptrs type ( c_ptr ), dimension ( size ( output_tensors )), target :: output_ptrs interface subroutine torch_jit_model_forward_c ( model_c , input_tensors_c , n_inputs_c , & output_tensors_c , n_outputs_c , requires_grad_c ) & bind ( c , name = 'torch_jit_module_forward' ) use , intrinsic :: iso_c_binding , only : c_bool , c_ptr , c_int implicit none type ( c_ptr ), value , intent ( in ) :: model_c type ( c_ptr ), value , intent ( in ) :: input_tensors_c integer ( c_int ), value , intent ( in ) :: n_inputs_c type ( c_ptr ), value , intent ( in ) :: output_tensors_c integer ( c_int ), value , intent ( in ) :: n_outputs_c logical ( c_bool ), value , intent ( in ) :: requires_grad_c end subroutine torch_jit_model_forward_c end interface n_inputs = size ( input_tensors ) n_outputs = size ( output_tensors ) if (. not . present ( requires_grad )) then requires_grad_value = . false . else requires_grad_value = requires_grad end if ! Assign array of pointers to the input tensors do i = 1 , n_inputs input_ptrs ( i ) = input_tensors ( i )% p end do ! Assign array of pointers to the output tensors do i = 1 , n_outputs output_ptrs ( i ) = output_tensors ( i )% p end do call torch_jit_model_forward_c ( model % p , c_loc ( input_ptrs ), n_inputs , & c_loc ( output_ptrs ), n_outputs , & logical ( requires_grad_value , c_bool )) end subroutine torch_model_forward !> Deallocates a TorchScript model subroutine torch_model_delete ( model ) type ( torch_model ), intent ( in ) :: model !! Torch Model to deallocate interface subroutine torch_jit_model_delete_c ( model_c ) & bind ( c , name = 'torch_jit_module_delete' ) use , intrinsic :: iso_c_binding , only : c_ptr implicit none type ( c_ptr ), value , intent ( in ) :: model_c end subroutine torch_jit_model_delete_c end interface call torch_jit_model_delete_c ( model % p ) end subroutine torch_model_delete end module ftorch","tags":"","url":"sourcefile/ftorch.f90.html"},{"title":"ftorch_test_utils.f90 – FTorch","text":"Source Code !| Utils module for FTorch containing assertions for testing ! !  * License !    FTorch is released under an MIT license. !    See the [LICENSE](https://github.com/Cambridge-ICCS/FTorch/blob/main/LICENSE) !    file for details. module ftorch_test_utils use , intrinsic :: iso_fortran_env , only : real32 , real64 implicit none public interface assert_isclose module procedure assert_isclose_real32 module procedure assert_isclose_real64 end interface interface assert_allclose module procedure assert_allclose_real32_1d module procedure assert_allclose_real32_2d module procedure assert_allclose_real32_3d module procedure assert_allclose_real64_1d module procedure assert_allclose_real64_2d module procedure assert_allclose_real64_3d end interface contains !> Print the result of a test to the terminal subroutine test_print ( test_name , message , test_pass ) character ( len =* ), intent ( in ) :: test_name !! Name of the test being run character ( len =* ), intent ( in ) :: message !! Message to print logical , intent ( in ) :: test_pass !! Result of the assertion character ( len = 15 ) :: report if ( test_pass ) then report = char ( 27 ) // '[32m' // 'PASSED' // char ( 27 ) // '[0m' else report = char ( 27 ) // '[31m' // 'FAILED' // char ( 27 ) // '[0m' end if write ( * , '(A, \" :: [\", A, \"] \", A)' ) report , trim ( test_name ), trim ( message ) end subroutine test_print !> Asserts that two real32 values coincide to a given relative tolerance function assert_isclose_real32 ( got , expect , test_name , rtol , print_result ) result ( test_pass ) character ( len =* ), intent ( in ) :: test_name !! Name of the test being run real ( kind = real32 ), intent ( in ) :: got !! The value to be tested real ( kind = real32 ), intent ( in ) :: expect !! The expected value real ( kind = real32 ), intent ( in ), optional :: rtol !! Optional relative tolerance (defaults to 1e-5) logical , intent ( in ), optional :: print_result !! Optionally print test result to screen (defaults to .true.) logical :: test_pass !! Did the assertion pass? character ( len = 80 ) :: message real ( kind = real32 ) :: rtol_value logical :: print_result_value if (. not . present ( rtol )) then rtol_value = 1e-5 else rtol_value = rtol end if if (. not . present ( print_result )) then print_result_value = . true . else print_result_value = print_result end if test_pass = ( abs ( got - expect ) <= rtol_value * abs ( expect )) if ( print_result_value ) then write ( message , '(\"relative tolerance = \", E11.4)' ) rtol_value call test_print ( test_name , message , test_pass ) end if end function assert_isclose_real32 !> Asserts that two real64 values coincide to a given relative tolerance function assert_isclose_real64 ( got , expect , test_name , rtol , print_result ) result ( test_pass ) character ( len =* ), intent ( in ) :: test_name !! Name of the test being run real ( kind = real64 ), intent ( in ) :: got !! The value to be tested real ( kind = real64 ), intent ( in ) :: expect !! The expected value real ( kind = real64 ), intent ( in ), optional :: rtol !! Optional relative tolerance (defaults to 1e-5) logical , intent ( in ), optional :: print_result !! Optionally print test result to screen (defaults to .true.) logical :: test_pass !! Did the assertion pass? character ( len = 80 ) :: message real ( kind = real64 ) :: rtol_value logical :: print_result_value if (. not . present ( rtol )) then rtol_value = 1e-5 else rtol_value = rtol end if if (. not . present ( print_result )) then print_result_value = . true . else print_result_value = print_result end if test_pass = ( abs ( got - expect ) <= rtol_value * abs ( expect )) if ( print_result_value ) then write ( message , '(\"relative tolerance = \", E11.4)' ) rtol_value call test_print ( test_name , message , test_pass ) end if end function assert_isclose_real64 !> Asserts that two real32-valued 1D arrays coincide to a given relative tolerance function assert_allclose_real32_1d ( got , expect , test_name , rtol , print_result ) result ( test_pass ) character ( len =* ), intent ( in ) :: test_name !! Name of the test being run real ( kind = real32 ), intent ( in ), dimension (:) :: got !! The array of values to be tested real ( kind = real32 ), intent ( in ), dimension (:) :: expect !! The array of expected values real ( kind = real32 ), intent ( in ), optional :: rtol !! Optional relative tolerance (defaults to 1e-5) logical , intent ( in ), optional :: print_result !! Optionally print test result to screen (defaults to .true.) logical :: test_pass !! Did the assertion pass? character ( len = 80 ) :: message real ( kind = real32 ) :: rtol_value integer :: shape_error logical :: print_result_value if (. not . present ( rtol )) then rtol_value = 1.0e-5 else rtol_value = rtol end if if (. not . present ( print_result )) then print_result_value = . true . else print_result_value = print_result end if ! Check the shapes of the arrays match shape_error = maxval ( abs ( shape ( got ) - shape ( expect ))) test_pass = ( shape_error == 0 ) if ( test_pass ) then test_pass = all ( abs ( got - expect ) <= rtol_value * abs ( expect )) if ( print_result_value ) then write ( message , '(\"relative tolerance = \", E11.4)' ) rtol_value call test_print ( test_name , message , test_pass ) end if else if ( print_result_value ) then call test_print ( test_name , \"Arrays have mismatching shapes.\" , test_pass ) endif end function assert_allclose_real32_1d !> Asserts that two real32-valued 2D arrays coincide to a given relative tolerance function assert_allclose_real32_2d ( got , expect , test_name , rtol , print_result ) result ( test_pass ) character ( len =* ), intent ( in ) :: test_name !! Name of the test being run real ( kind = real32 ), intent ( in ), dimension (:,:) :: got !! The array of values to be tested real ( kind = real32 ), intent ( in ), dimension (:,:) :: expect !! The array of expected values real ( kind = real32 ), intent ( in ), optional :: rtol !! Optional relative tolerance (defaults to 1e-5) logical , intent ( in ), optional :: print_result !! Optionally print test result to screen (defaults to .true.) logical :: test_pass !! Did the assertion pass? character ( len = 80 ) :: message real ( kind = real32 ) :: rtol_value integer :: shape_error logical :: print_result_value if (. not . present ( rtol )) then rtol_value = 1.0e-5 else rtol_value = rtol end if if (. not . present ( print_result )) then print_result_value = . true . else print_result_value = print_result end if ! Check the shapes of the arrays match shape_error = maxval ( abs ( shape ( got ) - shape ( expect ))) test_pass = ( shape_error == 0 ) if ( test_pass ) then test_pass = all ( abs ( got - expect ) <= rtol_value * abs ( expect )) if ( print_result_value ) then write ( message , '(\"relative tolerance = \", E11.4)' ) rtol_value call test_print ( test_name , message , test_pass ) end if else if ( print_result_value ) then call test_print ( test_name , \"Arrays have mismatching shapes.\" , test_pass ) endif end function assert_allclose_real32_2d !> Asserts that two real32-valued 3D arrays coincide to a given relative tolerance function assert_allclose_real32_3d ( got , expect , test_name , rtol , print_result ) result ( test_pass ) character ( len =* ), intent ( in ) :: test_name !! Name of the test being run real ( kind = real32 ), intent ( in ), dimension (:,:,:) :: got !! The array of values to be tested real ( kind = real32 ), intent ( in ), dimension (:,:,:) :: expect !! The array of expected values real ( kind = real32 ), intent ( in ), optional :: rtol !! Optional relative tolerance (defaults to 1e-5) logical , intent ( in ), optional :: print_result !! Optionally print test result to screen (defaults to .true.) logical :: test_pass !! Did the assertion pass? character ( len = 80 ) :: message real ( kind = real32 ) :: rtol_value integer :: shape_error logical :: print_result_value if (. not . present ( rtol )) then rtol_value = 1.0e-5 else rtol_value = rtol end if if (. not . present ( print_result )) then print_result_value = . true . else print_result_value = print_result end if ! Check the shapes of the arrays match shape_error = maxval ( abs ( shape ( got ) - shape ( expect ))) test_pass = ( shape_error == 0 ) if ( test_pass ) then test_pass = all ( abs ( got - expect ) <= rtol_value * abs ( expect )) if ( print_result_value ) then write ( message , '(\"relative tolerance = \", E11.4)' ) rtol_value call test_print ( test_name , message , test_pass ) end if else if ( print_result_value ) then call test_print ( test_name , \"Arrays have mismatching shapes.\" , test_pass ) endif end function assert_allclose_real32_3d !> Asserts that two real64-valued 1D arrays coincide to a given relative tolerance function assert_allclose_real64_1d ( got , expect , test_name , rtol , print_result ) result ( test_pass ) character ( len =* ), intent ( in ) :: test_name !! Name of the test being run real ( kind = real64 ), intent ( in ), dimension (:) :: got !! The array of values to be tested real ( kind = real64 ), intent ( in ), dimension (:) :: expect !! The array of expected values real ( kind = real64 ), intent ( in ), optional :: rtol !! Optional relative tolerance (defaults to 1e-5) logical , intent ( in ), optional :: print_result !! Optionally print test result to screen (defaults to .true.) logical :: test_pass !! Did the assertion pass? character ( len = 80 ) :: message real ( kind = real64 ) :: rtol_value integer :: shape_error logical :: print_result_value if (. not . present ( rtol )) then rtol_value = 1.0e-5 else rtol_value = rtol end if if (. not . present ( print_result )) then print_result_value = . true . else print_result_value = print_result end if ! Check the shapes of the arrays match shape_error = maxval ( abs ( shape ( got ) - shape ( expect ))) test_pass = ( shape_error == 0 ) if ( test_pass ) then test_pass = all ( abs ( got - expect ) <= rtol_value * abs ( expect )) if ( print_result_value ) then write ( message , '(\"relative tolerance = \", E11.4)' ) rtol_value call test_print ( test_name , message , test_pass ) end if else if ( print_result_value ) then call test_print ( test_name , \"Arrays have mismatching shapes.\" , test_pass ) endif end function assert_allclose_real64_1d !> Asserts that two real64-valued 2D arrays coincide to a given relative tolerance function assert_allclose_real64_2d ( got , expect , test_name , rtol , print_result ) result ( test_pass ) character ( len =* ), intent ( in ) :: test_name !! Name of the test being run real ( kind = real64 ), intent ( in ), dimension (:,:) :: got !! The array of values to be tested real ( kind = real64 ), intent ( in ), dimension (:,:) :: expect !! The array of expected values real ( kind = real64 ), intent ( in ), optional :: rtol !! Optional relative tolerance (defaults to 1e-5) logical , intent ( in ), optional :: print_result !! Optionally print test result to screen (defaults to .true.) logical :: test_pass !! Did the assertion pass? character ( len = 80 ) :: message real ( kind = real64 ) :: rtol_value integer :: shape_error logical :: print_result_value if (. not . present ( rtol )) then rtol_value = 1.0e-5 else rtol_value = rtol end if if (. not . present ( print_result )) then print_result_value = . true . else print_result_value = print_result end if ! Check the shapes of the arrays match shape_error = maxval ( abs ( shape ( got ) - shape ( expect ))) test_pass = ( shape_error == 0 ) if ( test_pass ) then test_pass = all ( abs ( got - expect ) <= rtol_value * abs ( expect )) if ( print_result_value ) then write ( message , '(\"relative tolerance = \", E11.4)' ) rtol_value call test_print ( test_name , message , test_pass ) end if else if ( print_result_value ) then call test_print ( test_name , \"Arrays have mismatching shapes.\" , test_pass ) endif end function assert_allclose_real64_2d !> Asserts that two real64-valued 3D arrays coincide to a given relative tolerance function assert_allclose_real64_3d ( got , expect , test_name , rtol , print_result ) result ( test_pass ) character ( len =* ), intent ( in ) :: test_name !! Name of the test being run real ( kind = real64 ), intent ( in ), dimension (:,:,:) :: got !! The array of values to be tested real ( kind = real64 ), intent ( in ), dimension (:,:,:) :: expect !! The array of expected values real ( kind = real64 ), intent ( in ), optional :: rtol !! Optional relative tolerance (defaults to 1e-5) logical , intent ( in ), optional :: print_result !! Optionally print test result to screen (defaults to .true.) logical :: test_pass !! Did the assertion pass? character ( len = 80 ) :: message real ( kind = real64 ) :: rtol_value integer :: shape_error logical :: print_result_value if (. not . present ( rtol )) then rtol_value = 1.0e-5 else rtol_value = rtol end if if (. not . present ( print_result )) then print_result_value = . true . else print_result_value = print_result end if ! Check the shapes of the arrays match shape_error = maxval ( abs ( shape ( got ) - shape ( expect ))) test_pass = ( shape_error == 0 ) if ( test_pass ) then test_pass = all ( abs ( got - expect ) <= rtol_value * abs ( expect )) if ( print_result_value ) then write ( message , '(\"relative tolerance = \", E11.4)' ) rtol_value call test_print ( test_name , message , test_pass ) end if else if ( print_result_value ) then call test_print ( test_name , \"Arrays have mismatching shapes.\" , test_pass ) endif end function assert_allclose_real64_3d end module ftorch_test_utils","tags":"","url":"sourcefile/ftorch_test_utils.f90.html"},{"title":"pt2ts.py – FTorch","text":"Source Code \"\"\"Load a PyTorch model and convert it to TorchScript.\"\"\" # Throughout this script there are various `FTORCH-TODO` comments indicating where # the user needs to modify as appropriate for their model import os from typing import Optional # FTORCH-TODO # Add a module import with your model here: # This example assumes the model architecture is in an adjacent module `my_ml_model.py` import my_ml_model import torch def script_to_torchscript ( model : torch . nn . Module , filename : Optional [ str ] = \"scripted_model.pt\" ) -> None : \"\"\" Save PyTorch model to TorchScript using scripting. Parameters ---------- model : torch.NN.Module a PyTorch model filename : str name of file to save to \"\"\" # FIXME: torch.jit.optimize_for_inference() when PyTorch issue #81085 is resolved scripted_model = torch . jit . script ( model ) # print(scripted_model.code) scripted_model . save ( filename ) def trace_to_torchscript ( model : torch . nn . Module , dummy_input : torch . Tensor , filename : Optional [ str ] = \"traced_model.pt\" , ) -> None : \"\"\" Save PyTorch model to TorchScript using tracing. Parameters ---------- model : torch.NN.Module a PyTorch model dummy_input : torch.Tensor appropriate size Tensor to act as input to model filename : str name of file to save to \"\"\" # FIXME: torch.jit.optimize_for_inference() when PyTorch issue #81085 is resolved traced_model = torch . jit . trace ( model , dummy_input ) # traced_model.save(filename) frozen_model = torch . jit . freeze ( traced_model ) ## print(frozen_model.graph) ## print(frozen_model.code) frozen_model . save ( filename ) def load_torchscript ( filename : Optional [ str ] = \"saved_model.pt\" ) -> torch . nn . Module : \"\"\" Load a TorchScript from file. Parameters ---------- filename : str name of file containing TorchScript model \"\"\" model = torch . jit . load ( filename ) return model if __name__ == \"__main__\" : import argparse parser = argparse . ArgumentParser ( formatter_class = argparse . ArgumentDefaultsHelpFormatter , ) parser . add_argument ( \"--device_type\" , help = \"Device type to run the inference on\" , type = str , choices = [ \"cpu\" , \"cuda\" , \"hip\" , \"xpu\" , \"mps\" ], default = \"cpu\" , ) parser . add_argument ( \"--filepath\" , help = \"Path to the file containing the PyTorch model\" , type = str , default = os . path . dirname ( __file__ ), ) parsed_args = parser . parse_args () device_type = parsed_args . device_type filepath = parsed_args . filepath # ===================================================== # Load model and prepare for saving # ===================================================== # FTORCH-TODO # Load a pre-trained PyTorch model # Insert code here to load your model as `trained_model`. # This example assumes my_ml_model has a method `initialize` to load # architecture, weights, and place in inference mode trained_model = my_ml_model . initialize () # Switch off specific layers/parts of the model that behave # differently during training and inference. # This may have been done by the user already, so just make sure here. trained_model . eval () # ===================================================== # Prepare dummy input and check model runs # ===================================================== # FTORCH-TODO # Generate a dummy input Tensor `dummy_input` to the model of appropriate size. # This example assumes two inputs of size (512x40) and (512x1) trained_model_dummy_input_1 = torch . ones (( 512 , 40 ), dtype = torch . float64 ) trained_model_dummy_input_2 = torch . ones (( 512 , 1 ), dtype = torch . float64 ) # Transfer the model and inputs to GPU device, if appropriate if device_type != \"cpu\" : if device_type == \"hip\" : device = torch . device ( \"cuda\" ) # NOTE: HIP is treated as CUDA in FTorch else : device = torch . device ( device_type ) trained_model = trained_model . to ( device ) trained_model . eval () trained_model_dummy_input_1 = trained_model_dummy_input_1 . to ( device ) trained_model_dummy_input_2 = trained_model_dummy_input_2 . to ( device ) # FTORCH-TODO # Run model for dummy inputs # If something isn't working This will generate an error trained_model_dummy_outputs = trained_model ( trained_model_dummy_input_1 , trained_model_dummy_input_2 , ) # ===================================================== # Save model # ===================================================== # FTORCH-TODO # Set the name of the file you want to save the torchscript model to: saved_ts_filename = f \"saved_model_ { device_type } .pt\" # A filepath may also be provided. To do this, pass the filepath as an argument to # this script when it is run from the command line, i.e. `./pt2ts.py path/to/model`. # FTORCH-TODO # Save the PyTorch model using either scripting (recommended if possible) or tracing # ----------- # Scripting # ----------- script_to_torchscript ( trained_model , filename = saved_ts_filename ) # ----------- # Tracing # ----------- # trace_to_torchscript( #     trained_model, trained_model_dummy_input, filename=saved_ts_filename # ) # ===================================================== # Check model saved OK # ===================================================== # Load torchscript and run model as a test, scaling inputs as above trained_model_dummy_input_1 = 2.0 * trained_model_dummy_input_1 trained_model_dummy_input_2 = 2.0 * trained_model_dummy_input_2 trained_model_testing_outputs = trained_model ( trained_model_dummy_input_1 , trained_model_dummy_input_2 , ) ts_model = load_torchscript ( filename = saved_ts_filename ) ts_model_outputs = ts_model ( trained_model_dummy_input_1 , trained_model_dummy_input_2 , ) if not isinstance ( ts_model_outputs , tuple ): ts_model_outputs = ( ts_model_outputs ,) if not isinstance ( trained_model_testing_outputs , tuple ): trained_model_testing_outputs = ( trained_model_testing_outputs ,) for ts_output , output in zip ( ts_model_outputs , trained_model_testing_outputs ): if torch . all ( ts_output . eq ( output )): print ( \"Saved TorchScript model working as expected in a basic test.\" ) print ( \"Users should perform further validation as appropriate.\" ) else : model_error = ( \"Saved Torchscript model is not performing as expected. \\n \" \"Consider using scripting if you used tracing, or investigate further.\" ) raise RuntimeError ( model_error ) # Check that the model file is created if not os . path . exists ( os . path . join ( filepath , saved_ts_filename )): torchscript_file_error = ( f \"Saved TorchScript file { os . path . join ( filepath , saved_ts_filename ) } \" \"cannot be found.\" ) raise FileNotFoundError ( torchscript_file_error )","tags":"","url":"sourcefile/pt2ts.py.html"},{"title":"ctorch.cpp – FTorch","text":"Source Code /* * For more details on the Torch Tensor C++ API, we refer to the Torch C++ documentation * (https://pytorch.org/cppdocs) and more specifically the C++ API documentation * (https://pytorch.org/cppdocs/api/library_root.html) pages on the PyTorch website. */ #include <torch/script.h> #include <torch/torch.h> #include \"ctorch.h\" #ifndef GPU_DEVICE #define GPU_DEVICE GPU_DEVICE_NONE #endif // ============================================================================= // --- Functions to aid in consistent error handling // ============================================================================= // Accept a string message and handle as error. Accepts a cleanup function if desired. void ctorch_error ( const std :: string & message , const std :: function < void () > & cleanup = nullptr ) { std :: cerr << \"[ERROR]: \" << message << std :: endl ; if ( cleanup ) { cleanup (); // Perform cleanup actions } exit ( EXIT_FAILURE ); } // Accept a string message and handle as a warning. void ctorch_warn ( const std :: string & message ) { std :: cerr << \"[WARNING]: \" << message << std :: endl ; } // ============================================================================= // --- Constant expressions // ============================================================================= // Mapping from FTorch device_data_t to libtorch Dtype constexpr auto get_libtorch_dtype ( torch_data_t dtype ) { switch ( dtype ) { case torch_kUInt8 : ctorch_error ( \"uint8 not supported in Fortran\" ); // See https://gcc.gnu.org/onlinedocs/gfortran/ISO_005fFORTRAN_005fENV.html case torch_kInt8 : return torch :: kInt8 ; case torch_kInt16 : return torch :: kInt16 ; case torch_kInt32 : return torch :: kInt32 ; case torch_kInt64 : return torch :: kInt64 ; case torch_kFloat16 : ctorch_error ( \"float16 not supported in Fortran\" ); // See https://gcc.gnu.org/onlinedocs/gfortran/ISO_005fFORTRAN_005fENV.html case torch_kFloat32 : return torch :: kFloat32 ; case torch_kFloat64 : return torch :: kFloat64 ; default : ctorch_warn ( \"unknown data type, setting to torch_kFloat32\" ); return torch :: kFloat32 ; } } // Mapping from libtorch Dtype to FTorch device_data_t torch_data_t get_ftorch_dtype ( caffe2 :: TypeMeta dtype ) { if ( dtype == torch :: kUInt8 ) { ctorch_error ( \"uint8 not supported in Fortran\" ); // See https://gcc.gnu.org/onlinedocs/gfortran/ISO_005fFORTRAN_005fENV.html } else if ( dtype == torch :: kInt8 ) { return torch_kInt8 ; } else if ( dtype == torch :: kInt16 ) { return torch_kInt16 ; } else if ( dtype == torch :: kInt32 ) { return torch_kInt32 ; } else if ( dtype == torch :: kInt64 ) { return torch_kInt64 ; } else if ( dtype == torch :: kFloat16 ) { ctorch_error ( \"float16 not supported in Fortran\" ); // See https://gcc.gnu.org/onlinedocs/gfortran/ISO_005fFORTRAN_005fENV.html } else if ( dtype == torch :: kFloat32 ) { return torch_kFloat32 ; } else if ( dtype == torch :: kFloat64 ) { return torch_kFloat64 ; } else { std :: cerr << \"[ERROR]: data type \" << dtype << \" not supported in Fortran\" << std :: endl ; exit ( EXIT_FAILURE ); } return torch_kFloat32 ; // Dummy return to satisfy the compiler } // Mapping from FTorch device_type_t to libtorch DeviceType const auto get_libtorch_device ( torch_device_t device_type , int device_index ) { switch ( device_type ) { case torch_kCPU : if ( device_index != -1 ) { ctorch_warn ( \"device index unused for CPU-only runs\" ); } return torch :: Device ( torch :: kCPU ); #if (GPU_DEVICE == GPU_DEVICE_CUDA) || (GPU_DEVICE == GPU_DEVICE_HIP) // NOTE: HIP is treated as CUDA in this project case torch_kCUDA : if ( device_index == -1 ) { ctorch_warn ( \"device index unset, defaulting to 0\" ); device_index = 0 ; } if ( device_index >= 0 && device_index < torch :: cuda :: device_count ()) { return torch :: Device ( torch :: kCUDA , device_index ); } else { std :: cerr << \"[ERROR]: invalid device index \" << device_index << \" for device count \" << torch :: cuda :: device_count () << std :: endl ; exit ( EXIT_FAILURE ); } #endif case torch_kMPS : if ( device_index != -1 && device_index != 0 ) { ctorch_warn ( \"Only one device is available for MPS runs\" ); } return torch :: Device ( torch :: kMPS ); #if GPU_DEVICE == GPU_DEVICE_XPU case torch_kXPU : if ( device_index == -1 ) { ctorch_warn ( \"device index unset, defaulting to 0\" ); device_index = 0 ; } if ( device_index >= 0 && device_index < torch :: xpu :: device_count ()) { return torch :: Device ( torch :: kXPU , device_index ); } else { std :: cerr << \"[ERROR]: invalid device index \" << device_index << \" for XPU device count \" << torch :: xpu :: device_count () << std :: endl ; exit ( EXIT_FAILURE ); } #endif default : ctorch_warn ( \"unknown device type, setting to torch_kCPU\" ); return torch :: Device ( torch :: kCPU ); } } // Mapping from libtorch DeviceType to FTorch device_type_t const torch_device_t get_ftorch_device ( torch :: DeviceType device_type ) { switch ( device_type ) { case torch :: kCPU : return torch_kCPU ; case torch :: kCUDA : return torch_kCUDA ; case torch :: kHIP : return torch_kHIP ; case torch :: kXPU : return torch_kXPU ; case torch :: kMPS : return torch_kMPS ; default : std :: cerr << \"[ERROR]: device type \" << device_type << \" not implemented in FTorch\" << std :: endl ; exit ( EXIT_FAILURE ); } } // ============================================================================= // --- Functions for validating tensors // ============================================================================= // Check if a tensor is valid void validate_tensor_not_null ( const torch :: Tensor * t , const std :: string & name ) { if ( ! t ) { throw std :: invalid_argument ( name + \" is null.\" ); } } // Check if a tensor is defined void validate_tensor_defined ( const torch :: Tensor * t , const std :: string & name ) { if ( ! t -> defined ()) { throw std :: invalid_argument ( name + \" is undefined.\" ); } } void validate_tensor ( const torch :: Tensor * t , const std :: string & name ) { validate_tensor_not_null ( t , name ); validate_tensor_defined ( t , name ); } // Check if a tensor has requires_grad set void validate_requires_grad ( const torch :: Tensor * t , const std :: string & name ) { if ( ! t -> requires_grad ()) { throw std :: runtime_error ( name + \" does not have requires_grad set.\" ); } } void validate_gradient_defined ( const torch :: Tensor * t , const std :: string & name ) { if ( ! t -> grad (). defined ()) { throw std :: runtime_error ( name + \" has an undefined gradient. \\n Perhaps you forgot to call backward.\" ); } } // ============================================================================= // --- Functions for constructing tensors // ============================================================================= torch_tensor_t torch_empty ( int ndim , const int64_t * shape , torch_data_t dtype , torch_device_t device_type , int device_index = -1 , const bool requires_grad = false ) { torch :: AutoGradMode enable_grad ( requires_grad ); auto tensor = new torch :: Tensor ; try { // This doesn't throw if shape and dimensions are incompatible c10 :: IntArrayRef vshape ( shape , ndim ); auto options = torch :: TensorOptions () . dtype ( get_libtorch_dtype ( dtype )) . device ( get_libtorch_device ( device_type , device_index )) . requires_grad ( requires_grad ); * tensor = torch :: empty ( vshape , options ); } catch ( const torch :: Error & e ) { ctorch_error ( e . msg (), [ & ]() { delete tensor ; }); } catch ( const std :: exception & e ) { ctorch_error ( e . what (), [ & ]() { delete tensor ; }); } return tensor ; } torch_tensor_t torch_zeros ( int ndim , const int64_t * shape , torch_data_t dtype , torch_device_t device_type , int device_index = -1 , const bool requires_grad = false ) { torch :: AutoGradMode enable_grad ( requires_grad ); auto tensor = new torch :: Tensor ; try { // This doesn't throw if shape and dimensions are incompatible c10 :: IntArrayRef vshape ( shape , ndim ); auto options = torch :: TensorOptions () . dtype ( get_libtorch_dtype ( dtype )) . device ( get_libtorch_device ( device_type , device_index )) . requires_grad ( requires_grad ); * tensor = torch :: zeros ( vshape , options ); } catch ( const torch :: Error & e ) { ctorch_error ( e . msg (), [ & ]() { delete tensor ; }); } catch ( const std :: exception & e ) { ctorch_error ( e . what (), [ & ]() { delete tensor ; }); } return tensor ; } torch_tensor_t torch_ones ( int ndim , const int64_t * shape , torch_data_t dtype , torch_device_t device_type , int device_index = -1 , const bool requires_grad = false ) { torch :: AutoGradMode enable_grad ( requires_grad ); auto tensor = new torch :: Tensor ; try { // This doesn't throw if shape and dimensions are incompatible c10 :: IntArrayRef vshape ( shape , ndim ); auto options = torch :: TensorOptions () . dtype ( get_libtorch_dtype ( dtype )) . device ( get_libtorch_device ( device_type , device_index )) . requires_grad ( requires_grad ); * tensor = torch :: ones ( vshape , options ); } catch ( const torch :: Error & e ) { ctorch_error ( e . msg (), [ & ]() { delete tensor ; }); } catch ( const std :: exception & e ) { ctorch_error ( e . what (), [ & ]() { delete tensor ; }); } return tensor ; } // Exposes the given data as a Tensor without taking ownership of the original // data torch_tensor_t torch_from_blob ( void * data , int ndim , const int64_t * shape , const int64_t * strides , torch_data_t dtype , torch_device_t device_type , int device_index = -1 , const bool requires_grad = false ) { torch :: AutoGradMode enable_grad ( requires_grad ); auto tensor = new torch :: Tensor ; try { // This doesn't throw if shape and dimensions are incompatible c10 :: IntArrayRef vshape ( shape , ndim ); c10 :: IntArrayRef vstrides ( strides , ndim ); // NOTE: Do not pass device TensorOptions since this would cause torch::from_blob //       to expect data to reside on the host device_type, which is not case if //       device_type is a GPU device (see #365) auto options = torch :: TensorOptions () . dtype ( get_libtorch_dtype ( dtype )) . requires_grad ( requires_grad ); * tensor = torch :: from_blob ( data , vshape , vstrides , options ) . to ( get_libtorch_device ( device_type , device_index )); } catch ( const torch :: Error & e ) { ctorch_error ( e . msg (), [ & ]() { delete tensor ; }); } catch ( const std :: exception & e ) { ctorch_error ( e . what (), [ & ]() { delete tensor ; }); } return tensor ; } // ===================================================================================== // --- Functions for interrogating tensors // ===================================================================================== void torch_tensor_print ( const torch_tensor_t tensor ) { auto t = reinterpret_cast < torch :: Tensor *> ( tensor ); std :: cout << * t << std :: endl ; } int torch_tensor_get_rank ( const torch_tensor_t tensor ) { auto t = reinterpret_cast < torch :: Tensor *> ( tensor ); return t -> sizes (). size (); } const torch_size_t * torch_tensor_get_sizes ( const torch_tensor_t tensor ) { auto t = reinterpret_cast < torch :: Tensor *> ( tensor ); return t -> sizes (). data (); } const torch_size_t * torch_tensor_get_stride ( const torch_tensor_t tensor ) { auto t = reinterpret_cast < torch :: Tensor *> ( tensor ); return t -> strides (). data (); } torch_data_t torch_tensor_get_dtype ( const torch_tensor_t tensor ) { auto t = reinterpret_cast < torch :: Tensor *> ( tensor ); return get_ftorch_dtype ( t -> dtype ()); } torch_device_t torch_tensor_get_device_type ( const torch_tensor_t tensor ) { auto t = reinterpret_cast < torch :: Tensor *> ( tensor ); return get_ftorch_device ( t -> device (). type ()); } int torch_tensor_get_device_index ( const torch_tensor_t tensor ) { auto t = reinterpret_cast < torch :: Tensor *> ( tensor ); return t -> device (). index (); } bool torch_tensor_requires_grad ( const torch_tensor_t tensor ) { auto t = reinterpret_cast < torch :: Tensor *> ( tensor ); return t -> requires_grad (); } // ===================================================================================== // --- Functions for deallocating tensors // ===================================================================================== void torch_tensor_delete ( torch_tensor_t tensor ) { auto t = reinterpret_cast < torch :: Tensor *> ( tensor ); delete t ; } // ===================================================================================== // --- Functions for manipulating tensors // ===================================================================================== void torch_tensor_zero ( torch_tensor_t tensor ) { auto t = reinterpret_cast < torch :: Tensor *> ( tensor ); validate_tensor ( t , \"Input tensor\" ); t -> zero_ (); } void torch_tensor_to ( const torch_tensor_t source_tensor , torch_tensor_t target_tensor , bool non_blocking ) { auto source_tens = reinterpret_cast < torch :: Tensor *> ( source_tensor ); auto target_tens = reinterpret_cast < torch :: Tensor *> ( target_tensor ); validate_tensor ( source_tens , \"Source tensor\" ); validate_tensor ( target_tens , \"Target tensor\" ); torch :: Device device_type = target_tens -> device (); at :: ScalarType dtype = target_tens -> scalar_type (); // For non-blocking usage see: // https://pytorch.org/tutorials/intermediate/pinmem_nonblock.html std :: move ( * target_tens ) = source_tens -> to ( device_type , dtype , non_blocking ); } // ===================================================================================== // --- Operator overloads acting on tensors // ===================================================================================== void torch_tensor_assign ( torch_tensor_t output , const torch_tensor_t input ) { auto out = reinterpret_cast < torch :: Tensor *> ( output ); auto in = reinterpret_cast < torch :: Tensor * const > ( input ); validate_tensor ( out , \"Output tensor\" ); validate_tensor ( in , \"Input tensor\" ); torch :: AutoGradMode enable_grad ( in -> requires_grad ()); // NOTE: The following line ensures that the output tensor continues to point to a //       Fortran array if it was set up to do so using torch_tensor_from_array. If //       it's removed then the Fortran array keeps its original value and is no //       longer be pointed to. std :: move ( * out ) = * in ; // NOTE: The following line ensures that we always overwrite the requires_grad // property matching the PyTorch behaviour. See the Python examples on // https://github.com/Cambridge-ICCS/FTorch/pull/373. out -> requires_grad_ ( in -> requires_grad ()); } void torch_tensor_add ( torch_tensor_t output , const torch_tensor_t tensor1 , const torch_tensor_t tensor2 ) { auto out = reinterpret_cast < torch :: Tensor *> ( output ); auto t1 = reinterpret_cast < torch :: Tensor * const > ( tensor1 ); auto t2 = reinterpret_cast < torch :: Tensor * const > ( tensor2 ); * out = * t1 + * t2 ; } void torch_tensor_negative ( torch_tensor_t output , const torch_tensor_t tensor ) { auto out = reinterpret_cast < torch :: Tensor *> ( output ); auto t = reinterpret_cast < torch :: Tensor * const > ( tensor ); * out = -* t ; } void torch_tensor_subtract ( torch_tensor_t output , const torch_tensor_t tensor1 , const torch_tensor_t tensor2 ) { auto out = reinterpret_cast < torch :: Tensor *> ( output ); auto t1 = reinterpret_cast < torch :: Tensor * const > ( tensor1 ); auto t2 = reinterpret_cast < torch :: Tensor * const > ( tensor2 ); * out = * t1 - * t2 ; } void torch_tensor_multiply ( torch_tensor_t output , const torch_tensor_t tensor1 , const torch_tensor_t tensor2 ) { auto out = reinterpret_cast < torch :: Tensor *> ( output ); auto t1 = reinterpret_cast < torch :: Tensor * const > ( tensor1 ); auto t2 = reinterpret_cast < torch :: Tensor * const > ( tensor2 ); * out = * t1 * * t2 ; } void torch_tensor_divide ( torch_tensor_t output , const torch_tensor_t tensor1 , const torch_tensor_t tensor2 ) { auto out = reinterpret_cast < torch :: Tensor *> ( output ); auto t1 = reinterpret_cast < torch :: Tensor * const > ( tensor1 ); auto t2 = reinterpret_cast < torch :: Tensor * const > ( tensor2 ); * out = * t1 / * t2 ; } void torch_tensor_power_int ( torch_tensor_t output , const torch_tensor_t tensor , const torch_int_t exponent ) { // NOTE: The following cast will only work for integer exponents auto out = reinterpret_cast < torch :: Tensor *> ( output ); auto t = reinterpret_cast < torch :: Tensor * const > ( tensor ); auto exp = reinterpret_cast < int * const > ( exponent ); * out = pow ( * t , * exp ); } void torch_tensor_power_float ( torch_tensor_t output , const torch_tensor_t tensor , const torch_float_t exponent ) { // NOTE: The following cast will only work for floating point exponents auto out = reinterpret_cast < torch :: Tensor *> ( output ); auto t = reinterpret_cast < torch :: Tensor * const > ( tensor ); auto exp = reinterpret_cast < float * const > ( exponent ); * out = pow ( * t , * exp ); } // ============================================================================ // --- Other operators for computations involving tensors // ============================================================================ void torch_tensor_sum ( torch_tensor_t output , const torch_tensor_t tensor ) { auto out = reinterpret_cast < torch :: Tensor *> ( output ); auto t = reinterpret_cast < torch :: Tensor * const > ( tensor ); if ( torch_tensor_get_rank ( output ) != 1 ) { std :: stringstream errmsg ; errmsg << \"Invalid rank of output tensor for sum \\n rank=\" << torch_tensor_get_rank ( output ) << \" != 1\" ; ctorch_error ( errmsg . str ()); } if ( torch_tensor_get_sizes ( output )[ 0 ] != 1 ) { std :: stringstream errmsg ; errmsg << \"Invalid shape of output tensor for sum \\n shape=[\" << torch_tensor_get_sizes ( output )[ 0 ] << \"] != [1]\" ; ctorch_error ( errmsg . str ()); } std :: move ( * out ) = t -> sum (); } void torch_tensor_mean ( torch_tensor_t output , const torch_tensor_t tensor ) { auto out = reinterpret_cast < torch :: Tensor *> ( output ); auto t = reinterpret_cast < torch :: Tensor * const > ( tensor ); if ( torch_tensor_get_rank ( output ) != 1 ) { std :: stringstream errmsg ; std :: cerr << \"Invalid rank of output tensor for mean \\n rank=\" << torch_tensor_get_rank ( output ) << \" != 1\" ; ctorch_error ( errmsg . str ()); } if ( torch_tensor_get_sizes ( output )[ 0 ] != 1 ) { std :: stringstream errmsg ; errmsg << \"Invalid shape of output tensor for mean \\n shape=[\" << torch_tensor_get_sizes ( output )[ 0 ] << \"] != [1]\" ; ctorch_error ( errmsg . str ()); } std :: move ( * out ) = t -> mean (); } // ============================================================================= // --- Functions related to automatic differentiation functionality for tensors // ============================================================================= void torch_tensor_zero_grad ( torch_tensor_t tensor ) { auto t = reinterpret_cast < torch :: Tensor *> ( tensor ); validate_tensor ( t , \"Gradient to zero\" ); t -> mutable_grad (). zero_ (); } void torch_tensor_backward ( const torch_tensor_t tensor , const torch_tensor_t external_gradient , const bool retain_graph ) { auto t = reinterpret_cast < torch :: Tensor *> ( tensor ); auto g = reinterpret_cast < torch :: Tensor * const > ( external_gradient ); try { // Check if the tensors are valid and defined validate_tensor ( t , \"Input tensor\" ); validate_tensor ( g , \"External gradient\" ); // Perform backwards step t -> backward ( * g , retain_graph ); } catch ( const std :: exception & e ) { ctorch_error ( std :: string ( e . what ()) + \" in torch_tensor_backward\" ); } } void torch_tensor_get_gradient ( const torch_tensor_t tensor , torch_tensor_t gradient ) { try { // Cast the input pointers to torch::Tensor auto t = reinterpret_cast < torch :: Tensor * const > ( tensor ); auto g = reinterpret_cast < torch :: Tensor *> ( gradient ); // Check if the tensors are valid and defined validate_tensor ( t , \"Input tensor\" ); validate_tensor_not_null ( g , \"Output gradient\" ); // Check input has requires_grad set and can generate a valid gradient tensor validate_requires_grad ( t , \"Input tensor\" ); validate_gradient_defined ( t , \"Input tensor\" ); // Assign the gradient to the output tensor std :: move ( * g ) = t -> grad (); } catch ( const std :: exception & e ) { ctorch_error ( std :: string ( e . what ()) + \" in torch_tensor_get_gradient\" ); } } // ============================================================================= // --- Torch model API // ============================================================================= void set_is_training ( torch_jit_script_module_t module , const bool is_training = false ) { auto model = static_cast < torch :: jit :: script :: Module *> ( module ); if ( is_training ) { model -> train (); } else { model -> eval (); } } torch_jit_script_module_t torch_jit_load ( const char * filename , const torch_device_t device_type = torch_kCPU , const int device_index = -1 , const bool requires_grad = false , const bool is_training = false ) { torch :: AutoGradMode enable_grad ( requires_grad ); torch :: jit :: script :: Module * module = nullptr ; try { module = new torch :: jit :: script :: Module ; * module = torch :: jit :: load ( filename , get_libtorch_device ( device_type , device_index )); } catch ( const torch :: Error & e ) { ctorch_error ( e . msg (), [ & ]() { delete module ; }); } catch ( const std :: exception & e ) { ctorch_error ( e . what (), [ & ]() { delete module ; }); } set_is_training ( module , is_training ); return module ; } void torch_jit_module_forward ( const torch_jit_script_module_t module , const torch_tensor_t * inputs , const int nin , torch_tensor_t * outputs , const int nout , const bool requires_grad = false ) { torch :: AutoGradMode enable_grad ( requires_grad ); // Here we cast the pointers we recieved in to Tensor objects auto model = static_cast < torch :: jit :: script :: Module *> ( module ); auto in = reinterpret_cast < torch :: Tensor * const *> ( inputs ); auto out = reinterpret_cast < torch :: Tensor **> ( outputs ); // Local IValue for checking we are passed types torch :: jit :: IValue LocalTensor ; // Generate a vector of IValues (placeholders for various Torch types) std :: vector < torch :: jit :: IValue > inputs_vec ; // Populate with Tensors pointed at by pointers // For each IValue check it is of Tensor type for ( int i = 0 ; i < nin ; ++ i ) { LocalTensor = * ( in [ i ]); if ( LocalTensor . isTensor ()) { inputs_vec . push_back ( LocalTensor ); } else { ctorch_error ( \"One of the inputs to torch_jit_module_forward is not a Tensor\" ); } } try { auto model_out = model -> forward ( inputs_vec ); if ( model_out . isTensor ()) { // Single output models will return a tensor directly. std :: move ( * out [ 0 ]) = model_out . toTensor (); } else if ( model_out . isTuple ()) { // Multiple output models will return a tuple => cast to tensors. for ( int i = 0 ; i < nout ; ++ i ) { std :: move ( * out [ i ]) = model_out . toTuple () -> elements ()[ i ]. toTensor (); } } else { // If for some reason the forward method does not return a Tensor it // should raise an error when trying to cast to a Tensor type ctorch_error ( \"Model Output is neither Tensor nor Tuple\" ); } } catch ( const torch :: Error & e ) { ctorch_error ( e . msg ()); } catch ( const std :: exception & e ) { ctorch_error ( e . what ()); } } void torch_jit_module_delete ( torch_jit_script_module_t module ) { auto m = reinterpret_cast < torch :: jit :: script :: Module *> ( module ); delete m ; }","tags":"","url":"sourcefile/ctorch.cpp.html"},{"title":"ctorch.h – FTorch","text":"Source Code #ifndef C_TORCH_H #define C_TORCH_H #ifdef __cplusplus #define EXPORT_C extern \"C\" #else #define EXPORT_C #endif #include <stdint.h> // ============================================================================= // --- Typedefs // ============================================================================= // Opaque pointer type alias for torch::jit::script::Module class typedef void * torch_jit_script_module_t ; // Opaque pointer type alias for at::Tensor typedef void * torch_tensor_t ; // Opaque pointer type alias for integer scalars typedef void * torch_int_t ; // Opaque pointer type alias for float scalars typedef void * torch_float_t ; // Type that represents size, strides and indexing on tensors // (like std::size_t for standard containers) // // Torch is using internally int64_t [i.e. signed 64bit integer] // We can as well to avoid portability problems // (i.e. 64bit integer beeing long long on Windows) // typedef int64_t torch_size_t ; // Data types typedef enum { torch_kUInt8 , torch_kInt8 , torch_kInt16 , torch_kInt32 , torch_kInt64 , torch_kFloat16 , torch_kFloat32 , torch_kFloat64 } torch_data_t ; // Device types // NOTE: Defined in main CMakeLists and passed via preprocessor typedef enum { torch_kCPU = GPU_DEVICE_NONE , torch_kCUDA = GPU_DEVICE_CUDA , torch_kHIP = GPU_DEVICE_HIP , torch_kXPU = GPU_DEVICE_XPU , torch_kMPS = GPU_DEVICE_MPS , } torch_device_t ; // ============================================================================= // --- Functions for constructing tensors // ============================================================================= /** * Function to generate an empty Torch Tensor * @param number of dimensions of the Tensor * @param shape of the Tensor * @param data type of the elements of the Tensor * @param device type used (cpu, CUDA, etc.) * @param device index for the CUDA case * @param whether gradient is required */ EXPORT_C torch_tensor_t torch_empty ( int ndim , const int64_t * shape , torch_data_t dtype , torch_device_t device_type , int device_index , const bool requires_grad ); /** * Function to generate a Torch Tensor of zeros * @param number of dimensions of the Tensor * @param shape of the Tensor * @param data type of the elements of the Tensor * @param device type used (cpu, CUDA, etc.) * @param device index for the CUDA case * @param whether gradient is required */ EXPORT_C torch_tensor_t torch_zeros ( int ndim , const int64_t * shape , torch_data_t dtype , torch_device_t device_type , int device_index , const bool requires_grad ); /** * Function to generate a Torch Tensor of ones * @param number of dimensions of the Tensor * @param shape of the Tensor * @param data type of the elements of the Tensor * @param device type used (cpu, CUDA, etc.) * @param device index for the CUDA case * @param whether gradient is required */ EXPORT_C torch_tensor_t torch_ones ( int ndim , const int64_t * shape , torch_data_t dtype , torch_device_t device_type , int device_index , const bool requires_grad ); /** * Function to create a Torch Tensor from memory location given extra * information * @param pointer to the Tensor in memory * @param number of dimensions of the Tensor * @param shape of the Tensor * @param strides to take through data * @param data type of the elements of the Tensor * @param device type used (cpu, CUDA, etc.) * @param device index for the CUDA case * @param whether gradient is required * @return Torch Tensor interpretation of the data pointed at */ EXPORT_C torch_tensor_t torch_from_blob ( void * data , int ndim , const int64_t * shape , const int64_t * strides , torch_data_t dtype , torch_device_t device_type , int device_index , const bool requires_grad ); // ============================================================================= // --- Functions for interrogating tensors // ============================================================================= /** * Function to print out a Torch Tensor * @param Torch Tensor to print */ EXPORT_C void torch_tensor_print ( const torch_tensor_t tensor ); /** * Function to determine the rank of a Torch Tensor * @param Torch Tensor to determine the rank of * @return rank of the Torch Tensor */ EXPORT_C int torch_tensor_get_rank ( const torch_tensor_t tensor ); /** * Function to determine the sizes (shape) of a Torch Tensor * @param Torch Tensor to determine the rank of * @return pointer to the sizes array of the Torch Tensor */ EXPORT_C const torch_size_t * torch_tensor_get_sizes ( const torch_tensor_t tensor ); /** * Function to determine the strides of a Torch Tensor * @param tensor Torch tensor * @return pointer to the strides array of the tensor */ EXPORT_C const torch_size_t * torch_tensor_get_stride ( const torch_tensor_t tensor ); /** * Function to determine the data type of a Torch Tensor * @param Torch Tensor to determine the data type of * @return data type of the Torch Tensor represented as an enum */ EXPORT_C torch_data_t torch_tensor_get_dtype ( const torch_tensor_t tensor ); /** * Function to determine the device type of a Torch Tensor * @param Torch Tensor to determine the device type of * @return device type of the Torch Tensor represented as an enum */ EXPORT_C torch_device_t torch_tensor_get_device_type ( const torch_tensor_t tensor ); /** * Function to determine the device index of a Torch Tensor * @param Torch Tensor to determine the device index of * @return device index of the Torch Tensor */ EXPORT_C int torch_tensor_get_device_index ( const torch_tensor_t tensor ); /** * Function to determine whether a Torch Tensor requires the autograd module * @param Torch Tensor to interrogate * @return whether the Torch Tensor requires autograd */ EXPORT_C bool torch_tensor_requires_grad ( const torch_tensor_t tensor ); // ============================================================================= // --- Functions for deallocating tensors // ============================================================================= /** * Function to delete a Torch Tensor to clean up * @param Torch Tensor to delete */ EXPORT_C void torch_tensor_delete ( torch_tensor_t tensor ); // ===================================================================================== // --- Functions for manipulating tensors // ===================================================================================== /** * Function to reset the values of a Torch Tensor to zero * @param Torch Tensor to zero the values of */ EXPORT_C void torch_tensor_zero ( torch_tensor_t tensor ); /** * Function to move a tensor to a target tensor's device and dtype * @param Tensor to be moved * @param Tensor with the target device and dtype * @param if True and this copy is happening between CPU and GPU, the copy may occur * asynchronously */ EXPORT_C void torch_tensor_to ( const torch_tensor_t source_tensor , torch_tensor_t target_tensor , bool non_blocking ); // ============================================================================= // --- Operator overloads acting on tensors // ============================================================================= /** * Overloads the assignment operator for Torch Tensor * @param output Tensor * @param input Tensor */ EXPORT_C void torch_tensor_assign ( torch_tensor_t output , const torch_tensor_t input ); /** * Overloads the addition operator for two Torch Tensors * @param sum of the Tensors * @param first Tensor to be added * @param second Tensor to be added */ EXPORT_C void torch_tensor_add ( torch_tensor_t , const torch_tensor_t tensor1 , const torch_tensor_t tensor2 ); /** * Overloads the minus operator for a single Torch Tensor * @param the negative Tensor * @param Tensor to take the negative of */ EXPORT_C void torch_tensor_negative ( torch_tensor_t output , const torch_tensor_t tensor ); /** * Overloads the subtraction operator for two Torch Tensors * @param output Tensor * @param first Tensor to be subtracted * @param second Tensor to be subtracted */ EXPORT_C void torch_tensor_subtract ( torch_tensor_t output , const torch_tensor_t tensor1 , const torch_tensor_t tensor2 ); /** * Overloads the multiplication operator for two Torch Tensors * @param output Tensor * @param first Tensor to be multiplied * @param second Tensor to be multiplied */ EXPORT_C void torch_tensor_multiply ( torch_tensor_t output , const torch_tensor_t tensor1 , const torch_tensor_t tensor2 ); /** * Overloads the division operator for two Torch Tensors. * @param output Tensor * @param first Tensor to be divided * @param second Tensor to be divided */ EXPORT_C void torch_tensor_divide ( torch_tensor_t output , const torch_tensor_t tensor1 , const torch_tensor_t tensor2 ); /** * Overloads the exponentiation operator for a Torch Tensor and an integer exponent * @param output Tensor * @param Tensor to take the power of * @param integer exponent */ EXPORT_C void torch_tensor_power_int ( torch_tensor_t output , const torch_tensor_t tensor , const torch_int_t exponent ); /** * Overloads the exponentiation operator for a Torch Tensor and a floating point * exponent * @param output Tensor * @param Tensor to take the power of * @param floating point exponent */ EXPORT_C void torch_tensor_power_float ( torch_tensor_t output , const torch_tensor_t tensor , const torch_float_t exponent ); // ============================================================================ // --- Other operators for computations involving tensors // ============================================================================ /** * Overloads the summation operator for a Torch Tensor * @param output Tensor * @param Tensor to sum the values of */ EXPORT_C void torch_tensor_sum ( torch_tensor_t output , const torch_tensor_t tensor ); /** * Overloads the mean operator for a Torch Tensor * @param output Tensor * @param Tensor to take the mean over the values of */ EXPORT_C void torch_tensor_mean ( torch_tensor_t output , const torch_tensor_t tensor ); // ============================================================================= // --- Functions related to automatic differentiation functionality for tensors // ============================================================================= /** * Function to reset the gradient values of a Torch Tensor to zero * @param Torch Tensor to zero the gradient values of */ EXPORT_C void torch_tensor_zero_grad ( torch_tensor_t tensor ); /** * Function to perform back-propagation on a Torch Tensor. * Note that the Tensor must have the requires_grad attribute set to true. * @param Tensor to perform back-propagation on * @param Tensor with an external gradient to supply for the back-propagation * @param whether the computational graph should be retained */ EXPORT_C void torch_tensor_backward ( const torch_tensor_t tensor , const torch_tensor_t external_gradient , const bool retain_graph ); /** * Function to return the grad attribute of a Torch Tensor. * @param Tensor to get the gradient of * @param Tensor for the gradient */ EXPORT_C void torch_tensor_get_gradient ( const torch_tensor_t tensor , torch_tensor_t gradient ); // ============================================================================= // --- Torch model API // ============================================================================= /** * Function to load in a Torch model from a TorchScript file and store in a * Torch Module * @param filename where TorchScript description of model is stored * @param device type used (cpu, CUDA, etc.) * @param device index for the CUDA case * @param whether gradient is required * @param whether model is being trained * @return Torch Module loaded in from file */ EXPORT_C torch_jit_script_module_t torch_jit_load ( const char * filename , const torch_device_t device_type , const int device_index , const bool requires_grad , const bool is_training ); /** * Function to run the `forward` method of a Torch Module * @param Torch Module containing the model * @param vector of Torch Tensors as inputs to the model * @param number of input Tensors in the input vector * @param vector of Torch Tensors as outputs from running the model * @param number of output Tensors in the output vector * @param whether gradient is required */ EXPORT_C void torch_jit_module_forward ( const torch_jit_script_module_t module , const torch_tensor_t * inputs , const int nin , torch_tensor_t * outputs , const int nout , const bool requires_grad ); /** * Function to delete a Torch Module to clean up * @param Torch Module to delete */ EXPORT_C void torch_jit_module_delete ( torch_jit_script_module_t module ); #endif /* C_TORCH_H*/","tags":"","url":"sourcefile/ctorch.h.html"},{"title":"User Guide – FTorch","text":"Welcome to the FTorch user documentation! FTorch is a library for coupling PyTorch machine learning (ML) models to Fortran, enabling\nthe development of hybrid models that combine high-performance scientific computing with\nmodern ML techniques. It has been used in multiple scientific projects . If you make use of FTorch in your work please cite our publication: Atkinson et al., (2025). FTorch: a library for coupling PyTorch models to Fortran. Journal of Open Source Software , 10(107), 7602, https://doi.org/10.21105/joss.07602 This section of the documentation is designed to help users familiarise themselves with\nthe library, how to install and use it, and the community around FTorch.\nThe site also contains detailed API documentation for those using FTorch in projects. Getting Started Installation Guide Worked Examples Usage Guidance Documentation Map Installation & Build Usage Guidance Developer Guide Resources & Community External Resources FTorch on GitHub Case Studies The LibTorch C++ API documentation","tags":"","url":"page/index.html"},{"title":"Installation – FTorch","text":"FTorch Installation & Build This section covers how to build and install FTorch on various platforms. FTorch is built and installed using the CMake build system.\nGuidance for doing this can be found on the General Installation page, and should be sufficient\nfor most users, though further pages contain additional details for specific systems,\narchitectures, and configurations. Quick Links General Installation System-Specific Guidance GPU Support HPC Guidance","tags":"","url":"page/installation/index.html"},{"title":"Installation and Build – FTorch","text":"Installation and Build Installation of FTorch is performed using the CMake build system.\nThis is controlled by the CMakeLists.txt file in the root FTorch directory. Dependencies Basic Installation Instructions CMake Build Options Building FTorch as a Shared vs. Static library Dependencies To install FTorch requires the following to be installed on the system: CMake >= 3.15 Fortran (2008 standard compliant), C++ (must fully support C++17), and C compilers LibTorch 1 or PyTorch Additional dependencies of the test suite FTorch's test suite has some additional dependencies. You will also need to install the unit testing framework pFUnit . FTorch's test suite requires that PyTorch has been\n  installed, as opposed to LibTorch. We recommend installing torchvision in\n  the same command (e.g., pip install torch torchvision ). 2 Doing so\n  ensures that torch and torchvision are configured in the same way. Other Python modules are installed automatically upon building the tests. Basic Installation Instructions The following instructions assume a Unix system.\nFor installation on Windows, Apple Silicon, Conda Environments, or Codespaces refer to\nthe system-specific guidance as the process may differ. To build the library, first clone it from GitHub to your local machine using either ssh: git clone git@github.com:Cambridge-ICCS/FTorch.git or https: git clone https://github.com/Cambridge-ICCS/FTorch.git Then navigate to the FTorch directory and create a build directory: cd FTorch\nmkdir build cd build From here invoke CMake with the Release build type option, plus any other options as\nrequired from the table below .\nNote: you will likely need to provide at least the CMAKE_PREFIX_PATH flag\nplus any other options to enforce a consistent build on your machine: cmake .. -DCMAKE_BUILD_TYPE = Release Finally build and install the library using: cmake --build . --target install or, if you want to separate these steps: cmake --build .\ncmake --install . Note: If using a machine capable of running multiple jobs this can be sped up by\nadding --parallel [<jobs>] or -j [<jobs>] to the cmake build command.\nSee the CMake documentation for more information. Installation will place the following directories at the install location: include/ - contains C header and Fortran mod files lib/ - contains cmake directory and .so / .a files Note: Depending on your system and architecture lib may be lib64 , and \n  you may have .dll files or similar. CMake build options The following CMake flags are available and can be passed as arguments through -D<Option>=<Value> in order to tailor your build: Option Value Description CMAKE_Fortran_COMPILER gfortran / ifx / ifort Specify a Fortran compiler to build the library with. This should match the Fortran compiler you're using to build the code you are calling this library from. 3 CMAKE_C_COMPILER gcc / icx / icc Specify a C compiler to build the library with. 3 CMAKE_CXX_COMPILER g++ / icx / icpc Specify a C++ compiler to build the library with. 3 CMAKE_PREFIX_PATH </path/to/libTorch/> Location of Torch installation 4 CMAKE_INSTALL_PREFIX </path/to/install/lib/at/> Location at which the library files should be installed. By default this is /usr/local CMAKE_BUILD_TYPE Release / Debug Specifies build type. The default is Debug , use Release for production code CMAKE_BUILD_TESTS TRUE / FALSE Specifies whether to compile FTorch's test suite as part of the build. 5 GPU_DEVICE NONE / CUDA / HIP / XPU / MPS Specifies the target GPU architecture (if any) 6 MULTI_GPU ON / OFF Specifies whether to build the tests that involve multiple GPU devices ( ON by default if CMAKE_BUILD_TESTS and GPU_DEVICE are set). For example, to build using the GNU compilers and install to $HOME/FTorchbin/ we would need to run: cmake .. \\ -DCMAKE_BUILD_TYPE = Release \\ -DCMAKE_Fortran_COMPILER = gfortran \\ -DCMAKE_C_COMPILER = gcc \\ -DCMAKE_CXX_COMPILER = g++ \\ -DCMAKE_PREFIX_PATH = /path/to/venv/lib/python3.xx/site-packages/torch/ \\ -DCMAKE_INSTALL_PREFIX = ~/FTorchbin Once this completes you should be able to generate the code and install using: cmake --build . --target install Building FTorch as a Shared vs. Static library FTorch can be built as either a shared or static library depending\non how you want to link it with your own application. By default, FTorch builds as a shared library: cmake -DBUILD_SHARED_LIBS = ON ... This configuration dynamically links FTorch with its dependencies (including\nLibTorch) at runtime. A shared build is recommended for most users because: Multiple programs can use the same FTorch installation. You can update FTorch without recompiling dependent executables. If you prefer to include FTorch directly inside your executable, you can build\nit statically: cmake -DBUILD_SHARED_LIBS = OFF ... A static build links all FTorch code directly into your application executable.\nThis can be useful when: You want a single self-contained executable. You are installing FTorch on an HPC system and intend to use it in an\napplication for which you want maximum reproducibility (i.e., the FTorch\nversion embedded in your application is \"frozen\"). To this second point on building FTorch as a static library, a brief\njustification on applications for which this may be relevant is covered here . For more general details on shared and static libraries as well as their\ntrade-offs, see shared vs. static\nlibraries , a case for static\nlinking ,\nand static linking considered\nharmful Note For discussion on how to build and link another code to the FTorch library see the generic usage example , and the detailed discussion\non the HPC page . The minimal example provided downloads the CPU-only Linux Nightly binary. Alternative versions to match hardware\nmay be required. ↩ For more details, see here . ↩ This may need to be the full path to the compiler if CMake\ncannot locate it by default. ↩ ↩ ↩ The path to the Torch installation needs to allow CMake to locate the relevant Torch CMake files. If Torch has been installed as LibTorch then this should be the absolute path to the unzipped LibTorch distribution.\nIf Torch has been installed as PyTorch in a Python venv (virtual environment) ,\ne.g. with pip install torch , then this should be </path/to/venv/>lib/python<3.xx>/site-packages/torch/ . You can find the location of your torch install by importing torch from your Python environment ( import torch ) and running print(torch.__file__) ↩ To run the tests, your system's MPI must support use mpi_f08 . Note that OpenMPI < v2.0 and MPICH < v3.1 do not support this module. ↩ This must match the installed PyTorch/Libtorch library. When installing with pip, the index-url flag can be used to ensure a CPU-only or GPU-enabled version is installed, e.g. pip install torch --index-url https://download.pytorch.org/whl/cpu URLs for alternative versions can be found here . ↩","tags":"","url":"page/installation/general.html"},{"title":"System-Specific Guidance – FTorch","text":"System-Specific Guidance Windows Apple Silicon Conda GitHub Codespace Windows If possible we recommend using the Windows Subsystem for Linux (WSL) to build\nthe library. In this case the build process is the same as for a Linux environment. To build in native Windows using Visual Studio and the Intel Fortran resources the following additional dependencies are required: Visual Studio ensuring C++ tools are selected and installed. Intel OneAPI Basetoolkit Intel OneAPI HPC toolkit ensuring that the Intel Fortran compiler and VS integration is selected. Note that LibTorch is not supported for the GNU Fortran compiler with MinGW. Installation Load the Intel Fortran compilers using setvars.bat which is found in the Intel compiler install\ndirectory (see the Intel\ndocs )\nfor more details. From cmd this can be done with: call \"C:\\Program Files (x86)\\Intel\\oneAPI\\setvars.bat\" FTorch can then be built according to the regular CMake instructions ,\nwith the addition of -G \"NMake Makefiles\" . So the basic command to build from cmd becomes: cmake - G \"NMake Makefiles\" - DCMAKE_PREFIX_PATH = \"C:\\Users\\<path-to-libtorch-download>\\libtorch\" - DCMAKE_BUILD_TYPE = Release .. cmake -- build . cmake -- install . Note: In a Windows environment administrator privileges are required for the default install location. The following is an example cmd script that installs FTorch and runs the integration tests. It assumes you have already\ninstalled CMake, git, the Intel compilers, and Visual Studio. rem disable output for now ECHO ON rem load intel compilers call \"C:\\Program Files (x86)\\Intel\\oneAPI\\setvars.bat\" rem download ftorch git clone https : // github . com / Cambridge - ICCS / FTorch . git cd FTorch rem make venv python - m venv . ftorch rem activate the environment call . ftorch \\ Scripts \\ activate rem install torch pip install torch torchvision torchaudio rem enable output ECHO ON rem run cmake to generate build scripts rem ( update CMAKE_PREFIX_PATH depending on location of ftorch venv ) cmake - Bbuild - G \"NMake Makefiles\" - DCMAKE_Fortran_FLAGS = \"/fpscomp:logicals\" &#94; - DCMAKE_PREFIX_PATH = \"C:\\Users\\Quickemu\\Downloads\\FTorch\\.ftorch\\Lib\\site-packages\" &#94; - DCMAKE_BUILD_TYPE = Release &#94; - DCMAKE_BUILD_TESTS = True &#94; - DCMAKE_Fortran_COMPILER = ifx - DCMAKE_C_COMPILER = icx - DCMAKE_CXX_COMPILER = icx rem build and install ftorch cmake -- build build cmake -- install build rem quit if this raises an error if % errorlevel % neq 0 exit / b % errorlevel % ECHO OFF rem add ftorch and pytorch libs to path rem ( update these depending on where you installed ftorch and where you created the venv ) set PATH = C : \\ Users \\ Quickemu \\ Downloads \\ FTorch \\ . ftorch \\ Lib \\ site - packages ; % PATH % set PATH = C : \\ Program Files ( x86 ) \\ FTorch \\ bin ; % PATH % set PATH = C : \\ Users \\ Quickemu \\ Downloads \\ FTorch \\ . ftorch \\ Lib \\ site - packages \\ torch \\ lib ; % PATH % cd .. rem run integration tests ECHO ON run_integration_tests . bat if % errorlevel % neq 0 exit / b % errorlevel % We recommend Windows users review the Windows CI workflow ( .github/workflows/test_suite_windows.yml ) for more\ninformation, as this provides another example of how to build and run FTorch and its integration tests. If using powershell the setvars and build commands become: cmd / k '\"C:\\Program Files (x86)\\Intel\\oneAPI\\setvars.bat\" && powershell' cmake - G \"NMake Makefiles\" - DCMAKE_PREFIX_PATH = \"C:\\Users\\<path-to-libtorch-download>\\libtorch\" - DCMAKE_BUILD_TYPE = Release .. cmake -- build . cmake -- install . Apple Silicon FTorch can successfully be built on Apple Silicon machines, including utilising the MPS backend,\nfollowing the regular CMake instructions . To leverage MPS include the -DGPU_DEVICE=MPS CMake flag at build time. Conda Conda is not our preferred approach for managing dependencies, but for users who want\nan environment to build FTorch in we provide guidance and environment files in a conda/ directory.\nNote that these environments are not minimal and will install Python, PyTorch,\nand other modules required for running the tests and examples. GitHub Codespace It is possible to try FTorch through an interactive browser session without\ninstalling anything locally using GitHub Codespace.\nFull instructions are in the codespace/ directory.","tags":"","url":"page/installation/systems.html"},{"title":"GPU Support – FTorch","text":"GPU Support Dependencies Changes Required Multiple GPUs FTorch supports running on a number of GPU hardwares by utilising the PyTorch/LibTorch\nbackends.\nCurrently supported are: CUDA (NVIDIA) HIP (AMD/ROCm) MPS (Apple Silicon) XPU (Intel) Dependencies To run FTorch on different hardwares requires downloading the appropriate version of\nTorch compatible with the device you wish to target. This can be done for all hardwares by using a pip-installed version, and for CUDA and\nHIP with a LibTorch binary. Installation using pip If installing using pip the appropriate version for the hardware can be specified by\nusing the --index-url option during pip install . Instructions for CPU, CUDA, and HIP/ROCm can be found in the installation matrix on pytorch.org . For XPU use --index-url https://download.pytorch.org/whl/test/xpu , whilst for MPS\npip should automatically detect the hardware and install the appropriate version. LibTorch binary For pure LibTorch binaries see the installation matrix on pytorch.org .\nCurrently standalone LibTorch binaries are only provided for CPU, CUDA, and HIP/ROCm. Changes Required In order to run a model on GPU, three main changes are required: 1) Build for the target device When building FTorch, specify the target GPU architecture using the GPU_DEVICE CMake argument : cmake .. -DGPU_DEVICE = <CUDA/HIP/XPU/MPS> The default setting is equivalent to cmake .. -DGPU_DEVICE = NONE i.e., CPU-only. 2) Save TorchScript models on the target device When saving a TorchScript model, ensure that it is on the GPU.\nFor example, when using pt2ts.py ,\nthis can be done by passing the --device_type <cpu/cuda/hip/xpu/mps> argument. This\nsets the device_type variable, which has the effect of transferring the model\n(and any input arrays used in tracing/testing) to the specified GPU device in the\nfollowing lines: if device_type != \"cpu\" : trained_model = trained_model . to ( device_type ) trained_model . eval () trained_model_dummy_input_1 = trained_model_dummy_input_1 . to ( device_type ) trained_model_dummy_input_2 = trained_model_dummy_input_2 . to ( device_type ) 3) Specify the target device from FTorch When calling torch_tensor_from_array and torch_model_load in Fortran,\nthe device type for the input tensor(s) and model should be set to the appropriate\ndevice type ( torch_kCUDA , torch_kHIP , torch_kXPU , or torch_kMPS ) rather\nthan torch_kCPU . The following snippet shows how you would load a model to a CUDA device, create tensors,\nand run inference: ! Load in from Torchscript to device call torch_model_load ( torch_net , 'path/to/saved/model.pt' , torch_kCUDA ) ! Cast Fortran data to Tensors call torch_tensor_from_array ( input_tensors ( 1 ), in_data , torch_kCUDA ) call torch_tensor_from_array ( output_tensors ( 1 ), out_data , torch_kCPU ) ! Inference call torch_model_forward ( torch_net , input_tensors , output_tensors ) Note: You do not need to change the device type for the output tensors as we\n      want them to be on the CPU for subsequent use in Fortran. Multiple GPUs For the case of having multiple GPU devices you should also specify a device index\nof the GPU to be targeted for any input tensors and models in addition to\nthe device type. This argument is optional and will default to\ndevice index 0 if unset. For example, the following code snippet sets up a Torch tensor with CUDA GPU\ndevice index 2: device_index = 2 call torch_tensor_from_array ( in_tensors ( 1 ), in_data , tensor_layout , & torch_kCUDA , device_index = device_index ) Whereas the following code snippet sets up a Torch tensor with (default) CUDA\ndevice index 0: call torch_tensor_from_array ( in_tensors ( 1 ), in_data , tensor_layout , & torch_kCUDA ) Similarly for the HIP or XPU device type.\nNote that MPS does not currently support multiple devices, so the\ndefault device index should always be used. See the MultiGPU example for a worked example of running with multiple devices from one code.","tags":"","url":"page/installation/gpu.html"},{"title":"HPC Support – FTorch","text":"Guidance for use in High Performance Computing (HPC) Installation Building and Linking Parallelism A common application of FTorch (indeed, the driving one for development) is the\ncoupling of machine learning components to large scientific codes/models running on\nHPC systems. Here we provide some guidance to help with deployment in these settings. Installation The basic installation procedure is the same as described in the main documentation and README, cloning from GitHub and building using CMake. Obtaining LibTorch For use on a HPC system we advise linking to an installation of LibTorch rather than\ninstalling full PyTorch.\nThis will reduce the dependencies and remove any requirement of Python.\nLibTorch can be obtained from the PyTorch website .\nThe assumption here is that any Python/PyTorch development is done elsewhere with a\nmodel being saved to TorchScript for subsequent use by FTorch. Once you have successfully tested and deployed FTorch in your code we recommend speaking\nto your administrator/software stack manager to make your chosen version of libtorch\nloadable as a module .\nThis will improve reproducibility and simplify the process for future users on your\nsystem.\nSee the information below for further details. Environment management It is important that FTorch is built using the same environment and compilers as the\nmodel/code in which it will be used. Most HPC systems manage software environments through Environment Modules .\nIt is important to load the same modules when building FTorch as you would\nwhen building your main code.\nThis will usually be done by using the same module commands as you would use to build\nyour code/model: module purge\nmodule load ... Alternatively you may be provided with a shell script that runs these commands and sets\nenvironment variables etc. that can be sourced: source model_environment.sh Complex codes with custom build systems may obfuscate this process, and you might need\nto probe the build system/scripts for this information.\nIf in doubt speak to the maintainer of the software for your system, or the manager of\nthe software stack on the machine. As a minimal requirement you will need to load modules for compilers and CMake.\nThese may be installed by the base OS/environment, but it is recommended to use modules\nfor reproducibility, access to a wider range of versions, and to match the compilers\nused to build the main code.\nBecause of the need to match compilers it is strongly recommended to specify the CMake flags CMAKE_Fortran_COMPILER , CMAKE_C_COMPILER , and CMAKE_CXX_COMPILER when building. Further functionalities may require loading of additional modules such as an\nMPI installation and CUDA. LibTorch as a module Once you have a working build of FTorch it is advisable to pin the version of LibTorch\nand make it a loadable module to improve reproducibility and simplify the build process\nfor subsequent users on the system. This can be done by the manager of the software stack, after which you can use module load libtorch or similar instead of downloading the binary from the PyTorch website. Note that the module name on your system may include additional information about the\nversion, compilers used, and a hash code as well as the name libtorch . You should always verify that the version of LibTorch used to build FTorch is\ncompatible with the version used to build and train your PyTorch model and save to\nTorchScript. If a newer version is used in Python it may be neccessary to provide the\nmatching version in the software stack. FTorch as a module If there are many users who want to use FTorch on a system it may be worth building\nand making it loadable as a module itself.\nThe module should be labelled with the compilers it was built with (see the importance of environment matching ) and automatically load\nany subdependencies (e.g. LibTorch, CUDA) For production builds, ensure that FTorch is built using the CMAKE_BUILD_TYPE=Release flag to enable optimisations.\nIt is also recommended to run FTorch's unit tests after building to verify successful\ninstallation.\nFor details on running FTorch's unit and integration tests after building, see the testing documentation . Once complete it should be possible to: module load ftorch or similar.\nLoading an ftorch module should also add to the LD_LIBRARY_PATH and CMAKE_PREFIX_PATH , rather than requiring the user to specify them manually as\ndiscussed in building and linking below. Building and Linking Whilst we describe how to link to FTorch using CMake to build a project in our generic usage example ,\nmany HPC codes rely on make or more elaborate custom build systems.\nTo build a project with make or similar you need to include the FTorch's\nheader ( .h ) and module ( .mod ) files and link the executable\nto the Ftorch library (e.g., .so , .dll , .dylib depending on your system) when\ncompiling. To compile with make use the following compiler flag for any files that\nuse ftorch to include the module and header files.\nThis is often done by appending to an FCFLAGS compiler flags variable or similar: FCFLAGS += \" -I<path/to/FTorch/install/location>/include/ftorch\" When compiling the final executable add the following linker flag.\nThis is often done by appending to an LDFLAGS linker flags variable or similar: LDFLAGS += \" -L<path/to/FTorch/install/location>/lib -lftorch\" pkg-config If you have pkg-config installed,\nyou can easily query the compiler and linker flags of FTorch instead of specifying\nthem manually as above.\nFTorch provides a standard pkg-config file in the lib/ installation for this purpose allowing users to instead use: FCFLAGS += \" $( pkg-config --cflags </path/to/FTorch/install/location>/lib/pkgconfig/ftorch.pc ) \" LDFLAGS += \" $( pkg-config --libs </path/to/FTorch/install/location>/lib/pkgconfig/ftorch.pc ) \" or, further simplified by extensing teh PKG_CONFIG_PATH environment variable: export PKG_CONFIG_PATH = ${ PKG_CONFIG_PATH } :</path/to/FTorch/install/location>/lib/pkgconfig/ FCFLAGS += \" $( pkg-config --cflags ftorch ) \" LDFLAGS += \" $( pkg-config --libs ftorch ) \" Adding to the runtime library path You may also need to add the location of the dynamic library .so files to your LD_LIBRARY_PATH environment variable unless installing in a default location: export LD_LIBRARY_PATH = $LD_LIBRARY_PATH :<path/to/FTorch/installation>/lib FTorch depends on Torch, and the RPATH of the FTorch shared library (i.e., libftorch.so ) generated during CMake installation contains the path to its\nTorch shared library dependency. The dynamic linker of the GNU C library\nsearches for shared libraries first using the RPATH (see ld.so - Linux\nmanual page for details),\nso the correct Torch dependency should be found automatically; however, if you\nencounter issues, you may have to modify the LD_LIBRARY_PATH environment\nvariable to also include the path to the Torch library (in addition to the\npath to FTorch described above): export LD_LIBRARY_PATH = $LD_LIBRARY_PATH :<path/to/Torch/installation>/lib Note Depending on your system and architecture lib may be lib64 or something similar. On MacOS devices you will need to set DYLD_LIBRARY_PATH rather than LD_LIBRARY_PATH . Note If you wish to build your model/code with static linking it is possible to build FTorch \nas both a shared or a static library. For more information see the static vs. shared guidance on the main installation page. Debug builds Whilst experimenting, it may be useful to build FTorch using the CMAKE_BUILD_TYPE=Debug CMake flag (see CMAKE_BUILD_TYPE and CMAKE_<LANG>_FLAGS )\nto allow useful error messages and investigation with debugging tools. Parallelism If you are investigating running FTorch on HPC then you are probably interested\nin improving computational efficiency via parallelism. For a worked example of running with MPI, see the associated example . For information on running on GPU architectures, see the GPU user guide page and/or the MultiGPU example .","tags":"","url":"page/installation/hpc.html"},{"title":"Usage – FTorch","text":"Usage Examples Generic Example Worked Examples API Documentation Tensor API Transposing data Model API (WIP) Optimizers API (WIP) Training Offline Online Troubleshooting Examples The Overview & Generic Example page walks\nthrough the process of saving a model from Python and using it within Fortran,\nincluding how to build and link the code using FTorch to the library.\nThis is the best place to start to understand how FTorch works and how to use it. The Worked Examples page summarises the\ncomprehensive set or practical examples included in the FTorch repository.\nThese demonstrate how to use FTorch for model coupling, tensor manipulation, with GPU\nacceleration, with MPI, and more.\nIt is advised to work through some of these to check your installation and better\nunderstand how to use FTorch. API Documentation These pages contain detailed documentation of the various component APIs included in FTorch.\nCurrently there is detail for Tensors , with Models and\nOptimizers being work in progress. Training These pages discuss the conceptual ideas around using FTorch for coupling models\ntrained offline , and training models online .","tags":"","url":"page/usage/index.html"},{"title":"Generic Example – FTorch","text":"Generic Example This page provides abstract guidance to the general process of using FTorch.\nIt covers the full process of saving a model from PyTorch and coupling it into a Fortran code.\nTo see this process in context we strongly advise following the Worked Examples . Overview of the interfacing process In order to use FTorch users will typically need to follow these steps: Save a PyTorch model as TorchScript . Write Fortran using the FTorch bindings to use the model from within Fortran. Build and compile the code, linking against the FTorch library These are outlined in detail below. 1. Saving the model as TorchScript The trained PyTorch model needs to be exported to TorchScript .\nThis can be done from within your code using the jit.script or jit.trace functionalities from within Python. If you are not familiar with these we provide a tool pt2ts.py as part of FTorch which contains an easily adaptable script to save your\nPyTorch model as TorchScript. 2. Using the model from Fortran To use the trained Torch model from within Fortran we need to import the ftorch module and use the binding routines to load the model, convert the data,\nand run inference.\nA very simple example is given below. This minimal snippet loads a saved Torch model, creates an input consisting of a 10x10 matrix of ones, and runs the model to infer output. This is for illustrative purposes only, and we recommend following the examples before writing your own code to fully explore the features. ! Import FTorch library for interfacing with PyTorch use ftorch , only : torch_model , torch_tensor , torch_kCPU , torch_delete , & torch_tensor_from_array , torch_model_load , torch_model_forward implicit none ! Generate an object to hold the Torch model type ( torch_model ) :: model ! Set up array of n_inputs input tensors and array of n_outputs output tensors ! Note: In this example there is only one input tensor (n_inputs = 1) and one !       output tensor (n_outputs = 1) integer , parameter :: n_inputs = 1 integer , parameter :: n_outputs = 1 type ( torch_tensor ), dimension ( n_inputs ) :: model_input_arr type ( torch_tensor ), dimension ( n_outputs ) :: model_output_arr ! Set up the model inputs and output as Fortran arrays real , dimension ( 10 , 10 ), target :: input real , dimension ( 5 ), target :: output ! Initialise the Torch model to be used torch_model_load ( model , \"/path/to/saved/model.pt\" , torch_kCPU ) ! Initialise the inputs as Fortran array of ones input = 1.0 ! Wrap Fortran data as no-copy Torch Tensors ! There may well be some reshaping required depending on the ! structure of the model which is not covered here (see examples) call torch_tensor_from_array ( model_input_arr ( 1 ), input , torch_kCPU ) call torch_tensor_from_array ( model_output_arr ( 1 ), output , torch_kCPU ) ! Run model forward method and Infer ! Again, there may be some reshaping required depending on model design call torch_model_forward ( model , model_input_arr , model_output_arr ) ! Write out the result of running the model write ( * , * ) output ! Clean up call torch_delete ( model ) call torch_delete ( model_input_arr ) call torch_delete ( model_output_arr ) 3. Building the code The code now needs to be compiled and linked against our installed library.\nHere we describe how to do this for two build systems, CMake and make. CMake If using CMake include the following in the CMakeLists.txt file to find the FTorch installation and link it to the executable. This can be done by adding the following to the CMakeLists.txt file: find_package ( FTorch REQUIRED ) target_link_libraries ( <executable> PRIVATE FTorch::ftorch ) message ( STATUS \"Building with Fortran PyTorch coupling\" ) and using the -DCMAKE_PREFIX_PATH=</path/to/install/location> flag when running CMake. Note If you used the CMAKE_INSTALL_PREFIX argument when building and installing the library then you should use the same path for </path/to/install/location> . Make To build with make we need to include the library and link the\nexecutable against it when compiling. For full details of the flags to set and the linking process see the HPC build pages . Running on GPUs In order to run a model on GPU, two main changes to the above process are required: When saving your TorchScript model, ensure that it is on the GPU. When calling torch_tensor_from_array in Fortran, the device for the input\n   tensor(s) should be set to torch_kCUDA , rather than torch_kCPU . For more information refer to the GPU Documentation","tags":"","url":"page/usage/generic_example.html"},{"title":"Worked Examples – FTorch","text":"Worked Examples The FTorch repository comes with a number of documented worked examples . These are designed to introduce users to FTorch and how to use the various features. A subset of the examples are used as integration tests as part of FTorch's test suite . 1) Tensor This worked example provides a simple demonstration of how to create, manipulate,\ninterrogate, and destroy instances of the torch_tensor derived type. This is\none of the core derived types in the FTorch library, providing an interface to\nthe torch::Tensor C++ class. Like torch::Tensor , the torch_tensor derived\ntype is designed to have a similar API to PyTorch's torch.Tensor class. 2) SimpleNet This worked example provides a simple but complete demonstration of how to use the library.\nIt uses simple PyTorch 'net' that takes an input vector of length 5 and applies a single\nLinear layer to multiply it by 2.\nThe aim is to demonstrate the most basic features of coupling before worrying about\nmore complex issues that are covered in later examples. 3) Resnet This worked example provides a more realistic demonstration of how to use the library,\nusing ResNet-18 to classify an image.\nAs the input to this model is four-dimensional (batch size, colour, x, y),\ncare must be taken dealing with the data array in Python and Fortran.\nSee when to transpose arrays for more details. 4) MultiIO This worked example considers a variant of the SimpleNet demo, which demonstrates how to account for\nmultiple input tensors and multiple output tensors. 5) Looping This worked example demonstrates best practices for performing inference on the same network with\ndifferent input multiple times in the same workflow. 6) MultiGPU This worked example builds on the SimpleNet demo and shows how to account for the case of sending different\ndata to multiple GPU devices. 7) MPI This worked example demonstrates how to run the SimpleNet example in the context of MPI parallelism,\nrunning the net with different input arrays on each MPI rank. 8) Autograd This worked example is currently under development. Eventually, it will demonstrate how to perform\nautomatic differentiation in FTorch by leveraging PyTorch's Autograd module.\nCurrently, it just demonstrates how to compute mathematical expressions\ninvolving Torch tensors.","tags":"","url":"page/usage/worked_examples.html"},{"title":"Tensor API – FTorch","text":"Tensor API Documentation Overview Procedures Constructors Interrogation Deallocation Manipulation Operator Overloading Overview FTorch provides a torch_tensor derived type, which exposes the\nfunctionality of the torch::Tensor C++ class. The interface is designed to be familiar to\nFortran programmers, whilst retaining strong similarity with torch::Tensor and\nthe torch.Tensor Python class. Under the hood, the torch_tensor type holds a pointer to a torch::Tensor object in C++ (implemented using c_ptr from the iso_c_binding intrinsic module). This allows us to avoid unnecessary data copies between C++ and\nFortran. Procedures Constructors We provide several subroutines for constructing torch_tensor objects. These include: torch_tensor_empty which allocates memory for the torch_tensor but does not set any values. torch_tensor_zeros which creates a torch_tensor whose values are uniformly zero. torch_tensor_ones which creates a torch_tensor whose values are\n  uniformly one. torch_tensor_from_array which allows the user to create\n  a torch_tensor with the same rank, shape, and data type as a\n  given Fortran array. Note that the data is not copied - the tensor data points to the\n  Fortran array, meaning the array must have been declared with the target property.\n  The array will continue to be pointed to even when operations are applied to the\n  tensor, so this subroutine can be used 'in advance' to set up an array for\n  outputting data. torch_tensor_from_array may be called\n  with or without the layout argument - an array which specifies the order in which\n  indices should be looped over. The default layout is [1,2,...,n] implies that data\n  will be read into the same indices by Torch. (See the transposing user guide page for more details. It is compulsory to call one of the constructors before interacting with it in\nany of the ways described in the following. Each of the constructors sets the\npointer attribute of the torch_tensor ; without this being set,\nmost of the other operations are meaningless. Interrogation We provide several subroutines for interrogating torch_tensor objects. These include: torch_tensor_get_rank which determines the rank\n  (i.e., dimensionality) of the tensor. torch_tensor_get_shape which determines the shape\n  (i.e., extent in each dimension) of the tensor. torch_tensor_get_dtype which determines the data type\n  of the tensor in terms of the enums torch_kInt8 , torch_kFloat32 , etc. torch_tensor_get_device_type , which determines the device\n  type that the tensor resides on in terms of the enums torch_kCPU , torch_kCUDA , torch_kXPU , etc. torch_tensor_get_device_index , which determines the\n  index of the device that the tensor resides on as an integer.\n  For a CPU device, this index should be set to -1 (the default).\n  For GPU devices, the index should be non-negative (defaulting to 0 ). Procedures for interrogation are implemented as methods as well as stand-alone\nprocedures. For example, tensor%get_rank can be used in place of torch_tensor_get_rank , omitting the first argument\n(which would be the tensor itself). The naming pattern is similar for the other methods\n(simply drop the preceding torch_tensor_ ). Deallocation We provide a subroutine for deallocating the memory associated with a torch_tensor object: torch_delete .\nAn interface is provided such that this can also be applied to arrays of tensors.\nCalling this subroutine manually is optional as it is called as a destructor when a torch_tensor goes out of scope. Manipulation We provide the following subroutines for manipulating the data values associated\nwith a torch_tensor object: torch_tensor_zero (aliased as class method torch_tensor%zero ), which\n  sets all the data entries associated with a tensor to zero. Note For a concrete example of how to construct, interrogate, manipulate, and delete\nTorch tensors, see the tensor manipulation worked example . Operator overloading Mathematical operators involving Tensors are overloaded, so that we can compute\nexpressions involving outputs from one or more ML models. Whilst it's possible to import such functionality with a bare use ftorch statement, the best practice is to import specifically the operators that you\nwish to use. Note that the assignment operator = has a slightly different\nnotation: use ftorch , only: assignment ( = ), operator ( + ), operator ( - ), operator ( * ), & operator ( / ), operator ( ** ) Overloaded assignment operator Particular care should be taken with the overloaded assignment operator.\nWhenever you execute code involving torch_tensor s on each side\nof an equals sign, the overloaded assignment operator should be triggered.\nAs such, if you aren't using the bare use ftorch import then you should ensure you\nspecify use ftorch, only: assignment(=) (as well as any other module members you\nrequire). For a straightforward assignment of two torch_tensor s a and b , b = a the overloaded assignment operator is called once. For overloaded operators the situation is more complex. Consider the overloaded\naddition operator (the same applies for the rest). When we execute the line c = a + b the addition is evaluated first. It is implemented as a Fortran function and its\nreturn value is an intermediate tensor. The setup is such that this is created\nusing torch_tensor_empty under the hood\n(inheriting all the properties of the tensors being added 1 ).\nFollowing this, the intermediate tensor is assigned to c .\nFinally, the finalizer for torch_tensor is called for the\nintermediate tensor because it goes out of scope. Similarly as above, in the case where you have some function func that returns\na torch_tensor , an intermediate torch_tensor will be created, assigned, and\ndestroyed because the call will have the form a = func () Other operators acting on tensors We have also exposed the operators for taking the sum or mean over the entries\nin a tensor, which can be achieved with the subroutines torch_tensor_sum and torch_tensor_mean , respectively. Note For a concrete example of how to compute mathematical expressions involving Torch\ntensors, see the autograd worked example . Note: In most cases, these should be the same, so that the operator makes\nsense. In the case of the requires_grad property, the values might differ, and\nthe result should be the logical .and. of the two values. ↩","tags":"","url":"page/usage/tensor.html"},{"title":"When to transpose data – FTorch","text":"When to transpose data Transposition of data between Fortran and C can lead to a lot of unnecessary confusion.\nThe FTorch library looks after this for you with the torch_tensor_from_array function which\nallows you to index a tensor in Torch in exactly the same way as you would in Fortran. If you wish to do something different to this then there are more complex functions\navailable and we describe here how and when to use them. Introduction - row- vs. column-major Astute users will note that Fortran is a column-major language whilst C, C++, and Python are row-major . This means that the matrix/tensor in Fortran will appear in contiguous memory on the computer as with the order of elements decided by moving down the columns before progressing in the\nrow dimension. In contrast, the same matrix/tensor defined in a row-major language will appear in\ncontiguous memory as reading along each row before progressing down the column dimension. Why does this matter? This matters for FTorch because a key feature is no-copy memory transfer between Fortran\nand Torch.\nTo do this the Fortran data that will be used in Torch is stored in memory and a pointer to the first\nelement, provided to Torch. Now, if Torch were to take this block of memory and interpret it as as a 2x2 matrix it\nwould be read in as which is the transpose of the\nmatrix we had in Fortran; likely not what we were expecting! This means we need to be careful when passing data to make sure that what we read in\nto our Torch net is correct as we expect. What can we do? There are a few approaches we can take to address this.\nThe first two of these are listed for conceptual purposes, whilst in practice we\nadvise handling this using the torch_tensor_from_array subroutine described in 3) below . 1) Transpose before passing As seen from the above example, writing out from Fortran and reading directly in to\nTorch results in us receiving the transpose. Therefore we could transpose our Fortran data immediately before passing it to Torch.\nAs a result we will read in to Torch indexed the same as in Fortran pre-transposition. For arrays of dimension 2 this can be done using the intrinsic transpose() function. For larger arrays we are required to use the 'reshape()' intrinsic to swap\nthe order of the indices.\nFor example, if we had a 3x4x5 matrix we would need to call A_to_torch = reshape(A, shape=[5, 4, 3], order=[3, 2, 1]) which could then be read by Torch as a 3x4x5 tensor. We would, of course, need to remember to transpose/reshape any output of the model\nas required. However, the transposition process involves creating a copy of the Fortran data.\nFor large matrices/tensors this can become expensive.\nIt would be better if we can pass data without having to transpose beforehand. 2) Design nets to use transpose Alternatively we could design our net to use as its input tensor meaning we can simply write from Fortran and read to Torch. However, this requires foresight and may not be intuitive - we would like to be indexing\ndata in the same way in both Fortran and Torch.\nNot doing so could leave us open to introducing bugs. 3) Use the layout argument in torch_tensor_from_array By far the easiest way to deal with the issue is not to worry about it at all! As described at the top of this page, the torch_tensor_from_array function\nprovides functionality for handling this through its optional layout argument.\nThis allows us to take data from Fortran and send it to Torch to be indexed in exactly\nthe same way by using strided access based on the shape of the array. It takes the form of an array specifying which order to read the indices in.\ni.e. [1, 2] will read i then j .\nBy passing layout = [1, 2] the data will be read into the correct indices by\nTorch. The natural ordering [1, 2, ..., n] (where n is the dimension of the\narray) is the default used by torch_tensor_from_array .\nIn cases where your tensors are indexed the same way in both Fortran and Torch, it\nshould be sufficient to just use the default value, in which case you don't need\nto pass a layout argument at all. The strided access is achieved by wrapping the torch_tensor_from_blob function\nto automatically generate strides, assuming that a straightforward conversion\nbetween row- and column-major is what should happen. i.e. if the Fortran array A is passed as torch_tensor_from_array(A, [1, 2], torch_device) the resulting Tensor will be read by Torch as Note: If, for some reason, we did want a different, transposed layout in Torch we\ncould use torch_tensor_from_array(A, [2, 1], torch_device) to get: Advanced use with torch_tensor_from_blob For more advanced options for manipulating and controlling data access when passing\nbetween Fortran and Torch see the more powerful but more complex torch_tensor_from_blob subroutine.","tags":"","url":"page/usage/transposing.html"},{"title":"Offline training – FTorch","text":"Offline Training The established approach for designing and training a model for running\ninference in FTorch is the so-called 'offline' approach, which is described in\nthe following. We are currently working on implementing an alternative online\ntraining approach - see the online training user guide page for details. Workflow Below we provide a schematic of the offline training workflow, which is broken\ndown into separate tasks below. 1. Design the ML model in PyTorch This task is done purely in Python and is not described here. See the PyTorch documentation for information on how to do this. 2. Data generation This task is done purely in Fortran. Run the Fortran model to generate training\ndata. Depending on how you write the Fortran model output to disk, there may be\nsome work required to get this training data in an appropriate format for later\nreading into Python. 3. Training This tasks is done purely in Python. Create a Python script that loads the\ntraining data that was saved to disk, splits it into training and validation\nsets, runs an optimizer, and then writes the trained model to a file with .pt extension. For more information on how to do this, see the PyTorch documentation . 4. pt2ts Having written a trained model to a file with .pt extension, use the pt2ts.py utility Python script to convert it to TorchScript format. A template pt2ts.py script can be found in the utils subdirectory. See the README there for more details on how to use the script. 5. Hybrid model In order to run inference with the trained ML model, you will need to modify\nyour Fortran model so that it uses FTorch syntax to set up appropriate torch_tensor and torch_model objects and call the torch_model_forward subroutine to run the inference. For examples of how to do this, see the examples user guides .","tags":"","url":"page/usage/offline.html"},{"title":"Online training – FTorch","text":"Online Training FTorch has supported offline training of ML models for some time (see the offline training user guide page for details). We are\ncurrently working on extending its functionality to support online training,\ntoo. This will involve exposing the backpropagation and optimization\nfunctionalities of PyTorch/LibTorch. In the following, we document a workplan of the related functionality. Each step\nbelow will be updated upon completion. Operator overloading Mathematical operators involving Tensors are overloaded, so that we can compute\nexpressions involving outputs from one or more ML models. For more information\non this, see the tensor API documentation page. Whilst it's possible to import such functionality with a bare use ftorch statement, the best practice is to import specifically the operators that you\nwish to use. Note that the assignment operator = has a slightly different\nnotation: use ftorch , only : assignment ( = ), operator ( + ), operator ( - ), operator ( * ), & operator ( / ), operator ( ** ) If you would like to make use of scalar multiplication or scalar division, this\ncan be achieved by setting the scalar as a rank-1 torch_tensor with a single entry. For example: call torch_tensor_from_array ( multiplier , [ 3.0_wp ], [ 1 ], torch_kCPU ) For a concrete example of how to compute mathematical expressions involving\nTorch tensors, see the autograd worked example . The requires_grad property For Tensors that you would like to differentiate with respect to, be sure to\nset the requires_grad optional argument to .true. when you construct it. Backpropagation Having defined some tensors with the requires_grad property set to .true. and computed another tensor in terms of an expression involving these, we can\ncompute gradients of that tensor with respect to those that it depends on. This\nis achieved using the torch_tensor_backward subroutine.\nFor example, for input tensors a and b and an output tensor Q : call torch_tensor_from_array ( a , in_data1 , tensor_layout , torch_kCPU , & requires_grad = . true .) call torch_tensor_from_array ( b , in_data2 , tensor_layout , torch_kCPU , & requires_grad = . true .) call torch_tensor_from_array ( Q , out_data1 , tensor_layout , torch_kCPU ) Q = a * b call torch_tensor_backward ( Q ) Following the example code above, we can extract gradients of Q with respect\nto a and/or b . To do this, we can use the torch_tensor_get_gradient subroutine. That is, for tensors dQda and dQdb : call torch_tensor_from_array ( dQda , out_data2 , tensor_layout , torch_kCPU ) call torch_tensor_get_gradient ( dQda , a ) call torch_tensor_from_array ( dQdb , out_data3 , tensor_layout , torch_kCPU ) call torch_tensor_get_gradient ( dQdb , b ) retain_graph argument If you wish to call the backpropagation operator multiple times then you may\nneed to make use of the retain_graph argument for torch_tensor_backward .\nThis argument accepts logical values and defaults to .false. , for consistency\nwith PyTorch and LibTorch. According to the PyTorch docs , retain_graph=.true. will not be needed in most cases, but it's useful to have\nfor the cases where it is. Zeroing gradients Having computed gradients of one tensor with respect to its dependencies,\nsuppose you wish to compute gradients of another tensor. Since the gradient\nvalues associated with each dependency are accumulated, you should zero the\ngradients before computing the next gradient. This can be achieved using the torch_tensor_zero_grad subroutine. Following the example code above: Q = a * b P = a + b call torch_tensor_backward ( Q ) ! ... call torch_tensor_zero_grad ( a ) call torch_tensor_zero_grad ( b ) call torch_tensor_backward ( P , retain_graph = . true .) ! ... Extracting gradients Note that torch_tensor_get_gradient must be called after every call to torch_tensor_backward or torch_tensor_zero_grad , even if the gradient for\nthe same tensor is being extracted into the same array. This is due to the way\nthat pointers are handled on the C++ side. Optimisation Not yet implemented. Loss functions Not yet implemented.","tags":"","url":"page/usage/online.html"},{"title":"Troubleshooting – FTorch","text":"FAQ If you are experiencing problems building or using FTorch please see below for guidance on common problems or queries. Usage Common Errors No specific subroutine Segmentation faults Usage Why are inputs/outputs to/from torch models arrays? The reason input and output tensors to/from torch_model_forward are contained in arrays is because it is possible to pass multiple input tensors to\nthe forward() method of a torch net, and it is possible for the net to return\nmultiple output tensors. The nature of Fortran means that it is not possible to set an arbitrary number\nof inputs to the torch_model_forward subroutine,\nso instead we use a single array of input tensors which can have an arbitrary length.\nSimilarly, a single array of output tensors is used. Note that this does not refer to batching data.\nThis should be done in the same way as in Torch; by extending the dimensionality of\nthe input tensors. Do I need to set torch.inference_mode() , torch.no_grad() , or torch.eval() somewhere like in PyTorch? By default we disable gradient calculations for tensors and models and place models in\nevaluation mode for efficiency.\nThese can be adjusted using the requires_grad and is_training optional arguments\nin the Fortran interface. See the API procedures documentation for torch_tensor_from_array and torch_model_load etc. for details. Common Errors No specific subroutine FTorch makes heavy use of Fortran interfaces to module procedure s to achieve overloading of subroutines such that for users do not need to call a different subroutine for each rank or type\nof tensor. If you make a call to a subroutine that fails to match anything in the interface\nyou will face a compile-time error of the form: 42 |   call torch_tensor_from_array(tensor, in_data, tensor_layout, torch_kCPU)\n      |                                                                          1\nError: There is no specific subroutine for the generic ‘torch_tensor_from_array’ at (1) The first thing to do in this instance is to inspect the interface you are trying to\ncall, and instead attempt to call the specific procedure you expect to use.\nThis can often provide more instructive error messages about what you are doing\nincorrectly int64 versions of ftorch for large tensors An alternative cause of the 'no specific subroutine' error can occur if your tensor\ndimension is larger than FTorch supports by default.\nCurrently FTorch represents the number of elements in an array dimension using\n32-bit integers. For most users this will be more than enough, but if your code\nuses large tensors (where large means more than 2,147,483,647 elements\nin any one dimension (the maximum value of a 32-bit integer)), you may you may\nneed to compile ftorch with 64-bit integers. If you do not, you may receive a\ncompile time error like the following: To fix this, rebuild FTorch with 64-bit integers by modifying the following line in src/ftorch.fypp integer , parameter :: ftorch_int = int32 ! set integer size for FTorch library to instead use 64-bit integers: integer , parameter :: ftorch_int = int64 ! set integer size for FTorch library Note: You will need to re-run fypp to regenerate the source files as described in the developer documentation Segmentation faults Missing import for overloaded assignment operator Whenever you execute code involving torch_tensor s on each side\nof an equals sign, the overloaded assignment operator should be triggered.\nAs such, if you aren't using the bare use ftorch import then you should ensure you\nspecify use ftorch, only: assignment(=) (as well as any other module members you\nrequire). See the tensor documentation for more details.","tags":"","url":"page/usage/troubleshooting.html"},{"title":"Community – FTorch","text":"FTorch Community Resources On these pages you can see the latest news from the FTorch development team, past\npresentations and workshops, some examples of use cases and publications\nthat build on and cite FTorch, and a copy of the changelog detailing any changes for each release and the latest code. To ensure that you remain up to date with the latest community developments you can subscribe to the FTorch mailing list hosted on JiscMail. Quick Links News Archive Case Studies Changelog Presentations If you make use of FTorch in your work please cite our publication: Atkinson et al., (2025). FTorch: a library for coupling PyTorch models to Fortran. Journal of Open Source Software , 10(107), 7602, https://doi.org/10.21105/joss.07602 For feature requests, bug reports, or assistance in using FTorch please get in touch via\nGitHub by either raising an issue or opening an discussion . For general enquiries please contact ICCS via iccs@maths.cam.ac.uk .","tags":"","url":"page/community/index.html"},{"title":"News archive – FTorch","text":"To ensure that you remain up to date with the latest community developments you can subscribe to the FTorch mailing list hosted on JiscMail. Slides and recordings for the events listed below, when available, can be found under presentations . Contents Upcoming Latest News Past News Upcoming FTorch developer Jack Atkinson will be presenting FTorch at the NOAA GFDL Formal Seminar Series on 8th January 2026. Latest News Cambridge Accelerate blog post following the Hybrid Modelling Workshop . Past news FTorch developer Joe Wallwork presented FTorch in a seminar at Deutsches Zentrum für Luft- und Raumfahrt (DLR) in Munich\n  on 17th December 2025. FTorch developer Jack Atkinson presented FTorch in a SciML seminar at CEMAC in Leeds on 18th July 2025. FTorch developers Jack Atkinson and Joe Wallwork were recently awarded funding from C2D3-Accelerate for a project entitled Online training of large-scale Fortran-based hybrid computational\n  science models, with applications in climate science. This grant will support development\n  for online training functionality for FTorch, as well as research visits, FTorch training\n  tutorials, and organisation of a workshop on hybrid modelling . Medium article on integrating PyTorch with the Community Earth System Model (CESM) on NVIDIA\n  Grace-Hopper 200 using FTorch.","tags":"","url":"page/community/news_archive.html"},{"title":"Presentations – FTorch","text":"Contents Talks and posters Tutorials Events Talks and posters The following presentations contain information about FTorch and its\napplications: Facilitating machine learning in Fortran using FTorch Deutsches Zentrum für Luft- und Raumfahrt (DLR) , Munich, Germany - December 2025 ( Slides ). An Overview of the FTorch Project ICCS Journal Club, Cambridge - October 2025 Slides - Recording FTorch: Facilitating Hybrid Modelling N8-CIR Seminar, Leeds - July 2025 Slides - Recording FTorch - Facilitating Hybrid Modelling Seminar at the Department of Atmospheric, Oceanic, and Planetary Physics at the University of Oxford Slides Accelerating UKCA by predicting timesteps with FTorch HPC in Weather & Climate Research session at Durham HPC Days University of Durham - June 2025 Slides Facilitating machine learning in Fortran using FTorch Seminars at the University of Reading Data Assimilation Research Centre and ECMWF, Reading -\n  May 2025 Slides FTorch: Enabling Online Training for Large-Scale Fortran Models CCfCS Polar Symposium 2025 ,\n  British Antarctic Survey, Cambridge - May 2025 Poster FTorch: A library to couple PyTorch ML models with Fortran climate models AI for Climate and Nature Community Day, Cambridge - May 2025 Slides Facilitating online training in Fortran-based climate models EuroAD, Kaiserslautern - April 2025 Slides Coupling Machine Learning to Numerical (Climate) Models Platform for Advanced Scientific Computing, Zurich - June 2024 Slides Blending Machine Learning and Numerical Simulation, with Applications to Climate Modelling Durham HPC days, Durham - May 2024 Slides Reducing the overheads for coupling PyTorch machine learning models to Fortran ML & DL Seminars, LSCE, IPSL, Paris - November 2023 Slides - Recording Reducing the Overhead of Coupled Machine Learning Models between Python and Fortran RSECon23, Swansea - September 2023 Slides - Recording Tutorials: We have given in-person training on FTorch in the form of tutorials and\nworkshops based on the companion repository https://github.com/Cambridge-ICCS/FTorch-workshop on the following occasions: ICCS Summer School ,\n  July 2025. Department of Atmospheric, Oceanic, and Planetary Physics ,\n  July 2025.\n  at the University of Oxford. Durham HPC Days ,\n  June 2025. ICCS Summer School ,\n  July 2024. Events Cambridge Hybrid Modelling Workshop - 3rd-4th September 2025 FTorch developers Jack atkinson and Joe Wallwork hosted a workshop on hybrid modelling developments and challenges in Cambridge with support from C2D3 and Accelerate .","tags":"","url":"page/community/presentations.html"},{"title":"FTorch Case Studies – FTorch","text":"FTorch has been deployed in a number of scientific projects.\nThis page collates the examples we are aware of.\nIf you have a case study you'd like to see listed here, please get in touch or open a pull request to add it! If you make use of FTorch in your work please cite our publication: Atkinson et al., (2025). FTorch: a library for coupling PyTorch models to Fortran. Journal of Open Source Software , 10(107), 7602, https://doi.org/10.21105/joss.07602 Papers and Projects using FTorch 2026 Review paper of hybrid modelling approaches for cloud microphysics - DOI: 10.1029/2025MS005341 2025 Testing winning parameterisation entries from the offline ClimSim Kaggle competition\n  for online performance in E3SM - DOI: 10.48550/arXiv.2511.20963 (preprint) Development of a data-driven boundary layer momentum scheme in single-column CAM .\n  Trained on LES schemes and outperforming existing parameterisations - DOI: 10.48550/arXiv.2511.01766 (preprint) By UKAEA emulating turbulent transport models in fusion research - Code - Conference paper Emulation of cloud resolving models to reduce computational cost in E3SM .\n  See Hu et al. (2025) - DOI: 10.1029/2024MS004618 (and code ) Review paper of hybrid modelling approaches - DOI: 10.48550/arXiv.2510.03305 (preprint) ClimSim Convection scheme in ICON giving a stable 20-year AMIP run - DOI: 10.48550/arXiv.2510.08107 (preprint) Bias correction of CESM through learning model biases compared to ERA5\\ DOI: 10.1029/2024GL114106 Implementation of nonlinear interactions in the WaveWatch III model - DOI: 10.22541/essoar.174366388.80605654 (preprint) In the GloSea6 Seasonal Forecasting Model -\n  Replacing a BiCGStab bottleneck in the code with a deep learning approach to speed up execution without compromising model accuracy.\n  See Park and Chung (2025) - DOI: 10.3390/atmos16010060 2024 Convection parameterisations in ICON -\n  Implementing machine-learnt convection parameterisations in the ICON atmospheric model\n  showing that best online performance occurs when causal relations are eliminated from the net.\n  See Heuer et al (2024) - DOI: 10.1029/2024MS004398 DataWave CAM-GW -\n  Using FTorch to couple neural net parameterisations of gravity waves to the CAM atmospheric model. MiMA Machine Learning -\n  Implementing a neural net parameterisation of gravity waves in the MiMA atmospheric model.\n  Demonstrates that nets trained near-identically offline can display greatly varied behaviours when coupled online.\n  See Mansfield and Sheshadri (2024) - DOI: 10.1029/2024MS004292","tags":"","url":"page/community/case_studies.html"},{"title":"FTorch Changelog – FTorch","text":"Changelog All notable changes to the project will be documented in this file. The format is based on Keep a Changelog ,\nand this project adheres to Semantic Versioning .\nFor specific details see the FTorch online documentation . Unreleased Added Provide support for using FTorch with pkg-config. #464 Support building FTorch as a static library. #448 Intel-ifx and Intel-ifort CI and GCC v9-13 CI. Intel CI builds OpenMPI from source to accomodate MPI integration tests #438 Expose tensor strides via get_stride method #416 Remove UNIX preprocessor variable that selected the  right C-integer type for 64bit int. Use int64_t instead #416 A new cmake option MULTI_GPU to control the build of multi GPU integration tests in #410 Support for AMD GPU backends (HIP) provided in #385 and #388 . requires_grad property hooked up to torch_tensor in #288 MPI example added in #270 Changelog file and guidance for versioning added in #313 A new tensor manipulation demo was introduced in #291 . Backpropagation implemented with torch_tensor_backward and torch_tensor_get_gradient in #286 Zeroing of gradients associated with a tensor implemented in #341 . Exposed retain_graph argument for torch_tensor_backward in #342 . Implemented torch_tensor_zero and class method alias in #338 . Provided interface for torch_tensor_from_array with default layout in #348 . Overload taking sum and mean of tensors in #344 . Changed Significant overhaul of the online FORD documentation and reduction of content in the README\n  in #459 Intel CI now uses Intel oneAPI MPI instead of OpenMPI built with Intel compilers #449 FTorch library ( libftorch.so ) produced by cmake installation now has RUNPATH that contains path to Torch library directory. Downstream targets linking against FTorch can now find the Torch dependency automatically and will compile successfully #437 . In all CMakeLists.txt where find_package(FTorch) was present, now using REQUIRE if not building tests to stop the cmake configuation process early for users who only wish to build examples in #434 fortitude dependency version increased to 0.7.0 Examples reordered to be more logical in #317 scalar multiplication/division of tensors reworked to require the scalar to first be mapped to a torch_tensor in #289 The unit tests for constructing and destroying tensors were separated out in #319 Demo numbers were bumped to account for new demo in #291 . Use interface for torch_tensor_from_array with default layout in tests and\n  examples in #348 . Error handling in ctorch.cpp improved in #347 . Removed Windows CI disabled until GitHub runner issues resolved in 50ea6d7 Patch Releases 1.0.0 - 2025-03-05 Added First release of FTorch accompanying pulication in JOSS MIT License Notable features of the library include: Representation of Torch tensors and models in Fortran Ability to run inference of Torch models from Fortran Early implementation of autograd features for Torch tensors in Fortran Comprehensive examples suite showcasing usage Testing suites: Unit, using pFUnit Integration, based on examples Code quality and static analysis checks Documentation: README.md and associated files in repository Online API and comprehensive docs build using FORD","tags":"","url":"page/community/changelog.html"},{"title":"Developer Guide – FTorch","text":"FTorch Developer Guide Interested in contributing to or extending FTorch?\nThis section provides guidance for developers, including API extension, testing, and code style. Developer Documentation Testing Suite Getting involved FTorch is an open-source project we appreciate any contributions or collaborations from\nusers that extended the functionality.\nIf you have done something but don't know where to start with open-source contributions\nplease get in touch! 1 For bugs, feature requests, and clear suggestions for improvement please open an issue . If you have built something that would be useful to others, or can\naddress an open issue , please fork the repository and open a pull request . Code of Conduct Everyone participating in the FTorch project, and in particular in the\nissue tracker, pull requests, and social media activity, is expected to treat other\npeople with respect and, more generally, to follow the guidelines articulated in the Python Community Code of Conduct . Our preferred method of contact is via Github issues and discussions,\nbut if you are unfamiliar with this you can email ICCS asking for the FTorch developers. ↩","tags":"","url":"page/developer/index.html"},{"title":"Developer Guide – FTorch","text":"Developer Guide This guide covers how to extend FTorch, contribute code, and the standards\nexpected for submissions. Developer Requirements Extending the API General guidelines Fortran source generation using Fypp GPU device handling Contribution Guidelines Code style and standards Documentation In-code Documentation Written Versioning and Changelog Developer requirements Development tools for pre-processing , code styling etc. are pip-installable using the requirements-dev file : pip install -r requirements-dev.txt In order to streamline the process of uploading we provide a pre-commit hook in .githooks/pre-commit .\nThis will check that both the .fypp and .F90 files have been updated together in a\nsynchronous fashion before a commmit can take place\n( see below ).\nUse of the hook is not automatic and needs to be enabled by the developer\n(after they have inspected it and are happy with its contents).\nHooks can be enabled by placing them in the .git directory with the following commands: cp .githooks/pre-commit .git/hooks/\nchmod +x .git/hooks/pre-commit Extending the API General guidelines If you wish to add Torch functionality from the C++ API to\nthe FTorch Fortran API the steps are generally as follows: Modify ctorch.cpp to create a C++ version of the function that accesses torch::<item> . Add the function to the header file ctorch.h Modify ftorch.fypp to create a Fortran version of the function\n  that binds to the version in ctorch.cpp . Refer to the LibTorch C++ Documentation and C++ API documentation for details of the available functions. The following guidelines should be followed whilst writing new routines: Match optional argument defaults between Fortran, C, and C++\n  ( principle of least astonishment ). Handle torch::Error and std::exception in the C++ functions by catching and\n  printing to screen before exiting cleanly. Fortran source generation using Fypp The Fortran source code in src/ftorch.F90 should not be edited directly\nbut instead generated from src/ftorch.fypp by running the Fypp preprocessor.\nThis is done to simplify the process of overloading functions for multiple data\nFypp can be installed with the developer requirements . To generate the Fortran code run: fypp src/ftorch.fypp src/ftorch.F90 Conformance of these files is checked using GitHub continuous integration and\nthe provided pre-commit hook . Note Generally it would be advisable to provide only the .fypp source code to\nreduce duplication and confusion. However, because it is a relatively small file\nand many of our users wish to \"clone-and-go\" rather than develop, we provide both. Development should only take place in ftorch.fypp , however._ GPU device handling GPU device-specific code is handled in FTorch using codes defined in the root CMakeLists.txt file: set ( GPU_DEVICE_NONE 0 ) set ( GPU_DEVICE_CUDA 1 ) set ( GPU_DEVICE_XPU 12 ) set ( GPU_DEVICE_MPS 13 ) These are chosen to be consistent with the numbering used in PyTorch . When a user specifies -DGPU_DEVICE=XPU (for example) in the FTorch CMake build, this\nis mapped to the appropriate device code (in this case 12). Device codes\nare passed to the C++ compiler in the following step: target_compile_definitions ( ${ LIB_NAME } PRIVATE GPU_DEVICE= ${ GPU_DEVICE_CODE } GPU_DEVICE_NONE= ${ GPU_DEVICE_NONE } GPU_DEVICE_CUDA= ${ GPU_DEVICE_CUDA } GPU_DEVICE_XPU= ${ GPU_DEVICE_XPU } GPU_DEVICE_MPS= ${ GPU_DEVICE_MPS } ) The chosen device code will enable the appropriate C pre-processor conditions in\nthe C++ source so that that the code relevant to that device type becomes\nactive. An example illustrating why this approach was taken is that if we removed the\ndevice codes and pre-processor conditions and tried to build with a CPU-only or\nCUDA LibTorch installation then compile errors would arise from the use of the torch::xpu module in src/ctorch.cpp . Note The HIP/ROCm backend uses the same API as the CUDA backend, so FTorch treats\nHIP as CUDA in places when calling LibTorch or PyTorch.\nThis should not concern end-users as the FTorch and pt2ts.py APIs handle this.\nFor further information see the PyTorch HIP documentation Contribution Guidelines Contributions for new features, bugfixes, or improvements should be raised in a pull\nrequest. In addition to making code contributions as described above users should also include documentation , in-code and written if\nrequired, and tests to cover any changes/additions.\nGuidance on testing can be found on the testing page .\nNotable changes should also be documented in the Changelog . Code style and standards FTorch source code is subject to a number of static analysis checks to ensure that it\nconforms to quality and legibility. These tools are a mixture of formatters and linters. The tools we use are as follows on a language-by-language basis: Fortran: fortitude C++: clang-format and clang-tidy C: clang-format and clang-tidy Python: ruff Shell: ShellCheck CMake: cmake-lint from cmake-format (Note: We do not use cmake-format's formatter) GitHub Actions workflows: zizmor Instructions on using these tools can be found in their respective documentations.\nNote that all but ShellCheck may be installed with pip as described in the developer requirements . Contributors should run these tools over their code and ensure that it conforms before\nsubmitting a pull request.\nIf there is a good reason to ignore a particular rule this should be\njustified in the pull request and ideally documented in the code.\nThere is a GitHub action as part of the continuous integration that will perform these\nchecks on all pull requests. Documentation The documentation for FTorch is generated using FORD which is installed as part of the developer requirements .\nThis builds API documentation based off of in-code docstring syntax, and\nweb-based documentation from markdown pages.\nFor detailed information refer to the FORD User Guide . To generate the documentation run: ford FTorch.md from the root of the repository. FORD uses graphviz to generate dependency graphs from the Fortran\nsource code 1 .\nFor this, you will need to install it on your system - see the installation guide for your platform. In-code Documentation Ford makes use of a docstring syntax for annotating code.\nAs a quick-start: !! is used to signify documentation. Documentation comes after whatever it is documenting (inline or subsequent line). Documentation can precede an item if designated using !> . The following examples from FORD and FTorch show this in context: subroutine feed_pets ( cats , dogs , food ) !! Feeds your cats and dogs, if enough food is available. ! Arguments integer , intent ( in ) :: cats !! The number of cats. integer , intent ( in ) :: dogs !! The number of dogs. real , intent ( inout ) :: food !! The ammount of pet food (in kilograms) which you have on hand. !... end subroutine feed_pets !> Type for holding a torch neural net (nn.Module). type torch_model type ( c_ptr ) :: p = c_null_ptr !! pointer to the neural net in memory end type torch_model Documentation of the C/C++ functions is provided\nby Doxygen .\nThis should be included in the header file ctorch.h . Written Documentation FTorch.md is the FORD index file that contains project metadata and describes\nthe project homepage.\nAdditional pages are contained in pages/ as markdown files. Notes: We need to define macros for GPU devices that are passed to ftorch.F90 via the C preprocessor in FTorch.md to match those in the CMakeLists.txt. If building documentation locally you can set the dbg: true in FTorch.md to allow\n  FORD to continue when encountering errors. Note that in this case the documentation\n  may build but be incomplete. When writing new pages you can set graph: false in FTorch.md whilst prototyping\n  to skip the time-consuming generation of dependency graphs. Versioning and Changelog FTorch has follows semantic versioning . Major releases for API changes Minor releases periodically for new features Patches for bug fixes The project version should be updated accordingly through the PACKAGE_VERSION in\nCMakeLists.txt for each new release. A log of notable changes to the software is kept in CHANGELOG.md .\nThis follows the conventions of Keep a Changelog and should\nbe updated by contributors and maintainers as part of a pull request when appropriate. Note \"Notable\" includes new features, bugfixes, dependency updates etc. \"Notable\" does not cover typo corrections, documentation rephrasing and restyling,\nor correction of other minor infelicities that do not impact the user or developer. New minor releases are made when deemed appropriate by maintainers by adding a tag to\nthe commit and creating a corresponding GitHub Release.\nThe minor number of the version should be incremented, the entry for the version\nfinalised in the changelog, and a clean log for 'Unreleased' changes created. New patch releases are made whenever a bugfix is merged.\nThe patch number of the version should be incremented, a tag attached to the commit,\nand a note made under the current 'Unreleased' patches header in the changelog. Note: If FORD cannot locate the graphviz executable (it is not a hard dependency)\nit will generate a warning. ↩","tags":"","url":"page/developer/developer.html"},{"title":"FTorch test suite – FTorch","text":"Testing FTorch's test suite includes unit tests of components, and integration\ntests based on a subset of the worked examples . Building Tests Running Tests Unit Tests Integration Tests Adding Tests Building To enable FTorch's test suite, set CMAKE_BUILD_TESTS=TRUE during the build.\nTo run the unit tests, you will need to install pFUnit and provide its\ninstall location to the CMAKE_PREFIX_PATH or as the environment variable PFUNIT_DIR : # Update `CMAKE_PREFIX_PATH` explicitly with pFUnit install directory cmake -DCMAKE_PREFIX_PATH = \"</path/to/pFUnit/build/installed/PFUNIT-VERSION>\" \\ -DCMAKE_BUILD_TESTS = True -S </path/to/FTorch> -B </path/to/FTorch/build> or # Using an environment variable with pFUnit install directory export PFUNIT_DIR = </path/to/pFUnit/build/installed/PFUNIT-VERSION>\ncmake -DCMAKE_BUILD_TESTS = TRUE -S </path/to/FTorch> -B </path/to/FTorch/build> Note that pFUnit includes the version number in the install directory name,\nso for version 4.12 that path will need to be specified as /path/to/pFUnit/build/installed/PFUNIT-4.12 , for example. Note If a GPU_DEVICE is specified but only one is available, set MULTI_GPU=OFF to skip\nthe 'multiple GPU devices' integration test. Building with tests enabled will automatically install any Python\ndependencies for the examples, so should be executed from within a virtual environment. 1 If this is not the case it will fail with appropriate warnings. Note that, whilst example 5_Looping is built if CMAKE_BUILD_TESTS=TRUE is\nspecified, it is not run as part of the integration test suite because it\ndemonstrates 'good' versus 'bad' practice, as opposed to functionality. Running Ensure that the Python virtual environment used when\nbuilding is active and then run ctest from the build directory to execute all tests.\nUse ctest arguments for greater control over the testing configuration. This will produce a report on which of the requested tests passed, and which, if any,\nfailed for your build. Unit tests Unit tests may be executed in the following ways: To run just the unit tests (tests whose names start with 'unittest') use ctest -R unittest . To run a specific unit test use ctest -R unittest_tensor_constructors_destructors , for example. Integration tests Integration tests may be executed in the following ways: To run just the integration tests (tests whose names start with 'example') use ctest -R example To run a specific integration test use ctest -R example2 , for example. Alternatively navigate to the corresponding example in ${BUILD_DIR}/examples and call ctest . Adding Tests New components should come with unit tests written using the pFUnit framework. New unit tests should be added to the test/unit/ directory and start with unittest_ . New tests need including in the CMakeLists.txt in that directory in order\n  to be built as part of the test suite. New functionalities should come with integration tests in the form of worked\nexamples. These should take the form of a new example in the examples/ directory. In addition to a CMakeLists.txt to build the example code there\n  should also be a section at the end setting up running of the example\n  using CTest. Integration test names should start with example_ New examples will also need including in examples/CMakeLists.txt Ensure the documentation on worked examples is\n  updated accordingly. If you built FTorch against LibTorch (rather than creating a\nvirtual environment) then you will need to create a virtual environment for\nthe purposes of integration testing as this script will install packages into your\nPython environment and will check that a virtual environment is in use. ↩","tags":"","url":"page/developer/testing.html"},{"title":"FTorch License – FTorch","text":"MIT License Copyright (c) 2022 Institute of Computing for Climate Science Permission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.","tags":"","url":"page/LICENSE.html"}]}